{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@jonakrusze",
    "title": "Stories by Jonatan Kruszewski on Medium",
    "link": "https://medium.com/@jonakrusze?source=rss-9d104c42e755------2",
    "author": "",
    "description": "Stories by Jonatan Kruszewski on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/1*H7UvB9BbyPEkZkwgAht5tw.jpeg"
  },
  "items": [
    {
      "title": "Migrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0",
      "pubDate": "2024-12-31 21:37:40",
      "link": "https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ed7faec2a8b6",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<h3>Migrating a Large Sass Codebase in a Monorepo To SASS ^1.80.0</h3>\n<h3>Straight to the Point: Why Avoid the Migration Tool?</h3>\n<p>Before we dive in, you might wonder, ‚ÄúWhy wouldn‚Äôt you just use the <a href=\"https://www.npmjs.com/package/sass-migrator\">Sass migration</a> tool?‚Äù</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoqvvPBiZIX8grEvwWVeVA.jpeg\"></figure><p>The answer is simple: with 13K downloads per week, it just doesn‚Äôt meet the bar. Besides, after a first run, I realized I can‚Äôt pass a whole path where all my .scss files are‚Äî so, if I need to write a script to run the migration tool, I will just do it myself. That, and also:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/239/1*YkFzeDWY2Sc3AvLZz0F6Bw.png\"><figcaption>A small screenshot of how the migration tool failed gracefully.</figcaption></figure><p>At the same time, manual control has its benefits: you can cleanup other stuff on the go, have what is called a human-on-the-loop and double check each time that the project compiles and builds properly. When you are in a monorepo, you would like to avoid breaking things unexpectedly.</p>\n<p>Undoubtedly, this made the process slower but more deliberate‚Ää‚Äî‚Ääand taught me a ton in the process.</p>\n<h3>Why Migrate at All?</h3>\n<p>With the release of Dart Sass 1.80.0, the use of @import is officially deprecated. Meaning, that all the usages need to be migrated to @use and @forward. On the positive side, it brings improved namespace management (whether you like it or not) and enhanced performance.</p>\n<p>For those using @importthis means you will need to say goodbye to them. Instead, the @use allows you to load a Sass file once and avoid polluting the global namespace, while @forward enables sharing styles across multiple modules without duplicating code.</p>\n<p>I can‚Äôt say I wasn‚Äôt aware of this: it has been in their deprecation roadmap since <strong>1.23.0</strong>, and the reason behind that change makes total sense: it solves the issue that global variables and mixins can conflict across stylesheets.</p>\n<h3>The Challenges Faced</h3>\n<h4><strong>1. I Didn‚Äôt Know How to Use the New Syntax</strong></h4>\n<p>The hardest part was simply understanding how to implement @use and @forward effectively. I was so used to @import that the new syntax felt like a whole different world.</p>\n<p>Use @use when you want to load a file and bring its variables, mixins, or functions into your current file, and @forward when you want to re-export those styles from one file to another, making them available without direct imports.</p>\n<p>@use usage:</p>\n<pre>// _colors.scss<br>$primary-color: #3498db;<br><br>// styles.scss<br>@use 'colors'; // instead of @import 'colors';<br><br>body {<br>  background-color: colors.$primary-color; // instead of $primary.color<br>}</pre>\n<p>@forward usage:</p>\n<pre>// _abstract.scss<br>@use 'colors';<br>@use 'spacing';<br><br>// _index.scss (re-exports abstract file)<br>@forward 'abstract';<br><br>// styles.scss<br>@use 'index';<br><br>.header {<br>  background-color: index.$primary-color;<br>}</pre>\n<p><em>Tip: Plan where and how you would change the most important files, then execute.</em></p>\n<h4>2. Don‚Äôt Do It in One Go.</h4>\n<p>Migrating everything at once can be overwhelming. Split the work by sections, files, folders or whatever works for you. I used about nine branches to split the work, making it easier to test and control.</p>\n<p><em>Tip: Go step by step.</em></p>\n<h4>3. Watch Out for Errors</h4>\n<p>When you‚Äôre in a monorepo, nothing lives in isolation. Modifying one SCSS file often unintentionally breaks something else in another package. Dependencies are everywhere, and fixing issues sometimes feels like playing Whac-A-Mole.</p>\n<p><em>Tip: Constantly check that the dev server compiles and the project builds. Read the errors and fix them.</em></p>\n<h4>4. Scalability vs. Speed</h4>\n<p>There‚Äôs a natural tension between wanting to refactor everything for long-term scalability and the pressure to move quickly. Sometimes, you have to choose <strong>pragmatism over perfection</strong>.</p>\n<p>While I encountered several other things to fix on the fly, I kept it minimal. The purpose was to migrate, not to fix what should have been done already. Keeping the focus on the migration is what ultimately brought the most value.</p>\n<p>Not every file needs a full makeover. If it‚Äôs something small and can be fixed quickly, go ahead. Otherwise, follow a ‚Äògood enough‚Äô approach‚Ää‚Äî‚Ääleaving unrelated issues for later (or never).</p>\n<h3>Insights and Wins</h3>\n<h4>1. Modularization Saved Me</h4>\n<p>One of the best decisions made a while ago was to break the SCSS into smaller, modular chunks. Instead of one massive file, the project had component-specific styles. This made it easier to refactor and test changes without affecting other parts of the codebase.</p>\n<h4>2. Gradual Refactoring Works</h4>\n<p>Rather than overhauling everything at once, I focused on refactoring one section at a time. This allowed me to tackle small, manageable tasks and minimize the risk of breaking something unexpectedly while keeping progress moving forward.</p>\n<h4>3. <strong>Taking Initiative Pays Off</strong>\n</h4>\n<p>Leading a migration initiative accelerates your learning and makes you the go-to expert on the process. It also helps free other developers from a slow, fragmented migration by streamlining the work and creating momentum. Stepping up to solve problems, drive progress, and manage change is an essential quality of strong leadership.</p>\n<h3>Things I‚Äôd Do Differently Next Time</h3>\n<h4>1. <strong>Plan Ahead</strong>\n</h4>\n<p>A bit more upfront planning would‚Äôve saved me time.</p>\n<h4>2. Automate Where You Can</h4>\n<p>While I mainly relied on search and replace functions, maybe next time I could write a small script to automate the job. The codebase wasn‚Äôt large enough to justify it, but maybe other situations or repos might.</p>\n<h4>3. Test, Test, Test</h4>\n<p>I learned the hard way that even small changes can have big impacts. Comprehensive tests (both unit and visual) caught countless issues I would‚Äôve otherwise missed. Having a robust UI testing tool is a good long term investment.</p>\n<h3>Closing Thoughts</h3>\n<p>Migrating a large SCSS codebase without a tool isn‚Äôt for everyone, but it‚Äôs definitely doable with the right mindset and approach. You‚Äôll face roadblocks, no doubt, but you‚Äôll also emerge with a deeper understanding.</p>\n<p>And hey, if you‚Äôre reading this and thinking, ‚ÄúWow, that sounds like a lot of work,‚Äù you‚Äôre absolutely right. But trust me, the effort is worth it. Your future self (and your teammates) will thank you.</p>\n<p>Happy coding‚Ää‚Äî‚Ääand good luck on your migration journey!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ed7faec2a8b6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6\">Migrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<h3>Migrating a Large Sass Codebase in a Monorepo To SASS ^1.80.0</h3>\n<h3>Straight to the Point: Why Avoid the Migration Tool?</h3>\n<p>Before we dive in, you might wonder, ‚ÄúWhy wouldn‚Äôt you just use the <a href=\"https://www.npmjs.com/package/sass-migrator\">Sass migration</a> tool?‚Äù</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoqvvPBiZIX8grEvwWVeVA.jpeg\"></figure><p>The answer is simple: with 13K downloads per week, it just doesn‚Äôt meet the bar. Besides, after a first run, I realized I can‚Äôt pass a whole path where all my .scss files are‚Äî so, if I need to write a script to run the migration tool, I will just do it myself. That, and also:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/239/1*YkFzeDWY2Sc3AvLZz0F6Bw.png\"><figcaption>A small screenshot of how the migration tool failed gracefully.</figcaption></figure><p>At the same time, manual control has its benefits: you can cleanup other stuff on the go, have what is called a human-on-the-loop and double check each time that the project compiles and builds properly. When you are in a monorepo, you would like to avoid breaking things unexpectedly.</p>\n<p>Undoubtedly, this made the process slower but more deliberate‚Ää‚Äî‚Ääand taught me a ton in the process.</p>\n<h3>Why Migrate at All?</h3>\n<p>With the release of Dart Sass 1.80.0, the use of @import is officially deprecated. Meaning, that all the usages need to be migrated to @use and @forward. On the positive side, it brings improved namespace management (whether you like it or not) and enhanced performance.</p>\n<p>For those using @importthis means you will need to say goodbye to them. Instead, the @use allows you to load a Sass file once and avoid polluting the global namespace, while @forward enables sharing styles across multiple modules without duplicating code.</p>\n<p>I can‚Äôt say I wasn‚Äôt aware of this: it has been in their deprecation roadmap since <strong>1.23.0</strong>, and the reason behind that change makes total sense: it solves the issue that global variables and mixins can conflict across stylesheets.</p>\n<h3>The Challenges Faced</h3>\n<h4><strong>1. I Didn‚Äôt Know How to Use the New Syntax</strong></h4>\n<p>The hardest part was simply understanding how to implement @use and @forward effectively. I was so used to @import that the new syntax felt like a whole different world.</p>\n<p>Use @use when you want to load a file and bring its variables, mixins, or functions into your current file, and @forward when you want to re-export those styles from one file to another, making them available without direct imports.</p>\n<p>@use usage:</p>\n<pre>// _colors.scss<br>$primary-color: #3498db;<br><br>// styles.scss<br>@use 'colors'; // instead of @import 'colors';<br><br>body {<br>  background-color: colors.$primary-color; // instead of $primary.color<br>}</pre>\n<p>@forward usage:</p>\n<pre>// _abstract.scss<br>@use 'colors';<br>@use 'spacing';<br><br>// _index.scss (re-exports abstract file)<br>@forward 'abstract';<br><br>// styles.scss<br>@use 'index';<br><br>.header {<br>  background-color: index.$primary-color;<br>}</pre>\n<p><em>Tip: Plan where and how you would change the most important files, then execute.</em></p>\n<h4>2. Don‚Äôt Do It in One Go.</h4>\n<p>Migrating everything at once can be overwhelming. Split the work by sections, files, folders or whatever works for you. I used about nine branches to split the work, making it easier to test and control.</p>\n<p><em>Tip: Go step by step.</em></p>\n<h4>3. Watch Out for Errors</h4>\n<p>When you‚Äôre in a monorepo, nothing lives in isolation. Modifying one SCSS file often unintentionally breaks something else in another package. Dependencies are everywhere, and fixing issues sometimes feels like playing Whac-A-Mole.</p>\n<p><em>Tip: Constantly check that the dev server compiles and the project builds. Read the errors and fix them.</em></p>\n<h4>4. Scalability vs. Speed</h4>\n<p>There‚Äôs a natural tension between wanting to refactor everything for long-term scalability and the pressure to move quickly. Sometimes, you have to choose <strong>pragmatism over perfection</strong>.</p>\n<p>While I encountered several other things to fix on the fly, I kept it minimal. The purpose was to migrate, not to fix what should have been done already. Keeping the focus on the migration is what ultimately brought the most value.</p>\n<p>Not every file needs a full makeover. If it‚Äôs something small and can be fixed quickly, go ahead. Otherwise, follow a ‚Äògood enough‚Äô approach‚Ää‚Äî‚Ääleaving unrelated issues for later (or never).</p>\n<h3>Insights and Wins</h3>\n<h4>1. Modularization Saved Me</h4>\n<p>One of the best decisions made a while ago was to break the SCSS into smaller, modular chunks. Instead of one massive file, the project had component-specific styles. This made it easier to refactor and test changes without affecting other parts of the codebase.</p>\n<h4>2. Gradual Refactoring Works</h4>\n<p>Rather than overhauling everything at once, I focused on refactoring one section at a time. This allowed me to tackle small, manageable tasks and minimize the risk of breaking something unexpectedly while keeping progress moving forward.</p>\n<h4>3. <strong>Taking Initiative Pays Off</strong>\n</h4>\n<p>Leading a migration initiative accelerates your learning and makes you the go-to expert on the process. It also helps free other developers from a slow, fragmented migration by streamlining the work and creating momentum. Stepping up to solve problems, drive progress, and manage change is an essential quality of strong leadership.</p>\n<h3>Things I‚Äôd Do Differently Next Time</h3>\n<h4>1. <strong>Plan Ahead</strong>\n</h4>\n<p>A bit more upfront planning would‚Äôve saved me time.</p>\n<h4>2. Automate Where You Can</h4>\n<p>While I mainly relied on search and replace functions, maybe next time I could write a small script to automate the job. The codebase wasn‚Äôt large enough to justify it, but maybe other situations or repos might.</p>\n<h4>3. Test, Test, Test</h4>\n<p>I learned the hard way that even small changes can have big impacts. Comprehensive tests (both unit and visual) caught countless issues I would‚Äôve otherwise missed. Having a robust UI testing tool is a good long term investment.</p>\n<h3>Closing Thoughts</h3>\n<p>Migrating a large SCSS codebase without a tool isn‚Äôt for everyone, but it‚Äôs definitely doable with the right mindset and approach. You‚Äôll face roadblocks, no doubt, but you‚Äôll also emerge with a deeper understanding.</p>\n<p>And hey, if you‚Äôre reading this and thinking, ‚ÄúWow, that sounds like a lot of work,‚Äù you‚Äôre absolutely right. But trust me, the effort is worth it. Your future self (and your teammates) will thank you.</p>\n<p>Happy coding‚Ää‚Äî‚Ääand good luck on your migration journey!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ed7faec2a8b6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6\">Migrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": ["scss", "javascript", "sass", "monorepo", "react"]
    },
    {
      "title": "Learn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics",
      "pubDate": "2024-12-17 21:08:18",
      "link": "https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ce6844f008ad",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<p>Want to learn TypeScript in one post in the shortest time possible? You can. With examples. Lots of them. Save yourself lots of hours by just reading this comprehensive guide.</p>\n<figure><img alt=\"Typescript logo with a crown\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJ73ynaAwbzLqZh-Nsf7Jw.jpeg\"></figure><h3>TS Snippets‚Äì A Quick Learning Approach</h3>\n<p>This guide features minimal text and focuses on bite-sized code examples designed to quickly elevate your proficiency in TypeScript.</p>\n<blockquote><em>Why snippets?</em></blockquote>\n<blockquote>Because examples are easier to digest than extensive documentation, keeping the essentials front and center without the extra layers. This guide is selective and opinionated‚Ää‚Äî‚Ääit won‚Äôt replace full documentation, but it will get you writing TypeScript fast. Really fast.</blockquote>\n<p>Think of it as a jumpstart. In under an hour or two, this guide takes you from zero to coding, prioritizing simplicity and practicality.</p>\n<p>Topics are categorized so you can move seamlessly between sections.</p>\n<h3>What to Expect from This Mega Post</h3>\n<p>In the upcoming sections, we will delve deeper into the following areas:</p>\n<ol>\n<li>\n<strong>Basic Usage (BU)</strong>: In this section, we‚Äôll cover TypeScript‚Äôs essential building blocks, like setting up types, defining functions and more. It‚Äôs everything you need to confidently start writing TypeScript code.</li>\n<li>\n<strong>Types (TPS), Interfaces (IN), Enums (EN)</strong>: We‚Äôll explore TypeScript‚Äôs tools for defining structured data, covering when to use types, interfaces, and enums to make your code more readable and robust.</li>\n<li>\n<strong>Inference (INFR)</strong>: Here, we‚Äôll look at TypeScript‚Äôs type inference capabilities and learn how to guide the compiler when it makes assumptions that don‚Äôt align with your intentions.</li>\n<li>\n<strong>Classes (CLS), Deriving Types from Variables (DTV) and Generics (GEN)</strong>: This section will dive into TypeScript‚Äôs object-oriented programming features, covering how to work with classes, derive new types from existing declarations, and use generics to write flexible and reusable code.</li>\n<li>\n<strong>Using with React (REA)</strong>: We‚Äôll dive into typing Components. Yep, that‚Äôs it.</li>\n<li>\n<strong>The Weird Parts (TWP) and Common Pitfalls (CPTF)</strong>: We‚Äôll dive into some quirky aspects of TypeScript that may trip you up, highlighting common pitfalls and how to avoid them for smoother coding.</li>\n</ol>\n<p>By the end, you‚Äôll have not only a deeper understanding of TypeScript but the practical know-how to apply it within your own projects and teams.</p>\n<p>You won‚Äôt be the TS hero of your team, but no one will guess you started only 40 minutes ago.</p>\n<p><strong>Let‚Äôs dive in!</strong></p>\n<h3>01. Basic Usage (BU)</h3>\n<h4>BU.01: Basic Types in TS</h4>\n<pre>let example1: string = \"Hello World!\";<br>let example2: number = 42;<br>let example3: boolean = true;<br>let example4: symbol = Symbol();<br>let example5: bigint = 123n;</pre>\n<h4>BU.02: Functions‚Ää‚Äî‚ÄäBasic notation</h4>\n<pre>function calculateSpeed(distanceInKilometers: number, timeInHours: number): number {<br>  return distanceInKilometers / timeInHours;<br>}<br><br>const calculateFuelEfficiency = (kilometers: number, liters: number): number =&gt; kilometers / liters;<br>const logCarInfo = (info: string): void =&gt; console.log(info);</pre>\n<h4>BU.03: Functions‚Ää‚Äî‚ÄäOptional parameters</h4>\n<pre>const formatCarDescription = (brand: string, model?: string): string =&gt; {<br>  if (!model) {<br>    return brand;<br>  }<br>  return `${brand} ${model}`;<br>};</pre>\n<h4>BU.04: Functions‚Ää‚Äî‚ÄäDefault parameters</h4>\n<pre>const createCar = (brand: string, year: number = 2024): string =&gt; {<br>  return `${brand}, Year: ${year}`;<br>};</pre>\n<h4>BU.05: Objects: Typing Object Literals (inline)</h4>\n<pre>const displayCarInfo = (car: { brand: string; year: number }): string =&gt; {<br>  return `${car.brand}, Year: ${car.year}`;<br>};</pre>\n<h4>BU.06: Objects: Typing Objects in own type</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const displayCarInfo = (car: Car): string =&gt; {<br>  return `${car.brand}, Year: ${car.year}`;<br>};</pre>\n<h4>BU.07: Objects: Making properties optional</h4>\n<pre>type Car = {<br>  brand: string;<br>  model?: string;<br>};<br><br>const describeCar = (car: Car): void =&gt; {<br>  const { brand, model } = car;<br>  if (model) {<br>    console.log(`${brand} ${model}`);<br>    return;<br>  }<br>  console.log(`${brand}`);<br>};</pre>\n<h4>BU.08: Objects: Using Record for Dynamically Typing</h4>\n<pre>const carFeatures: Record&lt;string, string&gt; = {};<br><br>carFeatures.color = \"Red\";<br>carFeatures.transmission = \"Automatic\";<br>carFeatures.condition = \"New\";</pre>\n<h4>BU.09: Arrays‚Ää‚Äî‚ÄäBasic notation</h4>\n<p>Prefer the [] syntax instead of the Array&lt;&gt; one</p>\n<pre>type CarInventory = {<br>  dealerId: string;<br>  carBrands: string[]; // alternatively, Array&lt;string&gt;<br>};</pre>\n<h4>BU.10: Arrays of objects</h4>\n<p>Prefer to define array of objects as types</p>\n<pre>type Feature = {<br>  name: string;<br>  description: string;<br>};<br><br>type CarModel = {<br>  brand: string;<br>  year: number;<br>  features: Feature[];<br>};<br><br>const processCarModel = (carModel: CarModel) =&gt; {<br>  // Do something with the car model in here<br>};<br><br>processCarModel({<br>  brand: \"Toyota\",<br>  year: 2024,<br>  features: [<br>    { name: \"Safety Rating\", description: \"5 stars\" },<br>    { name: \"Fuel Efficiency\", description: \"30 km/L\" },<br>  ],<br>});</pre>\n<h4>BU.11: Rest params</h4>\n<p>Treat them as array</p>\n<pre>export function listCarModels(...models: string[]): string {<br>  return models.join(\", \");<br>}</pre>\n<h4>BU.12: Tuples</h4>\n<p>Tuples are arrays of fixed length. Not necessarily 2 like in some coding languages. For example, useState returns a tuple.</p>\n<pre>const setCarDetails = (car: [string, number]) =&gt; {<br>  const brand = car[0];<br>  const year = car[1];<br>  console.log(`Car: ${brand}, Year: ${year}`);<br>};<br><br>setCarDetails([\"Toyota\", 2024]);</pre>\n<h4>BU.13: Using Optional Tuple members in TS</h4>\n<pre>const setCarSpecs = (specs: [string, number, number?]) =&gt; {<br>  const brand = specs[0];<br>  const year = specs[1];<br>  const kilometrage = specs[2];<br><br>  console.log(`Car: ${brand}, Year: ${year}${kilometrage !== undefined ? `, Kilometrage: ${kilometrage} km` : ''}`);<br>};<br><br>setCarSpecs([\"Honda\", 2024]);<br>setCarSpecs([\"Ford\", 2023, 15000]);</pre>\n<h4>BU.14: Using `any`</h4>\n<p>Don‚Äôt. The only placed allowed is when catching an error.</p>\n<pre>try {<br>  someDangerousFunctionThatMightThrow();<br>} catch (error: any) { // Acceptable use of `any`<br>  console.error(\"Caught an error:\", error.message);<br>}</pre>\n<h4>BU.15: Typing an Event Listener</h4>\n<p>Void just doesn‚Äôt care what you return. Better than any for functions.</p>\n<pre>const addClickEventListener = (listener: (this: Document, ev: MouseEvent) =&gt; void) =&gt; {<br>  document.addEventListener(\"click\", listener);<br>};<br><br>addClickEventListener(() =&gt; {<br>  console.log(\"Clicked!\");<br>});<br><br>// TypeScript will catch this as an error<br>addClickEventListener(<br>  // @ts-expect-error<br>  \"abc\" // Incorrect type<br>);</pre>\n<h4>BU.16: Typing sets</h4>\n<pre>const carBrands = new Set&lt;string&gt;();</pre>\n<h4>BU.17: Typing Maps</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const carMap = new Map&lt;number, Car&gt;();<br><br>carMap.set(1, { brand: \"Toyota\", year: 2024 });<br>carMap.set(2, { brand: \"Ford\", year: 2023 });</pre>\n<h4>BU.18: Typing Json.parse</h4>\n<pre>const parsedCarData: { brand: string; year: number; } = JSON.parse('{\"brand\": \"Honda\", \"year\": 2024}');</pre>\n<pre>async function fetchData(): Promise&lt;number&gt; {<br>  const response = await fetch('https://api.example.com/data');<br>  const data = await response.json(); //option b, type data<br>  return data;<br>}</pre>\n<h4>BU.20: Using Union types</h4>\n<p>Union types are the ‚Äúor‚Äù operator of TypeScript:</p>\n<pre>function getCarDetails(brand: string | null) {<br>  if (brand !== null) {<br>    return `Car: ${brand}`;<br>  }<br><br>  return \"Unknown Car\";<br>}</pre>\n<h3>02. Types, Interfaces, Enums</h3>\n<h4>Objects introduction</h4>\n<p>Objects in TypeScript can be typed using either type or interface. There is a never ending war about ‚Äúwhich one is best‚Äù the truth is, just pick one and be consistent.</p>\n<p>Both are similar, but type is more flexible for unions and complex types, while interface is extendable and better for defining class structures.</p>\n<p>For the sake of this opinionated guide, we will prefer types, but also will explain interfaces.</p>\n<h4>Types vs. Interfaces</h4>\n<ul>\n<li>Interfaces uses extend, Types uses &amp; to add properties to a definition</li>\n<li>Types match React‚Äôs declarative syntax a little bit better</li>\n<li>Interfaces can only type classes or objects. Types can represent other elements besides objects.</li>\n<li>Interfaces are slightly more performant</li>\n<li>Interfaces can extend several interfaces</li>\n<li>Interfaces can be declared several times in the same scope. The ultimate definition will be the merge of all the interfaces. Types will error with same declarations in the same scope. Forces you to use the &amp; to create mixed types.</li>\n<li><strong>Mostly it‚Äôs a matter of style.</strong></li>\n</ul>\n<h4>Types</h4>\n<h4>TPS.01: A basic example</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const myCar: Car = {<br>  brand: \"Tesla\",<br>  year: 2024,<br>};</pre>\n<h4>TPS.02: Extending a type‚Ää‚Äî‚ÄäUsing intersections</h4>\n<p>You can use the &amp; to extend an existing type. That is call an <em>intersection</em>. Prefer composability, using types that ‚Äòextend‚Äô from other types rather than adding optional props that might create ambiguity (see Unions and Narrowing)</p>\n<pre>type Vehicle = {<br>  brand: string;<br>  model: string;<br>};<br><br>type ElectricVehicle = Vehicle &amp; {<br>  batteryCapacity: number; // in kWh<br>};<br><br>const teslaModelS: ElectricVehicle = {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>TPS.03: Typing objects dynamically</h4>\n<p>Sometimes you want the object to have dynamic keys, but that they all match a format. For example, all the keys should be a number. For that, you can use Record&lt;&gt;</p>\n<pre>const carRatings: Record&lt;string, number&gt; = {};<br><br>carRatings.performance = 95;<br>carRatings.safety = 90;<br>carRatings.comfort = 85;</pre>\n<h4>TPS.04: Supporting different types of Keys for Maps and Sets</h4>\n<p>TS has an own type that is the union of string | number | symbol. It is named PropertyKey.</p>\n<pre>// PropertyKey = string | number | symbol<br><br>const carMap = new Map&lt;PropertyKey, string&gt;();<br><br>const key1: string = \"brand\";<br>const key2: number = 2024;<br>const key3: symbol = Symbol(\"uniqueModel\");<br><br>carMap.set(key1, \"Toyota\");<br>carMap.set(key2, \"Camry\");<br>carMap.set(key3, \"SpecialEdition\");</pre>\n<h4>TPS.05: Restricting keys of an object to a list</h4>\n<p>Let‚Äôs say you want to generate an object where the keys are dynamic but restricted to a list. For example:</p>\n<pre>const carConfigurations = {<br>  sedan: {<br>    fuelType: \"petrol\",<br>    doors: 4,<br>  },<br>  suv: {<br>    fuelType: \"diesel\",<br>    doors: 5,<br>  },<br>  hatchback: {<br>    fuelType: \"electric\",<br>    doors: 5,<br>  },<br>};</pre>\n<p>As you can see they all follow the same structure, yet you may want to add other environments. The way to type is to create a list of those possible keys:</p>\n<pre>type CarType = 'sedan' | 'suv' | 'hatchback';<br><br>type CarConfigurations = {<br>  [Type in CarType]: {<br>    fuelType: string;<br>    doors: number;<br>  };<br>};<br><br>const carConfigurations: CarConfigurations = {<br>  sedan: {<br>    fuelType: \"petrol\",<br>    doors: 4,<br>  },<br>  suv: {<br>    fuelType: \"diesel\",<br>    doors: 5,<br>  },<br>  hatchback: {<br>    fuelType: \"electric\",<br>    doors: 5,<br>  },<br>};</pre>\n<p>Alternatively, this could be annotated too as:</p>\n<pre>type CarType = 'sedan' | 'suv' | 'hatchback';<br><br>type Configurations = Record&lt;<br>  CarType,<br>  { apiBaseUrl: string; timeout: number; }<br> &gt;<br><br>const carConfigurations: CarConfigurations = {...} // the same object as before</pre>\n<h4>TPS.06: Creating a type that is a ‚Äòslice‚Äô from another one: Pick</h4>\n<p>Pick allows to create a ‚Äòslice‚Äô of a type. Prefer using type composition (see second example). You can‚Äôt pick a key that doesn‚Äôt exist on the type.</p>\n<pre>type Car = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  color: string;<br>}<br><br>type PickedCar = Pick&lt;Car, 'brand' | 'model'&gt;;<br><br>const TeslaCar: PickedCar = {brand: 'Tesla', model: 'CyberTruck'}</pre>\n<h4>TPS.07: Creating a type that is a ‚Äòslice‚Äô from another one: Omit</h4>\n<p>Like pick, but the opposite. Instead of keeping the marked keys, it removes them. Omit won‚Äôt complain if you pass a key that wasn‚Äôt declared ü§∑</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  color: string;<br>}<br><br>const addCar = (carInfo: Omit&lt;Car, 'id'&gt;) =&gt; {<br>  // Do something with the carInfo<br>};<br><br>addCar({<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  year: 2024,<br>  color: \"Metallic\",<br>});</pre>\n<h4>TPS.08: Creating a type that is a ‚Äòslice‚Äô from another one: Omit in unions</h4>\n<p>Omit isn‚Äôt distributive.</p>\n<pre>type Car = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  imageId: string;<br>};<br><br>type Truck = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  capacity: number;<br>  imageId: string;<br>};<br><br>type Motorcycle = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  cc: number;<br>  imageId: string;<br>};<br><br>type Vehicle = Car | Truck | Motorcycle;<br><br>type VehicleWithoutId = Omit&lt;Vehicle, \"id\"&gt;;</pre>\n<p>The reason this happens is due to a technicality of how Omit processes union types.</p>\n<p>Omit doesn‚Äôt iterate over every member of the union. Instead, it squashes the union into a structure it comprehends, and then operates on this new construct. As a result, the outcome is different than what you might expect. To remedy this, let‚Äôs take a look at DistributiveOmit</p>\n<h4>TPS.09: DistributiveOmit</h4>\n<p>Following the previous snippet, if you want to create an union where ‚Äòid‚Äô is ommited in each case, you can apply a distributive omit:</p>\n<pre>type DistributiveOmit&lt;T, K extends PropertyKey&gt; = T extends any<br>  ? Omit&lt;T, K&gt;<br>  : never;<br><br>type Vehicle = Car | Truck | Motorcycle;<br>type VehicleWithoutId = DistributiveOmit&lt;Vehicle, \"id\"&gt;;</pre>\n<h4>TPS.10: Using Partials</h4>\n<p>Sometimes, for example updates, you only want to pass 1 property to update.</p>\n<p>It is tempting to fix it by making all props optional with ? but that would change the definition of Product, and that isn‚Äôt what we want.</p>\n<p>The solution is to use Partial . Partial makes all the definition optional, like if it where with ?.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  description: string;<br>};<br><br>const updateCar = (id: number, carInfo: Partial&lt;Omit&lt;Car, \"id\"&gt;&gt;) =&gt; {<br>  // Do something with the carInfo<br>};<br><br>updateCar(1, {<br>  brand: \"Tesla\",<br>});<br><br>updateCar(1, {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>});<br><br>updateCar(1, {<br>  year: 2024,<br>});</pre>\n<p>Note: Partial doesn‚Äôt support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.</p>\n<h4>TPS.11: Using Required</h4>\n<p>The Required utility type in TypeScript does the opposite of Partial‚Äîit makes all properties mandatory. This is useful when you want to ensure that every property of an object must be provided.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year?: number; <br>};<br><br>const createCar = (carInfo: Required&lt;Car&gt;) =&gt; {<br>  console.log(carInfo);<br>};<br><br>createCar({<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  year: 2024<br>});</pre>\n<p>Note: Same as Partial, Required doesn‚Äôt support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.</p>\n<h4>TPS.12: Partial, Required, Pick, mixed together</h4>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year?: number; // Optional<br>  color?: string; // Optional<br>};<br><br>// Make only 'brand' and 'model' required, while 'id', 'year', and 'color' remain optional<br>type PartialCarWithRequired = Partial&lt;Car&gt; &amp; Required&lt;Pick&lt;Car, 'brand' | 'model'&gt;&gt;;<br><br>const createCar: PartialCarWithRequired = {<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  // id, year, and color can be omitted<br>}<br><br>console.log(createCar);</pre>\n<h4>TPS.13: Using Readonly</h4>\n<p>The Readonly utility type allows you to create a type with all properties of an existing type set to <strong>readonly</strong>. This means that the properties cannot be reassigned, providing a way to enforce immutability in your data structures. This is particularly useful when you want to ensure that certain data should not be changed after it has been created.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>};<br><br>// Create a readonly version of Car<br>type ReadonlyCar = Readonly&lt;Car&gt;;<br><br>const car: ReadonlyCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>};</pre>\n<p>Using it in arrays:</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>};<br><br>type ReadonlyCarArray = readonly Car[];<br>//alternatively <br>//type ReadonlyCarArray = ReadonlyArray&lt;Car&gt;;<br><br>const cars: ReadonlyCarArray = [<br>  { id: 1, brand: \"Tesla\", model: \"CyberTruck\" },<br>  { id: 2, brand: \"Ford\", model: \"F-150\" },<br>];</pre>\n<h4>TPS.14: Using NonNullable</h4>\n<p>The NonNullable utility type is used to exclude null and undefined from a type. This is helpful when you want to ensure that a value is defined and not null, which can prevent runtime errors related to dereferencing null or undefined values.</p>\n<pre>type Car = {<br>  id: number;<br>  model: string | null;<br>};<br><br>// Create a version of Car with a non-nullable model<br>type NonNullableCar = {<br>  id: number;<br>  model: NonNullable&lt;Car['model']&gt;;<br>};<br><br>const car: NonNullableCar = {<br>  id: 1,<br>  model: \"Tesla\",<br>};<br><br>// Assigning null will cause a compilation error<br>// car.model = null; // Error: Type 'null' is not assignable to type 'string'.</pre>\n<h4>Interfaces</h4>\n<p>Interfaces in TypeScript allow you to define the shape of objects and can be used in a similar way to types. They are particularly useful for defining class structures and can also be extended, providing a flexible way to create complex data structures. They suit better for classes.</p>\n<h4>INT.01: Basic Interface Definition</h4>\n<pre>interface Car {<br>  model: string;<br>  year: number;<br>}<br><br>// Which in this case could had been the same as:<br>// type Car = {<br>//   model: string;<br>//   year: number;<br>// }<br><br>const vehicle: Car = {<br>  model: \"Tesla Model 3\",<br>  year: 2020,<br>};</pre>\n<h4>INT.02: Extending Interfaces</h4>\n<p>You can create new interfaces by extending existing ones. This helps you build on top of existing structures without repeating code. This would be the way to compose other interfaces, the same way that types uses intersections, interfaces extend.</p>\n<pre>interface Vehicle {<br>  brand: string;<br>  model: string;<br>}<br><br>interface ElectricCar extends Vehicle {<br>  batteryCapacity: number; // in kWh<br>}<br><br>const teslaModelS: ElectricCar = {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>INT.03: Squashing Interfaces in the Same Namespace</h4>\n<p>One of the powerful features of interfaces is that they can be declared multiple times within the same scope. TypeScript automatically merges these declarations, allowing you to add properties to an interface as needed.</p>\n<pre>interface Car {<br>  brand: string;<br>  model: string;<br>}<br><br>interface Car {<br>  year: number;<br>}<br><br>const myCar: Car = {<br>  brand: \"Toyota\",<br>  model: \"Camry\",<br>  year: 2021,<br>};</pre>\n<h4>INT.04: Extending Interfaces with Function Types</h4>\n<p>Interfaces can also define function types, enabling you to type functions more explicitly.</p>\n<pre>interface CarProcessor {<br>  (car: Car): void;<br>}<br><br>const processCar: CarProcessor = (car) =&gt; {<br>  console.log(`Processing car: ${car.brand} ${car.model}`);<br>};</pre>\n<h4>INT.05: Namespaced Interfaces</h4>\n<p>You can use namespaces to group related interfaces together, helping to organize your code better. Since ES Modules, this feature is less common, and prefered to be avoided.</p>\n<pre>namespace CarModule {<br>  export interface Car {<br>    id: number;<br>    brand: string;<br>    model: string;<br>  }<br><br>  export interface ElectricCar extends Car {<br>    batteryCapacity: number;<br>  }<br>}<br><br>const tesla: CarModule.ElectricCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>INT.06: Optional Properties</h4>\n<p>Interfaces can have optional properties, allowing you to define flexible structures</p>\n<pre>interface Car {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  color?: string; // Optional property<br>}const tesla: Car = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model 3\",<br>};</pre>\n<h4>INT.07: Readonly Properties</h4>\n<p>To create properties that cannot be modified after their initial assignment, you can use the readonly modifier.</p>\n<pre>interface ImmutableUser {<br>interface ImmutableCar {<br>  readonly id: number;<br>  readonly brand: string;<br>  readonly model: string;<br>}<br><br>const myCar: ImmutableCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>};<br><br>// myCar.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.</pre>\n<h3>Enums</h3>\n<h4>EN.01: Enums‚Ää‚Äî‚ÄäPlease Don‚Äôt use them</h4>\n<p>Enums are widely unused since there are more modern approaches. Visit <a href=\"https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh#:~:text=Excessive%20use%20of%20regular%20ENUMs,new%20values%20can%20be%20added.\">here</a> for more details.</p>\n<p><strong>Example</strong>:</p>\n<pre>enum CarType {<br>  SEDAN = \"sedan\",<br>  SUV = \"suv\",<br>  TRUCK = \"truck\",<br>}<br><br>function createCar(type: CarType) {<br>  // Implementation here<br>}<br><br>createCar(CarType.SEDAN); // Valid<br>createCar('sedan'); // Invalid</pre>\n<p>Instead, use as const combined with exporting the union of values:</p>\n<pre>export const CarTypes = {<br>  SEDAN: \"sedan\",<br>  SUV: \"suv\",<br>  TRUCK: \"truck\",<br>} as const;<br><br>// Exporting the type derived from the CarTypes constant<br>export type CarType = typeof CarTypes[keyof typeof CarTypes];<br><br>const handlerFunction = (carType: CarType) =&gt; {<br>  if (carType === CarTypes.SEDAN) {<br>    return 'This is a sedan';<br>  }<br>  return 'This is not a sedan';<br>}<br><br>handlerFunction('sedan'); // This will work<br>handlerFunction(CarTypes.SEDAN); // This will work too.</pre>\n<h4>EN.02: Exporting nested enums as a flatten entity</h4>\n<pre>type ApiEndpoint =<br>  | `/${string}`<br>  | Record&lt;string, ApiEndpoint&gt;;<br><br>const apiEndpoints = {<br>  cards: {<br>    GET_ALL: '/cards',<br>    GET_BY_ID: '/cards/:id',<br>    CREATE: '/cards/create',<br>    UPDATE: '/cards/update/:id',<br>    DELETE: '/cards/delete/:id',<br>    CATEGORIES: {<br>      GET_ALL: '/cards/categories',<br>      GET_BY_ID: '/cards/categories/:id',<br>      CREATE: '/cards/categories/create',<br>      UPDATE: '/cards/categories/update/:id',<br>      DELETE: '/cards/categories/delete/:id',<br>    },<br>    TAGS: {<br>      GET_ALL: '/cards/tags',<br>      GET_BY_ID: '/cards/tags/:id',<br>      CREATE: '/cards/tags/create',<br>      UPDATE: '/cards/tags/update/:id',<br>      DELETE: '/cards/tags/delete/:id',<br>    },<br>  },<br>} as const;<br><br>type Flatten&lt;T&gt; = T extends Record&lt;string, infer U&gt; ? Flatten&lt;U&gt; : T;<br><br>export type ApiEndpoints = Flatten&lt;typeof apiEndpoints&gt;;<br><br>const someEndpoint: ApiEndpoints = apiEndpoints.cards.GET_ALL;<br>const someOtherEndpoint: ApiEndpoints = '/cards/categories';</pre>\n<h3>03. Inference</h3>\n<p>Inference is the way that TS ‚Äòguesses‚Äô what type some variable is. Sometimes, you need to help it a bit.</p>\n<h4>INFR.01: Inference: let and const change the way TS assigns types</h4>\n<p>Using let allows reassignment, resulting in the type being inferred as string. In contrast, const can‚Äôt be reassigned, leading TypeScript to infer its type as a literal.</p>\n<p>For example:</p>\n<pre>let type = \"sedan\"; // inferred as string, because it can be reassigned</pre>\n<p>While:</p>\n<pre>const type = \"sedan\"; // inferred as 'sedan' because it can't be reassigned</pre>\n<h4>INFR.02: Object property inference</h4>\n<p>TypeScript‚Äôs type inference can sometimes lead to unintended results when inferring object properties. Since objects are dynamically typed, a string in a key will default to string instead of maybe a literal.</p>\n<p>Most of the time, if you are using an approach like the following one, TS will infer ‚Äòstrings‚Äô instead of your assigned type ButtonAttributes. To avoid that, just add the type.</p>\n<p>This will error:</p>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: \"sedan\", // inferred as string<br>};<br><br>modifyCar(carAttributes); // will error</pre>\n<p>But this won‚Äôt</p>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes: CarAttributes = {<br>  type: \"sedan\",<br>};<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.03: Using ‚Äòas const‚Äô to force inference</h4>\n<p>The same example as before can be solved by instructing TS that it should be considered as const.</p>\n<p>as const not only locks the type to a specific literal but also makes the properties of the object readonly. Better to use a type if you can, but sometimes this trick will also do. It all depends on if you want that readonly attribute as well or not.</p>\n<pre>type CarAttributes = {<br>  type: 'sedan' | 'suv' | 'truck';<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: 'sedan' as const,<br>};<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.04: Using ‚Äòsatisfies‚Äô</h4>\n<p>Another way to solve the previous issue is using satisfies. satisfies helps in the case the object doesn‚Äôt have the same structure as the type.</p>\n<p>Using satisfies checks the object against the type at compile-time without requiring the object to match the type structure perfectly, thus enhancing flexibility.</p>\n<pre>type CarAttributes = {<br>  type: 'sedan' | 'suv' | 'truck';<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: 'sedan',<br>} satisfies CarAttributes;<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.05: ‚ÄòReadonly‚Äô and ‚Äòas const‚Äô</h4>\n<p>Using as const on an object makes it readonly, eliminating the need to define the type explicitly. This is important because immutability ensures that the values of properties can‚Äôt be changed after the object is created, reducing the risk of unintended side effects in your code.</p>\n<p>The 2 following snippets are exactly the same:</p>\n<pre>const carAttributes: CarAttributes = {<br>  sport: {<br>    type: \"sedan\",<br>  },<br>  utility: {<br>    type: \"suv\",<br>  },<br>} as const;<br><br>type CarType = \"sedan\" | \"suv\" | \"truck\";<br><br>type CarAttributes = {<br>  readonly sport: {<br>    readonly type: CarType;<br>  };<br>  readonly utility: {<br>    readonly type: CarType;<br>  };<br>};<br><br>const carAttributes: CarAttributes = {<br>  sport: {<br>    type: \"sedan\",<br>  },<br>  utility: {<br>    type: \"suv\",<br>  },<br>}</pre>\n<p>As you can see, using as const is a nice shortcut for those readonly properties.</p>\n<h4>INFR.06: Function Overloading</h4>\n<p>Function overloading allows you to define multiple signatures for a function, enabling it to accept different parameter types and return different types based on the parameters provided.</p>\n<p>In an ideal world, this kind of thing shouldn‚Äôt happen often, but if you have some kind of ‚Äúmaster‚Äù function that handles many cases with many types, it can be useful.</p>\n<p>This can improve code readability and maintainability by allowing a single function name to handle multiple use cases.</p>\n<p>Needless to say, try to avoid this kind of thing.</p>\n<p><strong>Example</strong>:</p>\n<pre>function processCar(input: string): boolean; // Returns a boolean<br>function processCar(input: number): string; // Returns a string<br>function processCar(input: boolean): number; // Returns a number<br>function processCar(input: string | number | boolean): boolean | string | number {<br>  if (typeof input === \"string\") {<br>    return input.length &gt; 0; // Returns true if the string is non-empty<br>  } else if (typeof input === \"number\") {<br>    return `The car count is ${input}.`; // Returns a string representation<br>  } else if (typeof input === \"boolean\") {<br>    return input ? 1 : 0; // Returns 1 for true and 0 for false<br>  }<br>  throw new Error(\"Invalid input type.\");<br>}</pre>\n<h4>INFR.07: Type Guards</h4>\n<p>Type guards are a feature that allow you to narrow down the type of a variable within a conditional block. This can enhance type safety and prevent runtime errors by ensuring that the operations performed on variables are valid for their types.</p>\n<p><strong>Example</strong>:</p>\n<pre>function logCar(value: string | number) {<br>  if (typeof value === \"string\") {<br>    console.log(`Car model: ${value}`);<br>  } else { // TS would know that value is a number<br>    console.log(`Car ID: ${value}`);<br>  }<br>}</pre>\n<h4>INFR.08: Scope Narrowing</h4>\n<p>Sometimes TS won‚Äôt be able to detect the type of a variable. Lowering the declaration of the variable to the same scope sometimes fixes it:</p>\n<pre>const findCarsByModel = (<br>  searchParams: { model?: string },<br>  cars: {<br>    id: string;<br>    model: string;<br>  }[],<br>) =&gt; {<br>  if (searchParams.model) {<br>    const { model } = searchParams; // Scope narrowing to avoid errors<br>    return cars.filter((car) =&gt; car.model.includes(model));<br>  }<br>  return cars;<br>};</pre>\n<h4>INFR.09: Discriminated Unions and Types: don‚Äôt use one type to try to cover several entities (avoid ambiguity, segregate the entities)</h4>\n<p>In this example Vehicle can represent both a circle and a rectangle. But it is not clear:</p>\n<pre>type Vehicle = {<br>  kind: string;<br>  horsepower?: number;<br>  seatingCapacity?: number;<br>};<br><br>function getSpecifications(vehicle: Vehicle) {<br>  if (vehicle.kind === \"sedan\") {<br>    return `Seating Capacity: ${vehicle.seatingCapacity}`;<br>  } else {<br>    return `Horsepower: ${vehicle.horsepower}`;<br>  }<br>}</pre>\n<p>Instead:</p>\n<pre>type Sedan = {<br>  kind: 'sedan';<br>  seatingCapacity: number;<br>};<br><br>type Truck = {<br>  kind: \"truck\";<br>  horsepower: number;<br>};<br><br>type Vehicle = Sedan | Truck;<br><br>function getSpecifications(vehicle: Vehicle) {<br>  if (vehicle.kind === \"sedan\") {<br>    return `Seating Capacity: ${vehicle.seatingCapacity}`;<br>  }<br>  return `Horsepower: ${vehicle.horsepower}`;<br>}</pre>\n<h4>INFR.10: Avoid using ‚Äòlet‚Äô without types:</h4>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>let type = \"sedan\"; // inferred as string, using a const would prevent this<br><br>const carAttributes: CarAttributes = {<br>  type, // error due to inferred string type<br>};</pre>\n<h4>INFR.11: The ‚ÄòNever‚Äô Type</h4>\n<p>The never type in TypeScript represents a value that never occurs. It's used in functions that throw errors or have infinite loops, as they never return a value.</p>\n<pre>function throwError(message: string): never {<br>  throw new Error(message);<br>}</pre>\n<p>It also represents incompatible types. For example: string &amp; number is going to be never.</p>\n<pre>type Car = {<br>  id: string;<br>  model: string;<br>};<br><br>type Truck = {<br>  id: number; // incompatible with Car's id<br>  model: string;<br>  payloadCapacity: number;<br>};<br><br>const impossible: Car &amp; Truck = {<br>  id: 'C123', // error because id must be both string and number, which is impossible<br>  model: 'X1',<br>  payloadCapacity: 3000<br>};</pre>\n<h3>04. Classes, deriving types, Generics</h3>\n<h4>Classes</h4>\n<h4>CLS.01: Default properties</h4>\n<pre>class Car {<br>  readonly make: string;<br>  readonly model: string;<br><br>  constructor(make = \"Generic\", model = \"Model\") {<br>    this.make = make;<br>    this.model = model;<br>  }<br>}<br><br><br>// Equivalent to:<br>class Car {<br>  readonly make: string = \"Generic\";<br>  readonly model: string = \"Model\";<br>}</pre>\n<h4>CLS.02: Creating Constructors</h4>\n<pre>class Car {<br>  make = \"Generic\";<br>  model = \"Model\";<br><br>  constructor(opts?: { make: string; model: string } = { make: \"Generic\", model: \"Model\" }) {<br>    this.make = opts.make;<br>    this.model = opts.model;<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.03: Declaring Methods</h4>\n<pre>class Car {<br>  make = \"Generic\";<br>  model = \"Model\";<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.04: Getters</h4>\n<pre>class Car {<br>  make: string;<br>  model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.make = details?.make ?? \"Generic\";<br>    this.model = details?.model ?? \"Model\";<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br><br>  get details() {<br>    return { make: this.make, model: this.model };<br>  }<br>}</pre>\n<h4>CLS.05: Private properties</h4>\n<p>You can use the private or # prefix in the member declaration to make it private. Both ways will work, it is a matter of style.</p>\n<pre>class Car {<br>  private make: string;<br>  private model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.make = details?.make ?? \"Generic\";<br>    this.model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.make, model: this.model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}<br><br>// Or with `#` prefix:<br>class Car {<br>  #make: string;<br>  #model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.#make = details?.make ?? \"Generic\";<br>    this.#model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.06: Setters</h4>\n<p>TS understands the type of the setter by checking the getter. No need to define the type.</p>\n<pre>class Car {<br>  #make: string;<br>  #model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.#make = details?.make ?? \"Generic\";<br>    this.#model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  // since the get details returns an object with make and model, the set expects the same signature<br>  set details(details) {<br>    this.#make = details.make;<br>    this.#model = details.model;<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.07: Overriding</h4>\n<p>If in the tsConfig the option noImplicitOverride is turned on, you will need to add the override keyword when extending a method from an inherited class.</p>\n<pre>// inside tsconfig.json<br>{<br>  \"compilerOptions\": {<br>    ...<br>    \"noImplicitOverride\": true</pre>\n<pre>class Vehicle {<br>  logType() {<br>    console.log(\"Vehicle type\");<br>  }<br>}<br><br>class Car extends Vehicle {<br>  override logType() {<br>    console.log(\"Car type\");<br>  }<br>}</pre>\n<h4>CLS.08: Implementing a ‚Äòtype‚Äô or ‚Äòinterface‚Äô</h4>\n<p>Classes can implement interfaces or types. Stick to using interfaces. As you can see, it can handle both, but the industry prefers the first one.</p>\n<pre>interface VehicleOptions {<br>  make: string;<br>  model: string;<br>}<br><br>type VehicleType = {<br>  details: { make: string; model: string };<br>  drive: (speed: number) =&gt; void;<br>};<br><br>class Car implements VehicleType {<br>  #make: string;<br>  #model: string;<br><br>  constructor(initial?: VehicleOptions) {<br>    this.#make = initial?.make ?? \"Generic\";<br>    this.#model = initial?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.09: Abstract Classes</h4>\n<p>abstract classes allow you to define methods that subclasses must implement, as well as methods with default behavior. This is useful when designing base classes for other classes to extend.</p>\n<pre>abstract class Vehicle {<br>  abstract speed(): number;<br><br>  describe(): string {<br>    return \"This is a vehicle.\";<br>  }<br>}<br><br>class Car extends Vehicle {<br>  constructor(public maxSpeed: number) {<br>    super();<br>  }<br><br>  speed(): number {<br>    return this.maxSpeed;<br>  }<br>}</pre>\n<h4>CLS.10: Static Properties and Methods</h4>\n<p>static members belong to the class itself rather than to any specific instance. This is useful for utility functions or properties that should be shared across all instances. So far, the static is nothing new to TS.</p>\n<pre>class VehicleUtils {<br>  static MAX_SPEED = 120;<br><br>  static calculateDistance(time: number) {<br>    return this.MAX_SPEED * time;<br>  }<br>}<br><br>console.log(VehicleUtils.calculateDistance(2)); // 240</pre>\n<h4>CLS.11: Parameter Properties</h4>\n<p>This shorthand allows you to define and initialize class members directly in the constructor‚Äôs parameter list, reducing boilerplate code.</p>\n<pre>class Car {<br>  constructor(public make: string = \"Generic\", public model: string = \"Model\") {}<br>}<br><br>const car = new Car(\"Toyota\", \"Corolla\");<br>console.log(car.make); // Toyota</pre>\n<p>This equals to:</p>\n<pre>class Car {<br>  public make: string;<br>  public model: string;<br><br>  constructor(make: string = \"Generic\", model: string = \"Model\") {<br>    this.make = make;<br>    this.model = model;<br>  }<br>}<br><br>const car = new Car(\"Toyota\", \"Corolla\");<br>console.log(car.make); // Toyota</pre>\n<p>Instead of declaring properties and assigning them in the constructor, parameter properties allow you to do both in a single step, making your class definitions more concise.</p>\n<h4>DTV.01: Deriving Types from Variables</h4>\n<p>Deriving types from existing values or variables is a powerful feature in TypeScript, allowing you to dynamically infer types based on data structures, function signatures, and constants. Here‚Äôs a comprehensive guide on different techniques for deriving types in TypeScript.</p>\n<p>This allows for a more dynamic and type-safe approach to working with complex data structures. Let‚Äôs explore key techniques like keyof, typeof, and more.</p>\n<h4>DTV.02: The ‚Äòkeyof‚Äô Operator</h4>\n<p>The keyof operator creates a union of string literal types from the keys of an interface or object. This is particularly useful for creating flexible types.</p>\n<p>Example:</p>\n<pre>interface CarSpecs {<br>  make: string;<br>  model: string;<br>  year: number;<br>}<br><br>// carDetails will need to have the same keys as the interface<br>const carDetails: Record&lt;keyof CarSpecs, { description: string; value: string | number }&gt; = {<br>  make: { description: \"Car Make\", value: \"Toyota\" },<br>  model: { description: \"Car Model\", value: \"Corolla\" },<br>  year: { description: \"Manufacturing Year\", value: 2021 },<br>};</pre>\n<p>Here, keyof CarSpecs creates a union of \"make\" | \"model\" | \"year\", allowing carDetails to have the same keys as CarSpecs.</p>\n<h4>DTV.03: The 'typeof' Operator</h4>\n<p>The typeof operator can be used to derive types directly from variables or objects.</p>\n<p>For example:</p>\n<pre>const configurations = {<br>  development: {<br>    apiBaseUrl: 'http://localhost:8080',<br>    timeout: 5000,<br>  },<br>  production: {<br>    apiBaseUrl: 'https://api.example.com',<br>    timeout: 10000,<br>  },<br>  staging: {<br>    apiBaseUrl: 'https://staging.example.com',<br>    timeout: 8000,<br>  },<br>};<br><br>type Environment = keyof typeof configurations; // 'development' | 'production' | 'staging'</pre>\n<p>In this case, keyof typeof configurations extracts the keys ('development', 'production', 'staging') as a union type.</p>\n<h4>DTV.04: You Can Create Types from Values, but Not Values from Types</h4>\n<p>types and interfaces in TypeScript are erased at runtime, which means you can only derive types from existing values, but not the other way around. Type information doesn‚Äôt exist at runtime and only helps in static checking during development.</p>\n<h4>DTV.05: Deriving Types with Classes</h4>\n<p>Classes can be used as types directly in TypeScript. Any instance of a class can be typed as the class itself.</p>\n<p>Example:</p>\n<pre>class CarPosition {<br>  x = 0;<br>  y = 0;<br><br>  move(x: number, y: number) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}<br><br>const positionFromCar = (position: CarPosition) =&gt; {<br>  return {<br>    x: position.x,<br>    y: position.y,<br>  };<br>};</pre>\n<p>Here, CarPosition serves both as a class and a type.</p>\n<h4>DTV.06: Using the Same Name for Values and Types</h4>\n<p>You can have the same name for a type and a constant.</p>\n<p>Example:</p>\n<pre>export const Logger = {<br>  log: (message: string) =&gt; console.log(message),<br>};<br><br>export type Logger = typeof Logger;</pre>\n<p>Here, Logger refers both to a type (inferred from the constant) and the constant itself.</p>\n<h4>DTV.07: Deriving Types from Complex Function Parameters</h4>\n<p>You can derive types from function parameters using Parameters&lt;&gt;.</p>\n<p>Example:</p>\n<pre>const makeQuery = (<br>  url: string,<br>  opts?: {<br>    method?: string;<br>    headers?: {<br>      [key: string]: string;<br>    };<br>    body?: string;<br>  },<br>) =&gt; {};<br><br>type MakeQueryParameters = Parameters&lt;typeof makeQuery&gt;;</pre>\n<p>Here, MakeQueryParameters extracts the type of the parameters from makeQuery.</p>\n<h4>DTV.08: Extracting a Type from a Function‚Äôs Return Type</h4>\n<p>You can extract the return type of a function using ReturnType&lt;&gt;.</p>\n<p>Example:</p>\n<pre>const createUser = (id: string) =&gt; {<br>  return {<br>    id,<br>    name: \"John Doe\",<br>    email: \"example@email.com\",<br>  };<br>};<br><br>type User = ReturnType&lt;typeof createUser&gt;;</pre>\n<h4>DTV.09: Extracting Type from an Async Function</h4>\n<p>When working with asynchronous functions, you can use Awaited&lt;&gt; to get the <em>resolved</em> type.</p>\n<p>Example:</p>\n<pre>const fetchUser = async (id: string) =&gt; {<br>  return {<br>    id,<br>    name: \"John Doe\",<br>    email: \"example@email.com\",<br>  };<br>};<br><br>type User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;;</pre>\n<h4>DTV.10: Access Specific Values in an 'as const' Object</h4>\n<p>By using as const, you can lock an object‚Äôs values as constants, which allows you to access them more precisely.</p>\n<pre>export const carBrandType = {<br>  SEDAN: \"sedan\",<br>  SUV: \"suv\",<br>  COUPE: \"coupe\",<br>  PICKUP: \"pickup\",<br>  VAN: \"van\",<br>} as const;<br><br>type CarBrandTypeMap = typeof carBrandType; // a readonly object accesible by key<br>type Sedan = CarBrandTypeMap['SEDAN']; // 'sedan'</pre>\n<h4>DTV.11: Passing a Union to an Indexed Access Type</h4>\n<p>You can create union types by passing specific keys to an indexed access type.</p>\n<pre>// Following previous example, this type will be: \"sedan\" | \"suv\"<br>type SedanOrSuv = CarBrandTypeMap['SEDAN' | 'SUV']</pre>\n<h4>DTV.12: Extract a Union of All Values from an Object</h4>\n<p>You can guess that with the previous explanation you could get the union of all the values hardcoding each of them. But you can make your life easier by extracting all the values from an object as a union. This is usually used instead of enums.</p>\n<pre><br>// Equals too 'sedan' | 'suv' | 'coupe' | 'pickup' | 'van'<br>type CarTypes = CarBrandTypeMap[keyof typeof carBrandType];</pre>\n<h4>DTV.13: Create a Union from an as const Array</h4>\n<p>You can derive a union type from an array by using as const.</p>\n<pre>export const carBrandType = [<br>  \"sedan\",<br>  \"suv\",<br>  \"coupe\",<br>  \"pickup\",<br>  \"van\",<br>] as const;<br><br>type BrandCars = (typeof carBrandType)[number];</pre>\n<h3>Generics</h3>\n<h4>GEN.01: Basic Generic Function</h4>\n<p>A generic function allows you to define a placeholder type that can be replaced later.</p>\n<pre>function identity&lt;T&gt;(value: T): T {<br>  return value;<br>}<br><br>const num = identity(42); // T is 'number'<br>const str = identity(\"hello\"); // T is 'string'</pre>\n<h4>GEN.02: Generic Types with Arrays</h4>\n<p>Generic functions can handle arrays of any type.</p>\n<pre>function getFirstElement&lt;T&gt;(arr: T[]): T {<br>  return arr[0];<br>}<br><br>const firstNumber = getFirstElement([1, 2, 3]); // T is 'number'<br>const firstString = getFirstElement([\"a\", \"b\", \"c\"]); // T is 'string'</pre>\n<h4>GEN.03: Generic Interfaces</h4>\n<p>Use generics with interfaces to define reusable types.</p>\n<pre>interface Result&lt;T&gt; {<br>  data: T;<br>  error?: string;<br>}<br><br>const success: Result&lt;number&gt; = { data: 42 };<br>const failure: Result&lt;string&gt; = { data: \"error occurred\", error: \"404 not found\" };</pre>\n<h4>GEN.04: Generic Constraints</h4>\n<p>Sometimes you need to restrict the types that can be passed to a generic. You can do this using <strong>constraints</strong>. For example, to ensure that a type has a length property (like arrays or strings), you can add the following:</p>\n<pre>interface HasLength {<br>  length: number;<br>}<br><br>function logLength&lt;T extends HasLength&gt;(input: T): void {<br>  console.log(input.length);<br>}<br><br>logLength(\"hello\"); // OK, string has a length property<br>logLength([1, 2, 3]); // OK, array has a length property<br>// logLength(42); // Error, number has no length property</pre>\n<p>This can also be used when you want &lt;T&gt; to be limited to certain interfaces or types.</p>\n<h4>GEN.05: Using Multiple Generics</h4>\n<p>You can use multiple generics in the same function or type.</p>\n<pre>function pair&lt;A, B&gt;(first: A, second: B): [A, B] {<br>  return [first, second];<br>}<br><br>const pair1 = pair(1, \"apple\"); // A is 'number', B is 'string'<br>const pair2 = pair(true, { name: \"John\" }); // A is 'boolean', B is an object</pre>\n<h4>GEN.06: Default Generic Types</h4>\n<p>Set default generic types to simplify function calls.</p>\n<pre>function createArray&lt;T = string&gt;(length: number, value: T): T[] {<br>  return Array(length).fill(value);<br>}<br><br>const stringArray = createArray(3, \"hello\"); // T is 'string'<br>const numberArray = createArray&lt;number&gt;(3, 42); // Explicitly set T as 'number'<br>const error = createArray&lt;number&gt;('3', 42); // This will error</pre>\n<h4>GEN.07: Conditional Types with Generics</h4>\n<p>TypeScript allows you to create <strong>conditional types</strong> using generics:</p>\n<pre>type IsArray&lt;T&gt; = T extends any[] ? \"Array\" : \"NotArray\";<br><br>const check1: IsArray&lt;string[]&gt; = \"Array\"; // OK<br>const check2: IsArray&lt;number&gt; = \"NotArray\"; // OK</pre>\n<h4>GEN.08: Generic Functions with Overloads</h4>\n<p>Overloading functions happen when you declare them more than once with different implementations. No, it is not a bug, but an overload. Overloading helps you map specific definitions to specific signatures.</p>\n<pre>function formatValue&lt;T extends string | number&gt;(value: T): T extends string ? string : number;<br>function formatValue&lt;T extends string | number&gt;(value: T): string | number {<br>  if (typeof value === \"string\") {<br>    return value.toUpperCase();<br>  } else {<br>    return value.toFixed(2);<br>  }<br>}</pre>\n<h4>GEN.09: Keyof with Generics</h4>\n<p>Access dynamic properties using keyof and generics.</p>\n<pre>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br>  return obj[key];<br>}<br><br>const user = { id: 1, name: \"Alice\" };<br>const id = getProperty(user, \"id\"); // OK<br>const name = getProperty(user, \"name\"); // OK<br>// getProperty(user, \"age\"); // Error: 'age' is not a key of 'user'</pre>\n<h4>GEN.10: Deeply Immutable Structures with Generics</h4>\n<p>While TypeScript has a built-in Readonly utility type, it only applies immutability to the top level of an object. To create a deeply immutable object where all nested properties are also immutable, we need a custom recursive generic type.</p>\n<pre>type DeepReadonly&lt;T&gt; = {<br>  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];<br>};<br><br>interface User {<br>  id: number;<br>  name: string;<br>  address: {<br>    street: string;<br>    city: string;<br>  };<br>}<br>const user: DeepReadonly&lt;User&gt; = {<br>  id: 1,<br>  name: \"Alice\",<br>  address: {<br>    street: \"Main St\",<br>    city: \"Wonderland\"<br>  }<br>};<br><br>// Now, all properties and nested properties are readonly:<br>user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property<br>user.address.city = \"New City\"; // Error: Cannot assign to 'city' because it is a read-only property</pre>\n<h4>GEN.11: Mapping Over a Union of Types</h4>\n<p>You can create a type that maps a transformation over each type in a union. This is useful for mass-transforming several types at once.</p>\n<pre>type Mapped&lt;T&gt; = T extends string ? string[] : T extends number ? number[] : T;<br>type Result = Mapped&lt;string | number&gt;; // string[] | number[]</pre>\n<p>The Mapped type checks if T is a string or number and returns an array of the respective type. If T is a union, TypeScript automatically distributes the transformation over each member.</p>\n<h4>GEN.12: Conditional Properties Exclusion</h4>\n<p>This example excludes properties from a definition based on their types. Here, we remove all string properties from an interface:</p>\n<pre>type OmitByType&lt;T, U&gt; = {<br>  [K in keyof T as T[K] extends U ? never : K]: T[K];<br>};<br><br>interface Person {<br>  id: number;<br>  name: string;<br>  age: number;<br>}<br><br>type WithoutStrings = OmitByType&lt;Person, string&gt;; // { id: number; age: number; }</pre>\n<h4>GEN.13: Keep Specific Properties Based on Type</h4>\n<p>Following the previous example, this one does the same thing but opposite. Instead of omiting the matching types, this one keeps them.</p>\n<pre>type KeepByType&lt;T, U&gt; = {<br>  [K in keyof T as T[K] extends U ? K : never]: T[K];<br>};<br><br>interface Person {<br>  id: number;<br>  name: string;<br>  age: number;<br>}<br><br>type StringProps = KeepByType&lt;Person, string&gt;; // { name: string }</pre>\n<p>This is the inverse of the previous example, pulling out only the keys where the value type matches a specific type (string in this case).</p>\n<h4>GEN.14: Type-Safe Builder Pattern with Generics</h4>\n<p>Here‚Äôs a generic Builder type that allows chaining method calls and ensures type safety as you build an object step-by-step.</p>\n<pre>type Builder&lt;T&gt; = {<br>  [K in keyof T as `set${Capitalize&lt;string &amp; K&gt;}`]: (value: T[K]) =&gt; Builder&lt;Omit&lt;T, K&gt;&gt;;<br>} &amp; { build(): T };<br><br>interface Product {<br>  id: number;<br>  name: string;<br>  price: number;<br>}<br><br>const productBuilder: Builder&lt;Product&gt; = {<br>  setId: (id) =&gt; productBuilder,<br>  setName: (name) =&gt; productBuilder,<br>  setPrice: (price) =&gt; productBuilder,<br>  build: () =&gt; ({ id: 1, name: \"Laptop\", price: 1200 })<br>};</pre>\n<p>This Builder type allows method chaining for setting properties on an object while ensuring each property can only be set once. Once all properties are set, you can call build() to return the final object.</p>\n<h3>05. TypeScript in React</h3>\n<h4>REA.01: Typing Props</h4>\n<p>TypeScript allows us to enforce types on props, which makes components safer and easier to debug.</p>\n<pre>type GreetingProps = {<br>  name: string;<br>  age?: number;<br>}<br><br>const Greeting = ({ name, age }: GreetingProps): JSX.Element =&gt; (<br>  &lt;h1&gt;<br>    Hello, {name}! {age &amp;&amp; `You are ${age} years old.`}<br>  &lt;/h1&gt;<br>);<br><br>export default Greeting;</pre>\n<h4>REA.02: Typing State with useState</h4>\n<p>When initializing state, TypeScript can infer the type, but explicit types are often better for clarity.</p>\n<pre>// &lt;number&gt; is not neccesary here -TS inference-, but added for the demonstration.<br>const [count, setCount] = useState&lt;number&gt;(0);<br>const increment = () =&gt; setCount(count + 1);</pre>\n<h4>REA.03: Typing Event Handlers</h4>\n<p>Typing event handlers helps ensure proper usage of event properties within components.</p>\n<pre>const handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {<br>  console.log(event.currentTarget);<br>};<br><br>&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;</pre>\n<p>For a button click event, we use React.MouseEvent&lt;HTMLButtonElement&gt;. TypeScript provides specific types for various events, like ChangeEvent for inputs. <a href=\"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/\">Here</a> is a good source for forms.</p>\n<h4>REA.04: Typing Refs with useRef</h4>\n<p>When working with refs, explicitly typing useRef can prevent accidental null access errors.</p>\n<pre>const inputRef = useRef&lt;HTMLInputElement&gt;(null); <br><br>const focusInput = () =&gt; {<br>  if (inputRef.current) {<br>    inputRef.current.focus();<br>  }<br>};<br><br>return &lt;input ref={inputRef} type=\"text\" /&gt;;</pre>\n<h4>REA.05: Typing Context</h4>\n<p>Using TypeScript with React Context can make it easy to provide and consume context values safely.</p>\n<pre>// Define the context value type<br>type ThemeContextType = {<br>  theme: string;<br>  toggleTheme: () =&gt; void;<br>}<br><br>const ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(undefined);<br><br>const ThemeProvider = ({ children }) =&gt; {<br>  const [theme, setTheme] = useState(\"light\");<br>  const toggleTheme = () =&gt; setTheme(theme === \"light\" ? \"dark\" : \"light\");<br>  return (<br>    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;<br>      {children}<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>};</pre>\n<p>In this example, ThemeContextType is used to define the structure of the context‚Äôs value, guaranteeing all consumers handle it correctly.</p>\n<h4>REA.06: Basic Typing Redux Store (Reducers and Selectors)</h4>\n<p>When working with <a href=\"https://redux.js.org/\">Redux</a>, TypeScript is particularly useful for defining types for the store, actions, and selectors. If you are going to dig deeper I recommend you go over their docs.</p>\n<pre>type CounterState = {<br>  count: number;<br>}<br><br>const initialState: CounterState = { count: 0 };<br><br>const actionTypes = {<br>  INCREMENT: \"INCREMENT\",<br>  DECREMENT: \"DECREMENT\",<br>} as const;<br><br>type ActionType = typeof actionTypes[keyof typeof actionTypes];<br><br>type CounterActionTypes = {type: ActionType};<br><br>const counterReducer = (state = initialState, action: CounterActionTypes): CounterState =&gt; {<br>  switch (action.type) {<br>    case actionTypes.INCREMENT:<br>      return { count: state.count + 1 };<br>    case actionTypes.DECREMENT:<br>      return { count: state.count - 1 };<br>    default:<br>      return state;<br>  }<br>};</pre>\n<h4>REA.07: Typing HOCs (Higher-Order Components)</h4>\n<p>Typing higher-order components (HOCs) means you will need to type the function of the HOC itself and also the argument (another function!) so beware of the syntax.</p>\n<pre>type WithLoadingProps = {<br>  isLoading: boolean;<br>};<br><br>const withLoading = &lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) =&gt; {<br>  const LoadingComponent: React.FC&lt;P &amp; WithLoadingProps&gt; = ({ isLoading, ...otherProps }) =&gt; <br>    isLoading ? &lt;p&gt;Loading...&lt;/p&gt; : &lt;Component {...(otherProps as P)} /&gt;;<br>  return LoadingComponent;<br>};</pre>\n<h4>REA.08: Typing Custom Hooks</h4>\n<p>TypeScript can make custom hooks more reusable by defining flexible types. For example, data can be of type T or null</p>\n<pre>function useFetch&lt;T&gt;(url: string): { data: T | null; loading: boolean; error: Error | null } {<br>  const [data, setData] = useState&lt;T | null&gt;(null);<br>  const [loading, setLoading] = useState(true);<br>  const [error, setError] = useState&lt;Error | null&gt;(null);<br><br>  useEffect(() =&gt; {<br>    fetch(url)<br>      .then((response) =&gt; response.json())<br>      .then((data: T) =&gt; {<br>        setData(data);<br>        setLoading(false);<br>      })<br>      .catch((error) =&gt; {<br>        setError(error);<br>        setLoading(false);<br>      });<br>  }, [url]);<br><br>  return { data, loading, error };<br>}</pre>\n<h4>REA.09: Typing Component as a Namespace</h4>\n<p>Many libaries use a root component as a namespace (for example, Radix) and that means that the root is also a React function but also works as an object for other references. Using React.FC could be problematic for those cases. Instead, I prefer this approach:</p>\n<pre>type SelectProps = { options: string[]; onSelect: (value: string) =&gt; void };<br><br>const Select = ({ options, onSelect }: SelectProps): JSX.Element =&gt; (<br>  &lt;select onChange={(e) =&gt; onSelect(e.target.value)}&gt;<br>    {options.map((option) =&gt; (<br>      &lt;option key={option} value={option}&gt;<br>        {option}<br>      &lt;/option&gt;<br>    ))}<br>  &lt;/select&gt;<br>);<br><br>Select.Item = ({ value }: { value: string }): JSX.Element =&gt; &lt;option&gt;{value}&lt;/option&gt;;<br>Select.Root = (props: SelectProps): JSX.Element =&gt; &lt;Select {...props} /&gt;;<br><br>export default Select;</pre>\n<h4>REA.10: Typing RenderProps</h4>\n<p>When you use a component as a prop, you can type it this way. For example:</p>\n<pre>type RenderProps = {<br>  children: (isLoading: boolean) =&gt; JSX.Element;<br>};<br><br>const Loader = ({ children }: RenderProps): JSX.Element =&gt; {<br>  const [isLoading, setIsLoading] = useState(true);<br>  useEffect(() =&gt; {<br>    const timer = setTimeout(() =&gt; setIsLoading(false), 2000);<br>    return () =&gt; clearTimeout(timer);<br>  }, []);<br>  return children(isLoading);<br>};</pre>\n<h4>REA.11: Typing a Hook with Generics</h4>\n<p>When using generics you need to add a comma , after T so it doesn‚Äôt get confused with JSX syntax.</p>\n<pre>const useArray = &lt;T,&gt;(initialValue: T[]): {array: T[], addItem: (item: T) =&gt; void} =&gt; {<br>  const [array, setArray] = useState&lt;T[]&gt;(initialValue);<br>  const addItem = (item: T) =&gt; setArray((arr) =&gt; [...arr, item]);<br>  return {array, addItem};<br>};</pre>\n<h4>REA.12: Component Composition with Generics</h4>\n<p>Taking advantage of using T for generic types, we can create really versatile componets that render any kind of list. For example:</p>\n<pre>type ListProps&lt;T&gt; = {<br>  items: T[];<br>  renderItem: (item: T) =&gt; JSX.Element;<br>};<br><br>const List = &lt;T,&gt;({ items, renderItem }: ListProps&lt;T&gt;): JSX.Element =&gt; (<br>  &lt;div&gt;{items.map(renderItem)}&lt;/div&gt;<br>);</pre>\n<h4>REA.13: Typing Compound Components with Context and Generics</h4>\n<p>Since types can be defined using generics too, we can pass the generic down to any of our props.</p>\n<pre>type TabContextType&lt;T&gt; = {<br>  activeTab: T;<br>  setActiveTab: React.Dispatch&lt;React.SetStateAction&lt;T&gt;&gt;;<br>};<br><br>const TabContext = React.createContext&lt;TabContextType&lt;string&gt; | undefined&gt;(undefined);<br>const TabProvider = ({ children }: { children: React.ReactNode }) =&gt; {<br>  const [activeTab, setActiveTab] = useState(\"home\");<br>  return (<br>    &lt;TabContext.Provider value={{ activeTab, setActiveTab }}&gt;<br>      {children}<br>    &lt;/TabContext.Provider&gt;<br>  );<br>};</pre>\n<h3>06. The Weird Parts of TypeScript, Common Pitfalls</h3>\n<h4>TWPTS.01: Accept Anything Except Null or Undefined</h4>\n<p>In TypeScript, you can create types that exclude null or undefined. For example:</p>\n<pre>type NonNullish&lt;T&gt; = T extends null | undefined ? never : T;<br>const acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};</pre>\n<p>Interestingly, you can simplify this by using an empty object type instead:</p>\n<pre>type NonNullish&lt;T&gt; = {}; // NonNulish represents the same type as before<br>const acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};</pre>\n<p>This works because unknown in TypeScript is defined as:</p>\n<pre>type unknown = {} | undefined | null;</pre>\n<h4>TWPTS.02: Typing a Truly Empty Object</h4>\n<p>Defining an empty object is tricky. You can use Record&lt;PropertyKey, never&gt; to enforce no properties:</p>\n<pre>const acceptOnlyEmptyObject = (input: Record&lt;PropertyKey, never&gt;) =&gt; {};</pre>\n<p>However, a more foolproof approach uses a unique symbol:</p>\n<pre>declare const tag: unique symbol;<br>type EmptyObject = { [tag]?: never };</pre>\n<p>This ensures no properties are allowed, effectively representing a truly empty object.</p>\n<h4>TWPTS.03: Techniques for Triggering Excess Property Warnings</h4>\n<p>TypeScript‚Äôs assignability model is based on satisfying contracts, not exact matches. Excess property checks are only triggered under specific conditions, like inline object literals.</p>\n<p>Here are a few techniques for forcing excess property checks:</p>\n<p><strong>Add a Type Annotation</strong>:</p>\n<pre>type User = {<br> id: number;<br> name: string;<br>}<br><br>// Error for 'age', since it is not part of the type<br>const obj: User = { id: 1, name: \"John\", age: 30 };</pre>\n<p><strong>Use the </strong><strong>satisfies Keyword</strong>:</p>\n<p>Without it, just creating the object and then passing it down to a function that demands a user type would work just fine. But, if you want to strictly enforce the same signature, use satisfies.</p>\n<pre>const obj = { id: 1, name: \"John\", age: 30 } satisfies User;</pre>\n<p><strong>Inline the Variable</strong>:</p>\n<pre>//printUser requires a User type<br>printUser({ id: 1, name: \"John\", age: 30 }); // Error for 'age'</pre>\n<h4>TWPTS.04: Accessing Object Properties Using Keys</h4>\n<p>If you‚Äôre iterating through object keys and want to ensure type safety, you can cast the key to a keyof the object type.</p>\n<pre>interface User {<br>  id: number;<br>  name: string;<br>}<br><br>function printUser(user: User) {<br>  for (const keyProperty in user) {<br>    console.log(user[keyProperty as keyof User]);<br>  }<br>}</pre>\n<h4>TWPTS.05: Typing Callbacks with Varying Parameters</h4>\n<p>If you need a function type that can accept various argument lengths, you can define a flexible callback type:</p>\n<pre>type CallbackType = (<br>  event: Event,<br>  x?: number,<br>  y?: number,<br>  screenId?: number<br>) =&gt; void;<br><br>function listenToEvent(callback: CallbackType) {<br>  // callback logic<br>}</pre>\n<p>This allows the following calls:</p>\n<pre>listenToEvent(() =&gt; {});<br>listenToEvent((event) =&gt; {});<br>listenToEvent((event, x, y) =&gt; {});<br>listenToEvent((event, x, y, screenId) =&gt; {});</pre>\n<p>Just remember to narrow down the types inside the function to make it work properly.</p>\n<h4>TWPTS.06: Correctly Typing Functions that Handle Multiple Types</h4>\n<p>Consider a scenario where you have an object containing functions that handle different types. You want to dynamically call the correct function based on the input type:</p>\n<pre>const objOfFunctions = {<br>  string: (input: string) =&gt; input.toUpperCase(),<br>  number: (input: number) =&gt; input.toFixed(2),<br>  boolean: (input: boolean) =&gt; (input ? \"true\" : \"false\"),<br>};<br><br>type ObjKeys = string | number | boolean;<br>const format = (input: ObjKeys) =&gt; {<br>  const inputType = input as keyof typeof objOfFunctions;<br>  const formatter = objOfFunctions[inputType];<br><br>  return formatter(input as never); // 'as never' to force correct typing<br>};</pre>\n<h4>CPTF.01: Forgetting Non-null Assertion in Nested Structures</h4>\n<p>Accessing properties on nested objects without ensuring their existence can cause runtime errors.</p>\n<pre>type Engine = { type: string };<br>type Car = { engine?: Engine };<br><br>function getEngineType(car: Car): string {<br>  return car.engine.type || \"\"; // Error: Object is possibly 'undefined'<br>}</pre>\n<p>The property engine is optional in Car, and TypeScript warns that type might not exist. Use optional chaining (car.engine?.type) to prevent this error.</p>\n<h4>CPTF.02: Not Handling Readonly Array Types Correctly</h4>\n<p>Using readonly with arrays incorrectly can lead to unexpected mutations.</p>\n<pre>const numbers: readonly number[] = [1, 2, 3];<br>numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'</pre>\n<p>By default readonly arrays prevent mutation. Trying to mutate (e.g., push) will cause an error. To fix it, copy the array first if modifications are needed (const newNumbers = [...numbers, 4]).</p>\n<h4>CPTF.03: Promise&lt;void&gt; Usage</h4>\n<p>Returning Promise&lt;void&gt; can lead to issues if callers assume the promise is resolved with data.</p>\n<pre>async function fetchData(): Promise&lt;void&gt; {<br>  const data = await fetch(\"https://api.example.com/data\");<br>  return data; // Error: Type 'Response' is not assignable to type 'void'<br>}</pre>\n<h4>CPTF.04: Overlapping Types with Union and Intersection</h4>\n<p>Using unions and intersections together can lead to unintentional overlap in types.</p>\n<pre>type Bird = { wings: 2; fly: () =&gt; void };<br>type Fish = { fins: 2; swim: () =&gt; void };<br>type Animal = Bird | Fish;<br><br>function move(animal: Animal) {<br>  if (\"swim\" in animal) {<br>    animal.swim(); // Works for Fish<br>  } else {<br>    animal.fly(); // Error: Property 'fl' does not exist on type 'Bird | Fish'<br>  }<br>}</pre>\n<p>Solution:</p>\n<pre>type Bird = { wings: 2; fly: () =&gt; void };<br>type Fish = { fins: 2; swim: () =&gt; void };<br><br>type Animal = Bird | Fish;<br><br>function isFish(animal: Animal): animal is Fish {<br>  return \"swim\" in animal;<br>}<br><br>function move(animal: Animal) {<br>  if (isFish(animal)) {<br>    animal.swim(); // Now TypeScript knows this is a Fish<br>  } else {<br>    animal.fly(); // TypeScript knows this is a Bird<br>  }<br>}</pre>\n<p>TypeScript can‚Äôt infer the common structure of Bird | Fish without further guards. Using custom type guards (e.g., function isFish(animal: Animal): animal is Fish) helps ensure correct property access.</p>\n<h4>CPTF.05: Forgetting readonly for Constants</h4>\n<p>Not using readonly on constants can lead to accidental mutation. In the following example adding readonly to speed would prevent unwanted modifications.</p>\n<pre>class Car {<br>  public speed = 100; // speed should be readonly for this car<br>  accelerate() {<br>    this.speed += 10; // Modifies speed unexpectedly<br>  }<br>}<br><br>const myCar = new Car();<br>myCar.speed = 50; // Mistakenly changes speed</pre>\n<h4>CPTF.06: Overusing Type Assertions</h4>\n<p>Overusing as assertions can lead to ignored type errors. Type assertions (as) bypass type checks, leading to runtime errors if not used wisely. Sometimes they are necessary, but most of the time type guards (if checks) provide safer validation.</p>\n<pre>function getCarName(car: unknown): string {<br>  return (car as { name: string }).name; // Unsafe assumption that `car` has `name` property<br>}<br><br>console.log(getCarName({ brand: \"Toyota\" })); // Error: Cannot read property 'name'</pre>\n<p>A better alternative:</p>\n<pre>function getCarName(car: unknown): string {<br>  if (isCarWithName(car)) {<br>    return car.name; // Safe access, as the type is validated<br>  }<br>  throw new Error(\"Invalid car object: 'name' property is missing\");<br>}<br><br>function isCarWithName(car: unknown): car is { name: string } {<br>  return typeof car === \"object\" &amp;&amp; car !== null &amp;&amp; \"name\" in car &amp;&amp; typeof (car as any).name === \"string\";<br>}<br><br>console.log(getCarName({ name: \"Toyota\" })); // Output: \"Toyota\"<br>console.log(getCarName({ brand: \"Toyota\" })); // Throws error: Invalid car object</pre>\n<h4>CPTF.07: Ignoring Optional Properties</h4>\n<p>Optional properties are often missed in destructuring or direct access.</p>\n<pre>type Car = { make: string; model?: string };<br><br>function getModel(car: Car) {<br>  return car.model.toUpperCase(); // Error: Object is possibly 'undefined'<br>}</pre>\n<p>The property model is optional, so accessing it directly without checking leads to errors. Using optional chaining (car.model?.toUpperCase()) would prevent this.</p>\n<h4>CPTF.08: Incorrect Use of Generic Constraints</h4>\n<p>Setting incorrect generic constraints can lead to unexpected type limitations.</p>\n<pre>function merge&lt;T extends string, U extends number&gt;(a: T, b: U): string {<br>  return a + b;<br>}<br><br>merge(\"Engine\", 1); // Works fine<br>merge(123, 456); // Error: Argument of type 'number' is not assignable to parameter of type 'string'</pre>\n<p>By limiting T to string and U to number, merge becomes too restrictive. Using a broader generic constraint (e.g., T, U) would allow more flexibility.</p>\n<p>A way to solve it would be too change its signature (or modify the function):</p>\n<pre>function merge&lt;T extends string, U extends number&gt;(a: T, b: U): string | number {<br>  return a + b;<br>}</pre>\n<h3>Closing Thoughts</h3>\n<p>By now, you‚Äôve likely absorbed a lot of information, and I can‚Äôt blame you if your brain feels a little fried‚Ää‚Äî‚Äämine certainly did halfway through writing this.</p>\n<p>While I believe this guide provides a solid foundation to get you started, it‚Äôs important to note that some topics‚Ää‚Äî‚Ääparticularly when it comes to setting up TypeScript or getting into advanced generics‚Ää‚Äî‚Äähaven‚Äôt been fully covered here.</p>\n<p>Think of this guide as a springboard, but don‚Äôt stop here. There‚Äôs much more to explore as you continue to deepen your understanding.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce6844f008ad\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad\">Learn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<p>Want to learn TypeScript in one post in the shortest time possible? You can. With examples. Lots of them. Save yourself lots of hours by just reading this comprehensive guide.</p>\n<figure><img alt=\"Typescript logo with a crown\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJ73ynaAwbzLqZh-Nsf7Jw.jpeg\"></figure><h3>TS Snippets‚Äì A Quick Learning Approach</h3>\n<p>This guide features minimal text and focuses on bite-sized code examples designed to quickly elevate your proficiency in TypeScript.</p>\n<blockquote><em>Why snippets?</em></blockquote>\n<blockquote>Because examples are easier to digest than extensive documentation, keeping the essentials front and center without the extra layers. This guide is selective and opinionated‚Ää‚Äî‚Ääit won‚Äôt replace full documentation, but it will get you writing TypeScript fast. Really fast.</blockquote>\n<p>Think of it as a jumpstart. In under an hour or two, this guide takes you from zero to coding, prioritizing simplicity and practicality.</p>\n<p>Topics are categorized so you can move seamlessly between sections.</p>\n<h3>What to Expect from This Mega Post</h3>\n<p>In the upcoming sections, we will delve deeper into the following areas:</p>\n<ol>\n<li>\n<strong>Basic Usage (BU)</strong>: In this section, we‚Äôll cover TypeScript‚Äôs essential building blocks, like setting up types, defining functions and more. It‚Äôs everything you need to confidently start writing TypeScript code.</li>\n<li>\n<strong>Types (TPS), Interfaces (IN), Enums (EN)</strong>: We‚Äôll explore TypeScript‚Äôs tools for defining structured data, covering when to use types, interfaces, and enums to make your code more readable and robust.</li>\n<li>\n<strong>Inference (INFR)</strong>: Here, we‚Äôll look at TypeScript‚Äôs type inference capabilities and learn how to guide the compiler when it makes assumptions that don‚Äôt align with your intentions.</li>\n<li>\n<strong>Classes (CLS), Deriving Types from Variables (DTV) and Generics (GEN)</strong>: This section will dive into TypeScript‚Äôs object-oriented programming features, covering how to work with classes, derive new types from existing declarations, and use generics to write flexible and reusable code.</li>\n<li>\n<strong>Using with React (REA)</strong>: We‚Äôll dive into typing Components. Yep, that‚Äôs it.</li>\n<li>\n<strong>The Weird Parts (TWP) and Common Pitfalls (CPTF)</strong>: We‚Äôll dive into some quirky aspects of TypeScript that may trip you up, highlighting common pitfalls and how to avoid them for smoother coding.</li>\n</ol>\n<p>By the end, you‚Äôll have not only a deeper understanding of TypeScript but the practical know-how to apply it within your own projects and teams.</p>\n<p>You won‚Äôt be the TS hero of your team, but no one will guess you started only 40 minutes ago.</p>\n<p><strong>Let‚Äôs dive in!</strong></p>\n<h3>01. Basic Usage (BU)</h3>\n<h4>BU.01: Basic Types in TS</h4>\n<pre>let example1: string = \"Hello World!\";<br>let example2: number = 42;<br>let example3: boolean = true;<br>let example4: symbol = Symbol();<br>let example5: bigint = 123n;</pre>\n<h4>BU.02: Functions‚Ää‚Äî‚ÄäBasic notation</h4>\n<pre>function calculateSpeed(distanceInKilometers: number, timeInHours: number): number {<br>  return distanceInKilometers / timeInHours;<br>}<br><br>const calculateFuelEfficiency = (kilometers: number, liters: number): number =&gt; kilometers / liters;<br>const logCarInfo = (info: string): void =&gt; console.log(info);</pre>\n<h4>BU.03: Functions‚Ää‚Äî‚ÄäOptional parameters</h4>\n<pre>const formatCarDescription = (brand: string, model?: string): string =&gt; {<br>  if (!model) {<br>    return brand;<br>  }<br>  return `${brand} ${model}`;<br>};</pre>\n<h4>BU.04: Functions‚Ää‚Äî‚ÄäDefault parameters</h4>\n<pre>const createCar = (brand: string, year: number = 2024): string =&gt; {<br>  return `${brand}, Year: ${year}`;<br>};</pre>\n<h4>BU.05: Objects: Typing Object Literals (inline)</h4>\n<pre>const displayCarInfo = (car: { brand: string; year: number }): string =&gt; {<br>  return `${car.brand}, Year: ${car.year}`;<br>};</pre>\n<h4>BU.06: Objects: Typing Objects in own type</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const displayCarInfo = (car: Car): string =&gt; {<br>  return `${car.brand}, Year: ${car.year}`;<br>};</pre>\n<h4>BU.07: Objects: Making properties optional</h4>\n<pre>type Car = {<br>  brand: string;<br>  model?: string;<br>};<br><br>const describeCar = (car: Car): void =&gt; {<br>  const { brand, model } = car;<br>  if (model) {<br>    console.log(`${brand} ${model}`);<br>    return;<br>  }<br>  console.log(`${brand}`);<br>};</pre>\n<h4>BU.08: Objects: Using Record for Dynamically Typing</h4>\n<pre>const carFeatures: Record&lt;string, string&gt; = {};<br><br>carFeatures.color = \"Red\";<br>carFeatures.transmission = \"Automatic\";<br>carFeatures.condition = \"New\";</pre>\n<h4>BU.09: Arrays‚Ää‚Äî‚ÄäBasic notation</h4>\n<p>Prefer the [] syntax instead of the Array&lt;&gt; one</p>\n<pre>type CarInventory = {<br>  dealerId: string;<br>  carBrands: string[]; // alternatively, Array&lt;string&gt;<br>};</pre>\n<h4>BU.10: Arrays of objects</h4>\n<p>Prefer to define array of objects as types</p>\n<pre>type Feature = {<br>  name: string;<br>  description: string;<br>};<br><br>type CarModel = {<br>  brand: string;<br>  year: number;<br>  features: Feature[];<br>};<br><br>const processCarModel = (carModel: CarModel) =&gt; {<br>  // Do something with the car model in here<br>};<br><br>processCarModel({<br>  brand: \"Toyota\",<br>  year: 2024,<br>  features: [<br>    { name: \"Safety Rating\", description: \"5 stars\" },<br>    { name: \"Fuel Efficiency\", description: \"30 km/L\" },<br>  ],<br>});</pre>\n<h4>BU.11: Rest params</h4>\n<p>Treat them as array</p>\n<pre>export function listCarModels(...models: string[]): string {<br>  return models.join(\", \");<br>}</pre>\n<h4>BU.12: Tuples</h4>\n<p>Tuples are arrays of fixed length. Not necessarily 2 like in some coding languages. For example, useState returns a tuple.</p>\n<pre>const setCarDetails = (car: [string, number]) =&gt; {<br>  const brand = car[0];<br>  const year = car[1];<br>  console.log(`Car: ${brand}, Year: ${year}`);<br>};<br><br>setCarDetails([\"Toyota\", 2024]);</pre>\n<h4>BU.13: Using Optional Tuple members in TS</h4>\n<pre>const setCarSpecs = (specs: [string, number, number?]) =&gt; {<br>  const brand = specs[0];<br>  const year = specs[1];<br>  const kilometrage = specs[2];<br><br>  console.log(`Car: ${brand}, Year: ${year}${kilometrage !== undefined ? `, Kilometrage: ${kilometrage} km` : ''}`);<br>};<br><br>setCarSpecs([\"Honda\", 2024]);<br>setCarSpecs([\"Ford\", 2023, 15000]);</pre>\n<h4>BU.14: Using `any`</h4>\n<p>Don‚Äôt. The only placed allowed is when catching an error.</p>\n<pre>try {<br>  someDangerousFunctionThatMightThrow();<br>} catch (error: any) { // Acceptable use of `any`<br>  console.error(\"Caught an error:\", error.message);<br>}</pre>\n<h4>BU.15: Typing an Event Listener</h4>\n<p>Void just doesn‚Äôt care what you return. Better than any for functions.</p>\n<pre>const addClickEventListener = (listener: (this: Document, ev: MouseEvent) =&gt; void) =&gt; {<br>  document.addEventListener(\"click\", listener);<br>};<br><br>addClickEventListener(() =&gt; {<br>  console.log(\"Clicked!\");<br>});<br><br>// TypeScript will catch this as an error<br>addClickEventListener(<br>  // @ts-expect-error<br>  \"abc\" // Incorrect type<br>);</pre>\n<h4>BU.16: Typing sets</h4>\n<pre>const carBrands = new Set&lt;string&gt;();</pre>\n<h4>BU.17: Typing Maps</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const carMap = new Map&lt;number, Car&gt;();<br><br>carMap.set(1, { brand: \"Toyota\", year: 2024 });<br>carMap.set(2, { brand: \"Ford\", year: 2023 });</pre>\n<h4>BU.18: Typing Json.parse</h4>\n<pre>const parsedCarData: { brand: string; year: number; } = JSON.parse('{\"brand\": \"Honda\", \"year\": 2024}');</pre>\n<pre>async function fetchData(): Promise&lt;number&gt; {<br>  const response = await fetch('https://api.example.com/data');<br>  const data = await response.json(); //option b, type data<br>  return data;<br>}</pre>\n<h4>BU.20: Using Union types</h4>\n<p>Union types are the ‚Äúor‚Äù operator of TypeScript:</p>\n<pre>function getCarDetails(brand: string | null) {<br>  if (brand !== null) {<br>    return `Car: ${brand}`;<br>  }<br><br>  return \"Unknown Car\";<br>}</pre>\n<h3>02. Types, Interfaces, Enums</h3>\n<h4>Objects introduction</h4>\n<p>Objects in TypeScript can be typed using either type or interface. There is a never ending war about ‚Äúwhich one is best‚Äù the truth is, just pick one and be consistent.</p>\n<p>Both are similar, but type is more flexible for unions and complex types, while interface is extendable and better for defining class structures.</p>\n<p>For the sake of this opinionated guide, we will prefer types, but also will explain interfaces.</p>\n<h4>Types vs. Interfaces</h4>\n<ul>\n<li>Interfaces uses extend, Types uses &amp; to add properties to a definition</li>\n<li>Types match React‚Äôs declarative syntax a little bit better</li>\n<li>Interfaces can only type classes or objects. Types can represent other elements besides objects.</li>\n<li>Interfaces are slightly more performant</li>\n<li>Interfaces can extend several interfaces</li>\n<li>Interfaces can be declared several times in the same scope. The ultimate definition will be the merge of all the interfaces. Types will error with same declarations in the same scope. Forces you to use the &amp; to create mixed types.</li>\n<li><strong>Mostly it‚Äôs a matter of style.</strong></li>\n</ul>\n<h4>Types</h4>\n<h4>TPS.01: A basic example</h4>\n<pre>type Car = {<br>  brand: string;<br>  year: number;<br>};<br><br>const myCar: Car = {<br>  brand: \"Tesla\",<br>  year: 2024,<br>};</pre>\n<h4>TPS.02: Extending a type‚Ää‚Äî‚ÄäUsing intersections</h4>\n<p>You can use the &amp; to extend an existing type. That is call an <em>intersection</em>. Prefer composability, using types that ‚Äòextend‚Äô from other types rather than adding optional props that might create ambiguity (see Unions and Narrowing)</p>\n<pre>type Vehicle = {<br>  brand: string;<br>  model: string;<br>};<br><br>type ElectricVehicle = Vehicle &amp; {<br>  batteryCapacity: number; // in kWh<br>};<br><br>const teslaModelS: ElectricVehicle = {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>TPS.03: Typing objects dynamically</h4>\n<p>Sometimes you want the object to have dynamic keys, but that they all match a format. For example, all the keys should be a number. For that, you can use Record&lt;&gt;</p>\n<pre>const carRatings: Record&lt;string, number&gt; = {};<br><br>carRatings.performance = 95;<br>carRatings.safety = 90;<br>carRatings.comfort = 85;</pre>\n<h4>TPS.04: Supporting different types of Keys for Maps and Sets</h4>\n<p>TS has an own type that is the union of string | number | symbol. It is named PropertyKey.</p>\n<pre>// PropertyKey = string | number | symbol<br><br>const carMap = new Map&lt;PropertyKey, string&gt;();<br><br>const key1: string = \"brand\";<br>const key2: number = 2024;<br>const key3: symbol = Symbol(\"uniqueModel\");<br><br>carMap.set(key1, \"Toyota\");<br>carMap.set(key2, \"Camry\");<br>carMap.set(key3, \"SpecialEdition\");</pre>\n<h4>TPS.05: Restricting keys of an object to a list</h4>\n<p>Let‚Äôs say you want to generate an object where the keys are dynamic but restricted to a list. For example:</p>\n<pre>const carConfigurations = {<br>  sedan: {<br>    fuelType: \"petrol\",<br>    doors: 4,<br>  },<br>  suv: {<br>    fuelType: \"diesel\",<br>    doors: 5,<br>  },<br>  hatchback: {<br>    fuelType: \"electric\",<br>    doors: 5,<br>  },<br>};</pre>\n<p>As you can see they all follow the same structure, yet you may want to add other environments. The way to type is to create a list of those possible keys:</p>\n<pre>type CarType = 'sedan' | 'suv' | 'hatchback';<br><br>type CarConfigurations = {<br>  [Type in CarType]: {<br>    fuelType: string;<br>    doors: number;<br>  };<br>};<br><br>const carConfigurations: CarConfigurations = {<br>  sedan: {<br>    fuelType: \"petrol\",<br>    doors: 4,<br>  },<br>  suv: {<br>    fuelType: \"diesel\",<br>    doors: 5,<br>  },<br>  hatchback: {<br>    fuelType: \"electric\",<br>    doors: 5,<br>  },<br>};</pre>\n<p>Alternatively, this could be annotated too as:</p>\n<pre>type CarType = 'sedan' | 'suv' | 'hatchback';<br><br>type Configurations = Record&lt;<br>  CarType,<br>  { apiBaseUrl: string; timeout: number; }<br> &gt;<br><br>const carConfigurations: CarConfigurations = {...} // the same object as before</pre>\n<h4>TPS.06: Creating a type that is a ‚Äòslice‚Äô from another one: Pick</h4>\n<p>Pick allows to create a ‚Äòslice‚Äô of a type. Prefer using type composition (see second example). You can‚Äôt pick a key that doesn‚Äôt exist on the type.</p>\n<pre>type Car = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  color: string;<br>}<br><br>type PickedCar = Pick&lt;Car, 'brand' | 'model'&gt;;<br><br>const TeslaCar: PickedCar = {brand: 'Tesla', model: 'CyberTruck'}</pre>\n<h4>TPS.07: Creating a type that is a ‚Äòslice‚Äô from another one: Omit</h4>\n<p>Like pick, but the opposite. Instead of keeping the marked keys, it removes them. Omit won‚Äôt complain if you pass a key that wasn‚Äôt declared ü§∑</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  color: string;<br>}<br><br>const addCar = (carInfo: Omit&lt;Car, 'id'&gt;) =&gt; {<br>  // Do something with the carInfo<br>};<br><br>addCar({<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  year: 2024,<br>  color: \"Metallic\",<br>});</pre>\n<h4>TPS.08: Creating a type that is a ‚Äòslice‚Äô from another one: Omit in unions</h4>\n<p>Omit isn‚Äôt distributive.</p>\n<pre>type Car = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  imageId: string;<br>};<br><br>type Truck = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  capacity: number;<br>  imageId: string;<br>};<br><br>type Motorcycle = {<br>  id: string;<br>  brand: string;<br>  model: string;<br>  cc: number;<br>  imageId: string;<br>};<br><br>type Vehicle = Car | Truck | Motorcycle;<br><br>type VehicleWithoutId = Omit&lt;Vehicle, \"id\"&gt;;</pre>\n<p>The reason this happens is due to a technicality of how Omit processes union types.</p>\n<p>Omit doesn‚Äôt iterate over every member of the union. Instead, it squashes the union into a structure it comprehends, and then operates on this new construct. As a result, the outcome is different than what you might expect. To remedy this, let‚Äôs take a look at DistributiveOmit</p>\n<h4>TPS.09: DistributiveOmit</h4>\n<p>Following the previous snippet, if you want to create an union where ‚Äòid‚Äô is ommited in each case, you can apply a distributive omit:</p>\n<pre>type DistributiveOmit&lt;T, K extends PropertyKey&gt; = T extends any<br>  ? Omit&lt;T, K&gt;<br>  : never;<br><br>type Vehicle = Car | Truck | Motorcycle;<br>type VehicleWithoutId = DistributiveOmit&lt;Vehicle, \"id\"&gt;;</pre>\n<h4>TPS.10: Using Partials</h4>\n<p>Sometimes, for example updates, you only want to pass 1 property to update.</p>\n<p>It is tempting to fix it by making all props optional with ? but that would change the definition of Product, and that isn‚Äôt what we want.</p>\n<p>The solution is to use Partial . Partial makes all the definition optional, like if it where with ?.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year: number;<br>  description: string;<br>};<br><br>const updateCar = (id: number, carInfo: Partial&lt;Omit&lt;Car, \"id\"&gt;&gt;) =&gt; {<br>  // Do something with the carInfo<br>};<br><br>updateCar(1, {<br>  brand: \"Tesla\",<br>});<br><br>updateCar(1, {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>});<br><br>updateCar(1, {<br>  year: 2024,<br>});</pre>\n<p>Note: Partial doesn‚Äôt support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.</p>\n<h4>TPS.11: Using Required</h4>\n<p>The Required utility type in TypeScript does the opposite of Partial‚Äîit makes all properties mandatory. This is useful when you want to ensure that every property of an object must be provided.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year?: number; <br>};<br><br>const createCar = (carInfo: Required&lt;Car&gt;) =&gt; {<br>  console.log(carInfo);<br>};<br><br>createCar({<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  year: 2024<br>});</pre>\n<p>Note: Same as Partial, Required doesn‚Äôt support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.</p>\n<h4>TPS.12: Partial, Required, Pick, mixed together</h4>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  year?: number; // Optional<br>  color?: string; // Optional<br>};<br><br>// Make only 'brand' and 'model' required, while 'id', 'year', and 'color' remain optional<br>type PartialCarWithRequired = Partial&lt;Car&gt; &amp; Required&lt;Pick&lt;Car, 'brand' | 'model'&gt;&gt;;<br><br>const createCar: PartialCarWithRequired = {<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>  // id, year, and color can be omitted<br>}<br><br>console.log(createCar);</pre>\n<h4>TPS.13: Using Readonly</h4>\n<p>The Readonly utility type allows you to create a type with all properties of an existing type set to <strong>readonly</strong>. This means that the properties cannot be reassigned, providing a way to enforce immutability in your data structures. This is particularly useful when you want to ensure that certain data should not be changed after it has been created.</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>};<br><br>// Create a readonly version of Car<br>type ReadonlyCar = Readonly&lt;Car&gt;;<br><br>const car: ReadonlyCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"CyberTruck\",<br>};</pre>\n<p>Using it in arrays:</p>\n<pre>type Car = {<br>  id: number;<br>  brand: string;<br>  model: string;<br>};<br><br>type ReadonlyCarArray = readonly Car[];<br>//alternatively <br>//type ReadonlyCarArray = ReadonlyArray&lt;Car&gt;;<br><br>const cars: ReadonlyCarArray = [<br>  { id: 1, brand: \"Tesla\", model: \"CyberTruck\" },<br>  { id: 2, brand: \"Ford\", model: \"F-150\" },<br>];</pre>\n<h4>TPS.14: Using NonNullable</h4>\n<p>The NonNullable utility type is used to exclude null and undefined from a type. This is helpful when you want to ensure that a value is defined and not null, which can prevent runtime errors related to dereferencing null or undefined values.</p>\n<pre>type Car = {<br>  id: number;<br>  model: string | null;<br>};<br><br>// Create a version of Car with a non-nullable model<br>type NonNullableCar = {<br>  id: number;<br>  model: NonNullable&lt;Car['model']&gt;;<br>};<br><br>const car: NonNullableCar = {<br>  id: 1,<br>  model: \"Tesla\",<br>};<br><br>// Assigning null will cause a compilation error<br>// car.model = null; // Error: Type 'null' is not assignable to type 'string'.</pre>\n<h4>Interfaces</h4>\n<p>Interfaces in TypeScript allow you to define the shape of objects and can be used in a similar way to types. They are particularly useful for defining class structures and can also be extended, providing a flexible way to create complex data structures. They suit better for classes.</p>\n<h4>INT.01: Basic Interface Definition</h4>\n<pre>interface Car {<br>  model: string;<br>  year: number;<br>}<br><br>// Which in this case could had been the same as:<br>// type Car = {<br>//   model: string;<br>//   year: number;<br>// }<br><br>const vehicle: Car = {<br>  model: \"Tesla Model 3\",<br>  year: 2020,<br>};</pre>\n<h4>INT.02: Extending Interfaces</h4>\n<p>You can create new interfaces by extending existing ones. This helps you build on top of existing structures without repeating code. This would be the way to compose other interfaces, the same way that types uses intersections, interfaces extend.</p>\n<pre>interface Vehicle {<br>  brand: string;<br>  model: string;<br>}<br><br>interface ElectricCar extends Vehicle {<br>  batteryCapacity: number; // in kWh<br>}<br><br>const teslaModelS: ElectricCar = {<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>INT.03: Squashing Interfaces in the Same Namespace</h4>\n<p>One of the powerful features of interfaces is that they can be declared multiple times within the same scope. TypeScript automatically merges these declarations, allowing you to add properties to an interface as needed.</p>\n<pre>interface Car {<br>  brand: string;<br>  model: string;<br>}<br><br>interface Car {<br>  year: number;<br>}<br><br>const myCar: Car = {<br>  brand: \"Toyota\",<br>  model: \"Camry\",<br>  year: 2021,<br>};</pre>\n<h4>INT.04: Extending Interfaces with Function Types</h4>\n<p>Interfaces can also define function types, enabling you to type functions more explicitly.</p>\n<pre>interface CarProcessor {<br>  (car: Car): void;<br>}<br><br>const processCar: CarProcessor = (car) =&gt; {<br>  console.log(`Processing car: ${car.brand} ${car.model}`);<br>};</pre>\n<h4>INT.05: Namespaced Interfaces</h4>\n<p>You can use namespaces to group related interfaces together, helping to organize your code better. Since ES Modules, this feature is less common, and prefered to be avoided.</p>\n<pre>namespace CarModule {<br>  export interface Car {<br>    id: number;<br>    brand: string;<br>    model: string;<br>  }<br><br>  export interface ElectricCar extends Car {<br>    batteryCapacity: number;<br>  }<br>}<br><br>const tesla: CarModule.ElectricCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>  batteryCapacity: 100,<br>};</pre>\n<h4>INT.06: Optional Properties</h4>\n<p>Interfaces can have optional properties, allowing you to define flexible structures</p>\n<pre>interface Car {<br>  id: number;<br>  brand: string;<br>  model: string;<br>  color?: string; // Optional property<br>}const tesla: Car = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model 3\",<br>};</pre>\n<h4>INT.07: Readonly Properties</h4>\n<p>To create properties that cannot be modified after their initial assignment, you can use the readonly modifier.</p>\n<pre>interface ImmutableUser {<br>interface ImmutableCar {<br>  readonly id: number;<br>  readonly brand: string;<br>  readonly model: string;<br>}<br><br>const myCar: ImmutableCar = {<br>  id: 1,<br>  brand: \"Tesla\",<br>  model: \"Model S\",<br>};<br><br>// myCar.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.</pre>\n<h3>Enums</h3>\n<h4>EN.01: Enums‚Ää‚Äî‚ÄäPlease Don‚Äôt use them</h4>\n<p>Enums are widely unused since there are more modern approaches. Visit <a href=\"https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh#:~:text=Excessive%20use%20of%20regular%20ENUMs,new%20values%20can%20be%20added.\">here</a> for more details.</p>\n<p><strong>Example</strong>:</p>\n<pre>enum CarType {<br>  SEDAN = \"sedan\",<br>  SUV = \"suv\",<br>  TRUCK = \"truck\",<br>}<br><br>function createCar(type: CarType) {<br>  // Implementation here<br>}<br><br>createCar(CarType.SEDAN); // Valid<br>createCar('sedan'); // Invalid</pre>\n<p>Instead, use as const combined with exporting the union of values:</p>\n<pre>export const CarTypes = {<br>  SEDAN: \"sedan\",<br>  SUV: \"suv\",<br>  TRUCK: \"truck\",<br>} as const;<br><br>// Exporting the type derived from the CarTypes constant<br>export type CarType = typeof CarTypes[keyof typeof CarTypes];<br><br>const handlerFunction = (carType: CarType) =&gt; {<br>  if (carType === CarTypes.SEDAN) {<br>    return 'This is a sedan';<br>  }<br>  return 'This is not a sedan';<br>}<br><br>handlerFunction('sedan'); // This will work<br>handlerFunction(CarTypes.SEDAN); // This will work too.</pre>\n<h4>EN.02: Exporting nested enums as a flatten entity</h4>\n<pre>type ApiEndpoint =<br>  | `/${string}`<br>  | Record&lt;string, ApiEndpoint&gt;;<br><br>const apiEndpoints = {<br>  cards: {<br>    GET_ALL: '/cards',<br>    GET_BY_ID: '/cards/:id',<br>    CREATE: '/cards/create',<br>    UPDATE: '/cards/update/:id',<br>    DELETE: '/cards/delete/:id',<br>    CATEGORIES: {<br>      GET_ALL: '/cards/categories',<br>      GET_BY_ID: '/cards/categories/:id',<br>      CREATE: '/cards/categories/create',<br>      UPDATE: '/cards/categories/update/:id',<br>      DELETE: '/cards/categories/delete/:id',<br>    },<br>    TAGS: {<br>      GET_ALL: '/cards/tags',<br>      GET_BY_ID: '/cards/tags/:id',<br>      CREATE: '/cards/tags/create',<br>      UPDATE: '/cards/tags/update/:id',<br>      DELETE: '/cards/tags/delete/:id',<br>    },<br>  },<br>} as const;<br><br>type Flatten&lt;T&gt; = T extends Record&lt;string, infer U&gt; ? Flatten&lt;U&gt; : T;<br><br>export type ApiEndpoints = Flatten&lt;typeof apiEndpoints&gt;;<br><br>const someEndpoint: ApiEndpoints = apiEndpoints.cards.GET_ALL;<br>const someOtherEndpoint: ApiEndpoints = '/cards/categories';</pre>\n<h3>03. Inference</h3>\n<p>Inference is the way that TS ‚Äòguesses‚Äô what type some variable is. Sometimes, you need to help it a bit.</p>\n<h4>INFR.01: Inference: let and const change the way TS assigns types</h4>\n<p>Using let allows reassignment, resulting in the type being inferred as string. In contrast, const can‚Äôt be reassigned, leading TypeScript to infer its type as a literal.</p>\n<p>For example:</p>\n<pre>let type = \"sedan\"; // inferred as string, because it can be reassigned</pre>\n<p>While:</p>\n<pre>const type = \"sedan\"; // inferred as 'sedan' because it can't be reassigned</pre>\n<h4>INFR.02: Object property inference</h4>\n<p>TypeScript‚Äôs type inference can sometimes lead to unintended results when inferring object properties. Since objects are dynamically typed, a string in a key will default to string instead of maybe a literal.</p>\n<p>Most of the time, if you are using an approach like the following one, TS will infer ‚Äòstrings‚Äô instead of your assigned type ButtonAttributes. To avoid that, just add the type.</p>\n<p>This will error:</p>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: \"sedan\", // inferred as string<br>};<br><br>modifyCar(carAttributes); // will error</pre>\n<p>But this won‚Äôt</p>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes: CarAttributes = {<br>  type: \"sedan\",<br>};<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.03: Using ‚Äòas const‚Äô to force inference</h4>\n<p>The same example as before can be solved by instructing TS that it should be considered as const.</p>\n<p>as const not only locks the type to a specific literal but also makes the properties of the object readonly. Better to use a type if you can, but sometimes this trick will also do. It all depends on if you want that readonly attribute as well or not.</p>\n<pre>type CarAttributes = {<br>  type: 'sedan' | 'suv' | 'truck';<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: 'sedan' as const,<br>};<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.04: Using ‚Äòsatisfies‚Äô</h4>\n<p>Another way to solve the previous issue is using satisfies. satisfies helps in the case the object doesn‚Äôt have the same structure as the type.</p>\n<p>Using satisfies checks the object against the type at compile-time without requiring the object to match the type structure perfectly, thus enhancing flexibility.</p>\n<pre>type CarAttributes = {<br>  type: 'sedan' | 'suv' | 'truck';<br>};<br><br>const modifyCar = (attributes: CarAttributes) =&gt; {};<br><br>const carAttributes = {<br>  type: 'sedan',<br>} satisfies CarAttributes;<br><br>modifyCar(carAttributes);</pre>\n<h4>INFR.05: ‚ÄòReadonly‚Äô and ‚Äòas const‚Äô</h4>\n<p>Using as const on an object makes it readonly, eliminating the need to define the type explicitly. This is important because immutability ensures that the values of properties can‚Äôt be changed after the object is created, reducing the risk of unintended side effects in your code.</p>\n<p>The 2 following snippets are exactly the same:</p>\n<pre>const carAttributes: CarAttributes = {<br>  sport: {<br>    type: \"sedan\",<br>  },<br>  utility: {<br>    type: \"suv\",<br>  },<br>} as const;<br><br>type CarType = \"sedan\" | \"suv\" | \"truck\";<br><br>type CarAttributes = {<br>  readonly sport: {<br>    readonly type: CarType;<br>  };<br>  readonly utility: {<br>    readonly type: CarType;<br>  };<br>};<br><br>const carAttributes: CarAttributes = {<br>  sport: {<br>    type: \"sedan\",<br>  },<br>  utility: {<br>    type: \"suv\",<br>  },<br>}</pre>\n<p>As you can see, using as const is a nice shortcut for those readonly properties.</p>\n<h4>INFR.06: Function Overloading</h4>\n<p>Function overloading allows you to define multiple signatures for a function, enabling it to accept different parameter types and return different types based on the parameters provided.</p>\n<p>In an ideal world, this kind of thing shouldn‚Äôt happen often, but if you have some kind of ‚Äúmaster‚Äù function that handles many cases with many types, it can be useful.</p>\n<p>This can improve code readability and maintainability by allowing a single function name to handle multiple use cases.</p>\n<p>Needless to say, try to avoid this kind of thing.</p>\n<p><strong>Example</strong>:</p>\n<pre>function processCar(input: string): boolean; // Returns a boolean<br>function processCar(input: number): string; // Returns a string<br>function processCar(input: boolean): number; // Returns a number<br>function processCar(input: string | number | boolean): boolean | string | number {<br>  if (typeof input === \"string\") {<br>    return input.length &gt; 0; // Returns true if the string is non-empty<br>  } else if (typeof input === \"number\") {<br>    return `The car count is ${input}.`; // Returns a string representation<br>  } else if (typeof input === \"boolean\") {<br>    return input ? 1 : 0; // Returns 1 for true and 0 for false<br>  }<br>  throw new Error(\"Invalid input type.\");<br>}</pre>\n<h4>INFR.07: Type Guards</h4>\n<p>Type guards are a feature that allow you to narrow down the type of a variable within a conditional block. This can enhance type safety and prevent runtime errors by ensuring that the operations performed on variables are valid for their types.</p>\n<p><strong>Example</strong>:</p>\n<pre>function logCar(value: string | number) {<br>  if (typeof value === \"string\") {<br>    console.log(`Car model: ${value}`);<br>  } else { // TS would know that value is a number<br>    console.log(`Car ID: ${value}`);<br>  }<br>}</pre>\n<h4>INFR.08: Scope Narrowing</h4>\n<p>Sometimes TS won‚Äôt be able to detect the type of a variable. Lowering the declaration of the variable to the same scope sometimes fixes it:</p>\n<pre>const findCarsByModel = (<br>  searchParams: { model?: string },<br>  cars: {<br>    id: string;<br>    model: string;<br>  }[],<br>) =&gt; {<br>  if (searchParams.model) {<br>    const { model } = searchParams; // Scope narrowing to avoid errors<br>    return cars.filter((car) =&gt; car.model.includes(model));<br>  }<br>  return cars;<br>};</pre>\n<h4>INFR.09: Discriminated Unions and Types: don‚Äôt use one type to try to cover several entities (avoid ambiguity, segregate the entities)</h4>\n<p>In this example Vehicle can represent both a circle and a rectangle. But it is not clear:</p>\n<pre>type Vehicle = {<br>  kind: string;<br>  horsepower?: number;<br>  seatingCapacity?: number;<br>};<br><br>function getSpecifications(vehicle: Vehicle) {<br>  if (vehicle.kind === \"sedan\") {<br>    return `Seating Capacity: ${vehicle.seatingCapacity}`;<br>  } else {<br>    return `Horsepower: ${vehicle.horsepower}`;<br>  }<br>}</pre>\n<p>Instead:</p>\n<pre>type Sedan = {<br>  kind: 'sedan';<br>  seatingCapacity: number;<br>};<br><br>type Truck = {<br>  kind: \"truck\";<br>  horsepower: number;<br>};<br><br>type Vehicle = Sedan | Truck;<br><br>function getSpecifications(vehicle: Vehicle) {<br>  if (vehicle.kind === \"sedan\") {<br>    return `Seating Capacity: ${vehicle.seatingCapacity}`;<br>  }<br>  return `Horsepower: ${vehicle.horsepower}`;<br>}</pre>\n<h4>INFR.10: Avoid using ‚Äòlet‚Äô without types:</h4>\n<pre>type CarAttributes = {<br>  type: \"sedan\" | \"suv\" | \"truck\";<br>};<br><br>let type = \"sedan\"; // inferred as string, using a const would prevent this<br><br>const carAttributes: CarAttributes = {<br>  type, // error due to inferred string type<br>};</pre>\n<h4>INFR.11: The ‚ÄòNever‚Äô Type</h4>\n<p>The never type in TypeScript represents a value that never occurs. It's used in functions that throw errors or have infinite loops, as they never return a value.</p>\n<pre>function throwError(message: string): never {<br>  throw new Error(message);<br>}</pre>\n<p>It also represents incompatible types. For example: string &amp; number is going to be never.</p>\n<pre>type Car = {<br>  id: string;<br>  model: string;<br>};<br><br>type Truck = {<br>  id: number; // incompatible with Car's id<br>  model: string;<br>  payloadCapacity: number;<br>};<br><br>const impossible: Car &amp; Truck = {<br>  id: 'C123', // error because id must be both string and number, which is impossible<br>  model: 'X1',<br>  payloadCapacity: 3000<br>};</pre>\n<h3>04. Classes, deriving types, Generics</h3>\n<h4>Classes</h4>\n<h4>CLS.01: Default properties</h4>\n<pre>class Car {<br>  readonly make: string;<br>  readonly model: string;<br><br>  constructor(make = \"Generic\", model = \"Model\") {<br>    this.make = make;<br>    this.model = model;<br>  }<br>}<br><br><br>// Equivalent to:<br>class Car {<br>  readonly make: string = \"Generic\";<br>  readonly model: string = \"Model\";<br>}</pre>\n<h4>CLS.02: Creating Constructors</h4>\n<pre>class Car {<br>  make = \"Generic\";<br>  model = \"Model\";<br><br>  constructor(opts?: { make: string; model: string } = { make: \"Generic\", model: \"Model\" }) {<br>    this.make = opts.make;<br>    this.model = opts.model;<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.03: Declaring Methods</h4>\n<pre>class Car {<br>  make = \"Generic\";<br>  model = \"Model\";<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.04: Getters</h4>\n<pre>class Car {<br>  make: string;<br>  model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.make = details?.make ?? \"Generic\";<br>    this.model = details?.model ?? \"Model\";<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br><br>  get details() {<br>    return { make: this.make, model: this.model };<br>  }<br>}</pre>\n<h4>CLS.05: Private properties</h4>\n<p>You can use the private or # prefix in the member declaration to make it private. Both ways will work, it is a matter of style.</p>\n<pre>class Car {<br>  private make: string;<br>  private model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.make = details?.make ?? \"Generic\";<br>    this.model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.make, model: this.model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}<br><br>// Or with `#` prefix:<br>class Car {<br>  #make: string;<br>  #model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.#make = details?.make ?? \"Generic\";<br>    this.#model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.06: Setters</h4>\n<p>TS understands the type of the setter by checking the getter. No need to define the type.</p>\n<pre>class Car {<br>  #make: string;<br>  #model: string;<br><br>  constructor(details?: { make: string; model: string }) {<br>    this.#make = details?.make ?? \"Generic\";<br>    this.#model = details?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  // since the get details returns an object with make and model, the set expects the same signature<br>  set details(details) {<br>    this.#make = details.make;<br>    this.#model = details.model;<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.07: Overriding</h4>\n<p>If in the tsConfig the option noImplicitOverride is turned on, you will need to add the override keyword when extending a method from an inherited class.</p>\n<pre>// inside tsconfig.json<br>{<br>  \"compilerOptions\": {<br>    ...<br>    \"noImplicitOverride\": true</pre>\n<pre>class Vehicle {<br>  logType() {<br>    console.log(\"Vehicle type\");<br>  }<br>}<br><br>class Car extends Vehicle {<br>  override logType() {<br>    console.log(\"Car type\");<br>  }<br>}</pre>\n<h4>CLS.08: Implementing a ‚Äòtype‚Äô or ‚Äòinterface‚Äô</h4>\n<p>Classes can implement interfaces or types. Stick to using interfaces. As you can see, it can handle both, but the industry prefers the first one.</p>\n<pre>interface VehicleOptions {<br>  make: string;<br>  model: string;<br>}<br><br>type VehicleType = {<br>  details: { make: string; model: string };<br>  drive: (speed: number) =&gt; void;<br>};<br><br>class Car implements VehicleType {<br>  #make: string;<br>  #model: string;<br><br>  constructor(initial?: VehicleOptions) {<br>    this.#make = initial?.make ?? \"Generic\";<br>    this.#model = initial?.model ?? \"Model\";<br>  }<br><br>  get details() {<br>    return { make: this.#make, model: this.#model };<br>  }<br><br>  drive(speed: number) {<br>    console.log(`Driving at ${speed} mph.`);<br>  }<br>}</pre>\n<h4>CLS.09: Abstract Classes</h4>\n<p>abstract classes allow you to define methods that subclasses must implement, as well as methods with default behavior. This is useful when designing base classes for other classes to extend.</p>\n<pre>abstract class Vehicle {<br>  abstract speed(): number;<br><br>  describe(): string {<br>    return \"This is a vehicle.\";<br>  }<br>}<br><br>class Car extends Vehicle {<br>  constructor(public maxSpeed: number) {<br>    super();<br>  }<br><br>  speed(): number {<br>    return this.maxSpeed;<br>  }<br>}</pre>\n<h4>CLS.10: Static Properties and Methods</h4>\n<p>static members belong to the class itself rather than to any specific instance. This is useful for utility functions or properties that should be shared across all instances. So far, the static is nothing new to TS.</p>\n<pre>class VehicleUtils {<br>  static MAX_SPEED = 120;<br><br>  static calculateDistance(time: number) {<br>    return this.MAX_SPEED * time;<br>  }<br>}<br><br>console.log(VehicleUtils.calculateDistance(2)); // 240</pre>\n<h4>CLS.11: Parameter Properties</h4>\n<p>This shorthand allows you to define and initialize class members directly in the constructor‚Äôs parameter list, reducing boilerplate code.</p>\n<pre>class Car {<br>  constructor(public make: string = \"Generic\", public model: string = \"Model\") {}<br>}<br><br>const car = new Car(\"Toyota\", \"Corolla\");<br>console.log(car.make); // Toyota</pre>\n<p>This equals to:</p>\n<pre>class Car {<br>  public make: string;<br>  public model: string;<br><br>  constructor(make: string = \"Generic\", model: string = \"Model\") {<br>    this.make = make;<br>    this.model = model;<br>  }<br>}<br><br>const car = new Car(\"Toyota\", \"Corolla\");<br>console.log(car.make); // Toyota</pre>\n<p>Instead of declaring properties and assigning them in the constructor, parameter properties allow you to do both in a single step, making your class definitions more concise.</p>\n<h4>DTV.01: Deriving Types from Variables</h4>\n<p>Deriving types from existing values or variables is a powerful feature in TypeScript, allowing you to dynamically infer types based on data structures, function signatures, and constants. Here‚Äôs a comprehensive guide on different techniques for deriving types in TypeScript.</p>\n<p>This allows for a more dynamic and type-safe approach to working with complex data structures. Let‚Äôs explore key techniques like keyof, typeof, and more.</p>\n<h4>DTV.02: The ‚Äòkeyof‚Äô Operator</h4>\n<p>The keyof operator creates a union of string literal types from the keys of an interface or object. This is particularly useful for creating flexible types.</p>\n<p>Example:</p>\n<pre>interface CarSpecs {<br>  make: string;<br>  model: string;<br>  year: number;<br>}<br><br>// carDetails will need to have the same keys as the interface<br>const carDetails: Record&lt;keyof CarSpecs, { description: string; value: string | number }&gt; = {<br>  make: { description: \"Car Make\", value: \"Toyota\" },<br>  model: { description: \"Car Model\", value: \"Corolla\" },<br>  year: { description: \"Manufacturing Year\", value: 2021 },<br>};</pre>\n<p>Here, keyof CarSpecs creates a union of \"make\" | \"model\" | \"year\", allowing carDetails to have the same keys as CarSpecs.</p>\n<h4>DTV.03: The 'typeof' Operator</h4>\n<p>The typeof operator can be used to derive types directly from variables or objects.</p>\n<p>For example:</p>\n<pre>const configurations = {<br>  development: {<br>    apiBaseUrl: 'http://localhost:8080',<br>    timeout: 5000,<br>  },<br>  production: {<br>    apiBaseUrl: 'https://api.example.com',<br>    timeout: 10000,<br>  },<br>  staging: {<br>    apiBaseUrl: 'https://staging.example.com',<br>    timeout: 8000,<br>  },<br>};<br><br>type Environment = keyof typeof configurations; // 'development' | 'production' | 'staging'</pre>\n<p>In this case, keyof typeof configurations extracts the keys ('development', 'production', 'staging') as a union type.</p>\n<h4>DTV.04: You Can Create Types from Values, but Not Values from Types</h4>\n<p>types and interfaces in TypeScript are erased at runtime, which means you can only derive types from existing values, but not the other way around. Type information doesn‚Äôt exist at runtime and only helps in static checking during development.</p>\n<h4>DTV.05: Deriving Types with Classes</h4>\n<p>Classes can be used as types directly in TypeScript. Any instance of a class can be typed as the class itself.</p>\n<p>Example:</p>\n<pre>class CarPosition {<br>  x = 0;<br>  y = 0;<br><br>  move(x: number, y: number) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}<br><br>const positionFromCar = (position: CarPosition) =&gt; {<br>  return {<br>    x: position.x,<br>    y: position.y,<br>  };<br>};</pre>\n<p>Here, CarPosition serves both as a class and a type.</p>\n<h4>DTV.06: Using the Same Name for Values and Types</h4>\n<p>You can have the same name for a type and a constant.</p>\n<p>Example:</p>\n<pre>export const Logger = {<br>  log: (message: string) =&gt; console.log(message),<br>};<br><br>export type Logger = typeof Logger;</pre>\n<p>Here, Logger refers both to a type (inferred from the constant) and the constant itself.</p>\n<h4>DTV.07: Deriving Types from Complex Function Parameters</h4>\n<p>You can derive types from function parameters using Parameters&lt;&gt;.</p>\n<p>Example:</p>\n<pre>const makeQuery = (<br>  url: string,<br>  opts?: {<br>    method?: string;<br>    headers?: {<br>      [key: string]: string;<br>    };<br>    body?: string;<br>  },<br>) =&gt; {};<br><br>type MakeQueryParameters = Parameters&lt;typeof makeQuery&gt;;</pre>\n<p>Here, MakeQueryParameters extracts the type of the parameters from makeQuery.</p>\n<h4>DTV.08: Extracting a Type from a Function‚Äôs Return Type</h4>\n<p>You can extract the return type of a function using ReturnType&lt;&gt;.</p>\n<p>Example:</p>\n<pre>const createUser = (id: string) =&gt; {<br>  return {<br>    id,<br>    name: \"John Doe\",<br>    email: \"example@email.com\",<br>  };<br>};<br><br>type User = ReturnType&lt;typeof createUser&gt;;</pre>\n<h4>DTV.09: Extracting Type from an Async Function</h4>\n<p>When working with asynchronous functions, you can use Awaited&lt;&gt; to get the <em>resolved</em> type.</p>\n<p>Example:</p>\n<pre>const fetchUser = async (id: string) =&gt; {<br>  return {<br>    id,<br>    name: \"John Doe\",<br>    email: \"example@email.com\",<br>  };<br>};<br><br>type User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;;</pre>\n<h4>DTV.10: Access Specific Values in an 'as const' Object</h4>\n<p>By using as const, you can lock an object‚Äôs values as constants, which allows you to access them more precisely.</p>\n<pre>export const carBrandType = {<br>  SEDAN: \"sedan\",<br>  SUV: \"suv\",<br>  COUPE: \"coupe\",<br>  PICKUP: \"pickup\",<br>  VAN: \"van\",<br>} as const;<br><br>type CarBrandTypeMap = typeof carBrandType; // a readonly object accesible by key<br>type Sedan = CarBrandTypeMap['SEDAN']; // 'sedan'</pre>\n<h4>DTV.11: Passing a Union to an Indexed Access Type</h4>\n<p>You can create union types by passing specific keys to an indexed access type.</p>\n<pre>// Following previous example, this type will be: \"sedan\" | \"suv\"<br>type SedanOrSuv = CarBrandTypeMap['SEDAN' | 'SUV']</pre>\n<h4>DTV.12: Extract a Union of All Values from an Object</h4>\n<p>You can guess that with the previous explanation you could get the union of all the values hardcoding each of them. But you can make your life easier by extracting all the values from an object as a union. This is usually used instead of enums.</p>\n<pre><br>// Equals too 'sedan' | 'suv' | 'coupe' | 'pickup' | 'van'<br>type CarTypes = CarBrandTypeMap[keyof typeof carBrandType];</pre>\n<h4>DTV.13: Create a Union from an as const Array</h4>\n<p>You can derive a union type from an array by using as const.</p>\n<pre>export const carBrandType = [<br>  \"sedan\",<br>  \"suv\",<br>  \"coupe\",<br>  \"pickup\",<br>  \"van\",<br>] as const;<br><br>type BrandCars = (typeof carBrandType)[number];</pre>\n<h3>Generics</h3>\n<h4>GEN.01: Basic Generic Function</h4>\n<p>A generic function allows you to define a placeholder type that can be replaced later.</p>\n<pre>function identity&lt;T&gt;(value: T): T {<br>  return value;<br>}<br><br>const num = identity(42); // T is 'number'<br>const str = identity(\"hello\"); // T is 'string'</pre>\n<h4>GEN.02: Generic Types with Arrays</h4>\n<p>Generic functions can handle arrays of any type.</p>\n<pre>function getFirstElement&lt;T&gt;(arr: T[]): T {<br>  return arr[0];<br>}<br><br>const firstNumber = getFirstElement([1, 2, 3]); // T is 'number'<br>const firstString = getFirstElement([\"a\", \"b\", \"c\"]); // T is 'string'</pre>\n<h4>GEN.03: Generic Interfaces</h4>\n<p>Use generics with interfaces to define reusable types.</p>\n<pre>interface Result&lt;T&gt; {<br>  data: T;<br>  error?: string;<br>}<br><br>const success: Result&lt;number&gt; = { data: 42 };<br>const failure: Result&lt;string&gt; = { data: \"error occurred\", error: \"404 not found\" };</pre>\n<h4>GEN.04: Generic Constraints</h4>\n<p>Sometimes you need to restrict the types that can be passed to a generic. You can do this using <strong>constraints</strong>. For example, to ensure that a type has a length property (like arrays or strings), you can add the following:</p>\n<pre>interface HasLength {<br>  length: number;<br>}<br><br>function logLength&lt;T extends HasLength&gt;(input: T): void {<br>  console.log(input.length);<br>}<br><br>logLength(\"hello\"); // OK, string has a length property<br>logLength([1, 2, 3]); // OK, array has a length property<br>// logLength(42); // Error, number has no length property</pre>\n<p>This can also be used when you want &lt;T&gt; to be limited to certain interfaces or types.</p>\n<h4>GEN.05: Using Multiple Generics</h4>\n<p>You can use multiple generics in the same function or type.</p>\n<pre>function pair&lt;A, B&gt;(first: A, second: B): [A, B] {<br>  return [first, second];<br>}<br><br>const pair1 = pair(1, \"apple\"); // A is 'number', B is 'string'<br>const pair2 = pair(true, { name: \"John\" }); // A is 'boolean', B is an object</pre>\n<h4>GEN.06: Default Generic Types</h4>\n<p>Set default generic types to simplify function calls.</p>\n<pre>function createArray&lt;T = string&gt;(length: number, value: T): T[] {<br>  return Array(length).fill(value);<br>}<br><br>const stringArray = createArray(3, \"hello\"); // T is 'string'<br>const numberArray = createArray&lt;number&gt;(3, 42); // Explicitly set T as 'number'<br>const error = createArray&lt;number&gt;('3', 42); // This will error</pre>\n<h4>GEN.07: Conditional Types with Generics</h4>\n<p>TypeScript allows you to create <strong>conditional types</strong> using generics:</p>\n<pre>type IsArray&lt;T&gt; = T extends any[] ? \"Array\" : \"NotArray\";<br><br>const check1: IsArray&lt;string[]&gt; = \"Array\"; // OK<br>const check2: IsArray&lt;number&gt; = \"NotArray\"; // OK</pre>\n<h4>GEN.08: Generic Functions with Overloads</h4>\n<p>Overloading functions happen when you declare them more than once with different implementations. No, it is not a bug, but an overload. Overloading helps you map specific definitions to specific signatures.</p>\n<pre>function formatValue&lt;T extends string | number&gt;(value: T): T extends string ? string : number;<br>function formatValue&lt;T extends string | number&gt;(value: T): string | number {<br>  if (typeof value === \"string\") {<br>    return value.toUpperCase();<br>  } else {<br>    return value.toFixed(2);<br>  }<br>}</pre>\n<h4>GEN.09: Keyof with Generics</h4>\n<p>Access dynamic properties using keyof and generics.</p>\n<pre>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br>  return obj[key];<br>}<br><br>const user = { id: 1, name: \"Alice\" };<br>const id = getProperty(user, \"id\"); // OK<br>const name = getProperty(user, \"name\"); // OK<br>// getProperty(user, \"age\"); // Error: 'age' is not a key of 'user'</pre>\n<h4>GEN.10: Deeply Immutable Structures with Generics</h4>\n<p>While TypeScript has a built-in Readonly utility type, it only applies immutability to the top level of an object. To create a deeply immutable object where all nested properties are also immutable, we need a custom recursive generic type.</p>\n<pre>type DeepReadonly&lt;T&gt; = {<br>  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];<br>};<br><br>interface User {<br>  id: number;<br>  name: string;<br>  address: {<br>    street: string;<br>    city: string;<br>  };<br>}<br>const user: DeepReadonly&lt;User&gt; = {<br>  id: 1,<br>  name: \"Alice\",<br>  address: {<br>    street: \"Main St\",<br>    city: \"Wonderland\"<br>  }<br>};<br><br>// Now, all properties and nested properties are readonly:<br>user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property<br>user.address.city = \"New City\"; // Error: Cannot assign to 'city' because it is a read-only property</pre>\n<h4>GEN.11: Mapping Over a Union of Types</h4>\n<p>You can create a type that maps a transformation over each type in a union. This is useful for mass-transforming several types at once.</p>\n<pre>type Mapped&lt;T&gt; = T extends string ? string[] : T extends number ? number[] : T;<br>type Result = Mapped&lt;string | number&gt;; // string[] | number[]</pre>\n<p>The Mapped type checks if T is a string or number and returns an array of the respective type. If T is a union, TypeScript automatically distributes the transformation over each member.</p>\n<h4>GEN.12: Conditional Properties Exclusion</h4>\n<p>This example excludes properties from a definition based on their types. Here, we remove all string properties from an interface:</p>\n<pre>type OmitByType&lt;T, U&gt; = {<br>  [K in keyof T as T[K] extends U ? never : K]: T[K];<br>};<br><br>interface Person {<br>  id: number;<br>  name: string;<br>  age: number;<br>}<br><br>type WithoutStrings = OmitByType&lt;Person, string&gt;; // { id: number; age: number; }</pre>\n<h4>GEN.13: Keep Specific Properties Based on Type</h4>\n<p>Following the previous example, this one does the same thing but opposite. Instead of omiting the matching types, this one keeps them.</p>\n<pre>type KeepByType&lt;T, U&gt; = {<br>  [K in keyof T as T[K] extends U ? K : never]: T[K];<br>};<br><br>interface Person {<br>  id: number;<br>  name: string;<br>  age: number;<br>}<br><br>type StringProps = KeepByType&lt;Person, string&gt;; // { name: string }</pre>\n<p>This is the inverse of the previous example, pulling out only the keys where the value type matches a specific type (string in this case).</p>\n<h4>GEN.14: Type-Safe Builder Pattern with Generics</h4>\n<p>Here‚Äôs a generic Builder type that allows chaining method calls and ensures type safety as you build an object step-by-step.</p>\n<pre>type Builder&lt;T&gt; = {<br>  [K in keyof T as `set${Capitalize&lt;string &amp; K&gt;}`]: (value: T[K]) =&gt; Builder&lt;Omit&lt;T, K&gt;&gt;;<br>} &amp; { build(): T };<br><br>interface Product {<br>  id: number;<br>  name: string;<br>  price: number;<br>}<br><br>const productBuilder: Builder&lt;Product&gt; = {<br>  setId: (id) =&gt; productBuilder,<br>  setName: (name) =&gt; productBuilder,<br>  setPrice: (price) =&gt; productBuilder,<br>  build: () =&gt; ({ id: 1, name: \"Laptop\", price: 1200 })<br>};</pre>\n<p>This Builder type allows method chaining for setting properties on an object while ensuring each property can only be set once. Once all properties are set, you can call build() to return the final object.</p>\n<h3>05. TypeScript in React</h3>\n<h4>REA.01: Typing Props</h4>\n<p>TypeScript allows us to enforce types on props, which makes components safer and easier to debug.</p>\n<pre>type GreetingProps = {<br>  name: string;<br>  age?: number;<br>}<br><br>const Greeting = ({ name, age }: GreetingProps): JSX.Element =&gt; (<br>  &lt;h1&gt;<br>    Hello, {name}! {age &amp;&amp; `You are ${age} years old.`}<br>  &lt;/h1&gt;<br>);<br><br>export default Greeting;</pre>\n<h4>REA.02: Typing State with useState</h4>\n<p>When initializing state, TypeScript can infer the type, but explicit types are often better for clarity.</p>\n<pre>// &lt;number&gt; is not neccesary here -TS inference-, but added for the demonstration.<br>const [count, setCount] = useState&lt;number&gt;(0);<br>const increment = () =&gt; setCount(count + 1);</pre>\n<h4>REA.03: Typing Event Handlers</h4>\n<p>Typing event handlers helps ensure proper usage of event properties within components.</p>\n<pre>const handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {<br>  console.log(event.currentTarget);<br>};<br><br>&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;</pre>\n<p>For a button click event, we use React.MouseEvent&lt;HTMLButtonElement&gt;. TypeScript provides specific types for various events, like ChangeEvent for inputs. <a href=\"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/\">Here</a> is a good source for forms.</p>\n<h4>REA.04: Typing Refs with useRef</h4>\n<p>When working with refs, explicitly typing useRef can prevent accidental null access errors.</p>\n<pre>const inputRef = useRef&lt;HTMLInputElement&gt;(null); <br><br>const focusInput = () =&gt; {<br>  if (inputRef.current) {<br>    inputRef.current.focus();<br>  }<br>};<br><br>return &lt;input ref={inputRef} type=\"text\" /&gt;;</pre>\n<h4>REA.05: Typing Context</h4>\n<p>Using TypeScript with React Context can make it easy to provide and consume context values safely.</p>\n<pre>// Define the context value type<br>type ThemeContextType = {<br>  theme: string;<br>  toggleTheme: () =&gt; void;<br>}<br><br>const ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(undefined);<br><br>const ThemeProvider = ({ children }) =&gt; {<br>  const [theme, setTheme] = useState(\"light\");<br>  const toggleTheme = () =&gt; setTheme(theme === \"light\" ? \"dark\" : \"light\");<br>  return (<br>    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;<br>      {children}<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>};</pre>\n<p>In this example, ThemeContextType is used to define the structure of the context‚Äôs value, guaranteeing all consumers handle it correctly.</p>\n<h4>REA.06: Basic Typing Redux Store (Reducers and Selectors)</h4>\n<p>When working with <a href=\"https://redux.js.org/\">Redux</a>, TypeScript is particularly useful for defining types for the store, actions, and selectors. If you are going to dig deeper I recommend you go over their docs.</p>\n<pre>type CounterState = {<br>  count: number;<br>}<br><br>const initialState: CounterState = { count: 0 };<br><br>const actionTypes = {<br>  INCREMENT: \"INCREMENT\",<br>  DECREMENT: \"DECREMENT\",<br>} as const;<br><br>type ActionType = typeof actionTypes[keyof typeof actionTypes];<br><br>type CounterActionTypes = {type: ActionType};<br><br>const counterReducer = (state = initialState, action: CounterActionTypes): CounterState =&gt; {<br>  switch (action.type) {<br>    case actionTypes.INCREMENT:<br>      return { count: state.count + 1 };<br>    case actionTypes.DECREMENT:<br>      return { count: state.count - 1 };<br>    default:<br>      return state;<br>  }<br>};</pre>\n<h4>REA.07: Typing HOCs (Higher-Order Components)</h4>\n<p>Typing higher-order components (HOCs) means you will need to type the function of the HOC itself and also the argument (another function!) so beware of the syntax.</p>\n<pre>type WithLoadingProps = {<br>  isLoading: boolean;<br>};<br><br>const withLoading = &lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) =&gt; {<br>  const LoadingComponent: React.FC&lt;P &amp; WithLoadingProps&gt; = ({ isLoading, ...otherProps }) =&gt; <br>    isLoading ? &lt;p&gt;Loading...&lt;/p&gt; : &lt;Component {...(otherProps as P)} /&gt;;<br>  return LoadingComponent;<br>};</pre>\n<h4>REA.08: Typing Custom Hooks</h4>\n<p>TypeScript can make custom hooks more reusable by defining flexible types. For example, data can be of type T or null</p>\n<pre>function useFetch&lt;T&gt;(url: string): { data: T | null; loading: boolean; error: Error | null } {<br>  const [data, setData] = useState&lt;T | null&gt;(null);<br>  const [loading, setLoading] = useState(true);<br>  const [error, setError] = useState&lt;Error | null&gt;(null);<br><br>  useEffect(() =&gt; {<br>    fetch(url)<br>      .then((response) =&gt; response.json())<br>      .then((data: T) =&gt; {<br>        setData(data);<br>        setLoading(false);<br>      })<br>      .catch((error) =&gt; {<br>        setError(error);<br>        setLoading(false);<br>      });<br>  }, [url]);<br><br>  return { data, loading, error };<br>}</pre>\n<h4>REA.09: Typing Component as a Namespace</h4>\n<p>Many libaries use a root component as a namespace (for example, Radix) and that means that the root is also a React function but also works as an object for other references. Using React.FC could be problematic for those cases. Instead, I prefer this approach:</p>\n<pre>type SelectProps = { options: string[]; onSelect: (value: string) =&gt; void };<br><br>const Select = ({ options, onSelect }: SelectProps): JSX.Element =&gt; (<br>  &lt;select onChange={(e) =&gt; onSelect(e.target.value)}&gt;<br>    {options.map((option) =&gt; (<br>      &lt;option key={option} value={option}&gt;<br>        {option}<br>      &lt;/option&gt;<br>    ))}<br>  &lt;/select&gt;<br>);<br><br>Select.Item = ({ value }: { value: string }): JSX.Element =&gt; &lt;option&gt;{value}&lt;/option&gt;;<br>Select.Root = (props: SelectProps): JSX.Element =&gt; &lt;Select {...props} /&gt;;<br><br>export default Select;</pre>\n<h4>REA.10: Typing RenderProps</h4>\n<p>When you use a component as a prop, you can type it this way. For example:</p>\n<pre>type RenderProps = {<br>  children: (isLoading: boolean) =&gt; JSX.Element;<br>};<br><br>const Loader = ({ children }: RenderProps): JSX.Element =&gt; {<br>  const [isLoading, setIsLoading] = useState(true);<br>  useEffect(() =&gt; {<br>    const timer = setTimeout(() =&gt; setIsLoading(false), 2000);<br>    return () =&gt; clearTimeout(timer);<br>  }, []);<br>  return children(isLoading);<br>};</pre>\n<h4>REA.11: Typing a Hook with Generics</h4>\n<p>When using generics you need to add a comma , after T so it doesn‚Äôt get confused with JSX syntax.</p>\n<pre>const useArray = &lt;T,&gt;(initialValue: T[]): {array: T[], addItem: (item: T) =&gt; void} =&gt; {<br>  const [array, setArray] = useState&lt;T[]&gt;(initialValue);<br>  const addItem = (item: T) =&gt; setArray((arr) =&gt; [...arr, item]);<br>  return {array, addItem};<br>};</pre>\n<h4>REA.12: Component Composition with Generics</h4>\n<p>Taking advantage of using T for generic types, we can create really versatile componets that render any kind of list. For example:</p>\n<pre>type ListProps&lt;T&gt; = {<br>  items: T[];<br>  renderItem: (item: T) =&gt; JSX.Element;<br>};<br><br>const List = &lt;T,&gt;({ items, renderItem }: ListProps&lt;T&gt;): JSX.Element =&gt; (<br>  &lt;div&gt;{items.map(renderItem)}&lt;/div&gt;<br>);</pre>\n<h4>REA.13: Typing Compound Components with Context and Generics</h4>\n<p>Since types can be defined using generics too, we can pass the generic down to any of our props.</p>\n<pre>type TabContextType&lt;T&gt; = {<br>  activeTab: T;<br>  setActiveTab: React.Dispatch&lt;React.SetStateAction&lt;T&gt;&gt;;<br>};<br><br>const TabContext = React.createContext&lt;TabContextType&lt;string&gt; | undefined&gt;(undefined);<br>const TabProvider = ({ children }: { children: React.ReactNode }) =&gt; {<br>  const [activeTab, setActiveTab] = useState(\"home\");<br>  return (<br>    &lt;TabContext.Provider value={{ activeTab, setActiveTab }}&gt;<br>      {children}<br>    &lt;/TabContext.Provider&gt;<br>  );<br>};</pre>\n<h3>06. The Weird Parts of TypeScript, Common Pitfalls</h3>\n<h4>TWPTS.01: Accept Anything Except Null or Undefined</h4>\n<p>In TypeScript, you can create types that exclude null or undefined. For example:</p>\n<pre>type NonNullish&lt;T&gt; = T extends null | undefined ? never : T;<br>const acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};</pre>\n<p>Interestingly, you can simplify this by using an empty object type instead:</p>\n<pre>type NonNullish&lt;T&gt; = {}; // NonNulish represents the same type as before<br>const acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};</pre>\n<p>This works because unknown in TypeScript is defined as:</p>\n<pre>type unknown = {} | undefined | null;</pre>\n<h4>TWPTS.02: Typing a Truly Empty Object</h4>\n<p>Defining an empty object is tricky. You can use Record&lt;PropertyKey, never&gt; to enforce no properties:</p>\n<pre>const acceptOnlyEmptyObject = (input: Record&lt;PropertyKey, never&gt;) =&gt; {};</pre>\n<p>However, a more foolproof approach uses a unique symbol:</p>\n<pre>declare const tag: unique symbol;<br>type EmptyObject = { [tag]?: never };</pre>\n<p>This ensures no properties are allowed, effectively representing a truly empty object.</p>\n<h4>TWPTS.03: Techniques for Triggering Excess Property Warnings</h4>\n<p>TypeScript‚Äôs assignability model is based on satisfying contracts, not exact matches. Excess property checks are only triggered under specific conditions, like inline object literals.</p>\n<p>Here are a few techniques for forcing excess property checks:</p>\n<p><strong>Add a Type Annotation</strong>:</p>\n<pre>type User = {<br> id: number;<br> name: string;<br>}<br><br>// Error for 'age', since it is not part of the type<br>const obj: User = { id: 1, name: \"John\", age: 30 };</pre>\n<p><strong>Use the </strong><strong>satisfies Keyword</strong>:</p>\n<p>Without it, just creating the object and then passing it down to a function that demands a user type would work just fine. But, if you want to strictly enforce the same signature, use satisfies.</p>\n<pre>const obj = { id: 1, name: \"John\", age: 30 } satisfies User;</pre>\n<p><strong>Inline the Variable</strong>:</p>\n<pre>//printUser requires a User type<br>printUser({ id: 1, name: \"John\", age: 30 }); // Error for 'age'</pre>\n<h4>TWPTS.04: Accessing Object Properties Using Keys</h4>\n<p>If you‚Äôre iterating through object keys and want to ensure type safety, you can cast the key to a keyof the object type.</p>\n<pre>interface User {<br>  id: number;<br>  name: string;<br>}<br><br>function printUser(user: User) {<br>  for (const keyProperty in user) {<br>    console.log(user[keyProperty as keyof User]);<br>  }<br>}</pre>\n<h4>TWPTS.05: Typing Callbacks with Varying Parameters</h4>\n<p>If you need a function type that can accept various argument lengths, you can define a flexible callback type:</p>\n<pre>type CallbackType = (<br>  event: Event,<br>  x?: number,<br>  y?: number,<br>  screenId?: number<br>) =&gt; void;<br><br>function listenToEvent(callback: CallbackType) {<br>  // callback logic<br>}</pre>\n<p>This allows the following calls:</p>\n<pre>listenToEvent(() =&gt; {});<br>listenToEvent((event) =&gt; {});<br>listenToEvent((event, x, y) =&gt; {});<br>listenToEvent((event, x, y, screenId) =&gt; {});</pre>\n<p>Just remember to narrow down the types inside the function to make it work properly.</p>\n<h4>TWPTS.06: Correctly Typing Functions that Handle Multiple Types</h4>\n<p>Consider a scenario where you have an object containing functions that handle different types. You want to dynamically call the correct function based on the input type:</p>\n<pre>const objOfFunctions = {<br>  string: (input: string) =&gt; input.toUpperCase(),<br>  number: (input: number) =&gt; input.toFixed(2),<br>  boolean: (input: boolean) =&gt; (input ? \"true\" : \"false\"),<br>};<br><br>type ObjKeys = string | number | boolean;<br>const format = (input: ObjKeys) =&gt; {<br>  const inputType = input as keyof typeof objOfFunctions;<br>  const formatter = objOfFunctions[inputType];<br><br>  return formatter(input as never); // 'as never' to force correct typing<br>};</pre>\n<h4>CPTF.01: Forgetting Non-null Assertion in Nested Structures</h4>\n<p>Accessing properties on nested objects without ensuring their existence can cause runtime errors.</p>\n<pre>type Engine = { type: string };<br>type Car = { engine?: Engine };<br><br>function getEngineType(car: Car): string {<br>  return car.engine.type || \"\"; // Error: Object is possibly 'undefined'<br>}</pre>\n<p>The property engine is optional in Car, and TypeScript warns that type might not exist. Use optional chaining (car.engine?.type) to prevent this error.</p>\n<h4>CPTF.02: Not Handling Readonly Array Types Correctly</h4>\n<p>Using readonly with arrays incorrectly can lead to unexpected mutations.</p>\n<pre>const numbers: readonly number[] = [1, 2, 3];<br>numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'</pre>\n<p>By default readonly arrays prevent mutation. Trying to mutate (e.g., push) will cause an error. To fix it, copy the array first if modifications are needed (const newNumbers = [...numbers, 4]).</p>\n<h4>CPTF.03: Promise&lt;void&gt; Usage</h4>\n<p>Returning Promise&lt;void&gt; can lead to issues if callers assume the promise is resolved with data.</p>\n<pre>async function fetchData(): Promise&lt;void&gt; {<br>  const data = await fetch(\"https://api.example.com/data\");<br>  return data; // Error: Type 'Response' is not assignable to type 'void'<br>}</pre>\n<h4>CPTF.04: Overlapping Types with Union and Intersection</h4>\n<p>Using unions and intersections together can lead to unintentional overlap in types.</p>\n<pre>type Bird = { wings: 2; fly: () =&gt; void };<br>type Fish = { fins: 2; swim: () =&gt; void };<br>type Animal = Bird | Fish;<br><br>function move(animal: Animal) {<br>  if (\"swim\" in animal) {<br>    animal.swim(); // Works for Fish<br>  } else {<br>    animal.fly(); // Error: Property 'fl' does not exist on type 'Bird | Fish'<br>  }<br>}</pre>\n<p>Solution:</p>\n<pre>type Bird = { wings: 2; fly: () =&gt; void };<br>type Fish = { fins: 2; swim: () =&gt; void };<br><br>type Animal = Bird | Fish;<br><br>function isFish(animal: Animal): animal is Fish {<br>  return \"swim\" in animal;<br>}<br><br>function move(animal: Animal) {<br>  if (isFish(animal)) {<br>    animal.swim(); // Now TypeScript knows this is a Fish<br>  } else {<br>    animal.fly(); // TypeScript knows this is a Bird<br>  }<br>}</pre>\n<p>TypeScript can‚Äôt infer the common structure of Bird | Fish without further guards. Using custom type guards (e.g., function isFish(animal: Animal): animal is Fish) helps ensure correct property access.</p>\n<h4>CPTF.05: Forgetting readonly for Constants</h4>\n<p>Not using readonly on constants can lead to accidental mutation. In the following example adding readonly to speed would prevent unwanted modifications.</p>\n<pre>class Car {<br>  public speed = 100; // speed should be readonly for this car<br>  accelerate() {<br>    this.speed += 10; // Modifies speed unexpectedly<br>  }<br>}<br><br>const myCar = new Car();<br>myCar.speed = 50; // Mistakenly changes speed</pre>\n<h4>CPTF.06: Overusing Type Assertions</h4>\n<p>Overusing as assertions can lead to ignored type errors. Type assertions (as) bypass type checks, leading to runtime errors if not used wisely. Sometimes they are necessary, but most of the time type guards (if checks) provide safer validation.</p>\n<pre>function getCarName(car: unknown): string {<br>  return (car as { name: string }).name; // Unsafe assumption that `car` has `name` property<br>}<br><br>console.log(getCarName({ brand: \"Toyota\" })); // Error: Cannot read property 'name'</pre>\n<p>A better alternative:</p>\n<pre>function getCarName(car: unknown): string {<br>  if (isCarWithName(car)) {<br>    return car.name; // Safe access, as the type is validated<br>  }<br>  throw new Error(\"Invalid car object: 'name' property is missing\");<br>}<br><br>function isCarWithName(car: unknown): car is { name: string } {<br>  return typeof car === \"object\" &amp;&amp; car !== null &amp;&amp; \"name\" in car &amp;&amp; typeof (car as any).name === \"string\";<br>}<br><br>console.log(getCarName({ name: \"Toyota\" })); // Output: \"Toyota\"<br>console.log(getCarName({ brand: \"Toyota\" })); // Throws error: Invalid car object</pre>\n<h4>CPTF.07: Ignoring Optional Properties</h4>\n<p>Optional properties are often missed in destructuring or direct access.</p>\n<pre>type Car = { make: string; model?: string };<br><br>function getModel(car: Car) {<br>  return car.model.toUpperCase(); // Error: Object is possibly 'undefined'<br>}</pre>\n<p>The property model is optional, so accessing it directly without checking leads to errors. Using optional chaining (car.model?.toUpperCase()) would prevent this.</p>\n<h4>CPTF.08: Incorrect Use of Generic Constraints</h4>\n<p>Setting incorrect generic constraints can lead to unexpected type limitations.</p>\n<pre>function merge&lt;T extends string, U extends number&gt;(a: T, b: U): string {<br>  return a + b;<br>}<br><br>merge(\"Engine\", 1); // Works fine<br>merge(123, 456); // Error: Argument of type 'number' is not assignable to parameter of type 'string'</pre>\n<p>By limiting T to string and U to number, merge becomes too restrictive. Using a broader generic constraint (e.g., T, U) would allow more flexibility.</p>\n<p>A way to solve it would be too change its signature (or modify the function):</p>\n<pre>function merge&lt;T extends string, U extends number&gt;(a: T, b: U): string | number {<br>  return a + b;<br>}</pre>\n<h3>Closing Thoughts</h3>\n<p>By now, you‚Äôve likely absorbed a lot of information, and I can‚Äôt blame you if your brain feels a little fried‚Ää‚Äî‚Äämine certainly did halfway through writing this.</p>\n<p>While I believe this guide provides a solid foundation to get you started, it‚Äôs important to note that some topics‚Ää‚Äî‚Ääparticularly when it comes to setting up TypeScript or getting into advanced generics‚Ää‚Äî‚Äähaven‚Äôt been fully covered here.</p>\n<p>Think of this guide as a springboard, but don‚Äôt stop here. There‚Äôs much more to explore as you continue to deepen your understanding.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce6844f008ad\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad\">Learn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "react",
        "typescript",
        "web-development",
        "programming",
        "javascript"
      ]
    },
    {
      "title": "Building Features in React the Right Way: A Scalable Solution Case Study",
      "pubDate": "2024-12-03 18:44:28",
      "link": "https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/b95a77853701",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<p><em>Exploring how thoughtful refactoring and design principles can simplify complex user flows and future-proof your codebase.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*X_ML5Wfh7-QdlFAL4LmLCQ.jpeg\"><figcaption>React on top of an AI generated map ‚Äîwith cars that drive on water.</figcaption></figure><h3>Introduction</h3>\n<p>I was recently tasked with extending the capabilities of ‚Äú<strong>The move users to different groups</strong>‚Äù feature. We currently have 4 different kinds of groups were users can be assigned:</p>\n<ul>\n<li>\n<strong>Recurring (A)</strong>: Where users receive the same budget each month independently ‚Äîno possibility to ‚Äúdrag‚Äù previous‚Äô months budgets</li>\n<li>\n<strong>Event (B)</strong>: A group with date limitations</li>\n<li>\n<strong>Lean Event (C):</strong> A subcategory of Event, where it has less configuration options.</li>\n<li>\n<strong>Rolling (D)</strong>: The unused budget from previous months is allocated to the new month (accumulative).</li>\n</ul>\n<p>As you see, four different groups with different options.</p>\n<p>Due to system limitations, the platform only allowed to move users from groups A, B and C between them, while users from group D could only be moved to another D group. If I needed to represent it with some AI image creator on a budget and some rusted Photoshop skills, it would look something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/788/1*C5F1X6hHO9BFRdF1sWOr3Q.jpeg\"><figcaption>ABC can move users between them, D is a different case.</figcaption></figure><p>As you can infer, there were two different kinds of moves. Between non ‚ÄúD‚Äù groups, and the rest. Code wise, it looked something like this:</p>\n<pre>if (targetGroupType === typeD){<br>  handleMoveUsersToGroupD() // the special case<br>} else {<br>  handleMoveBetweenGroupsABC()<br>}</pre>\n<p>This code lived beautifully for as long as it needed to until the infrastructure to handle move between any of the combinations was ready.</p>\n<p>As you can guess, the time had come, and that is the reason I am writing this article.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Understanding the Real Requirements</h3>\n<p>The Product team provided me the new flows:</p>\n<ul>\n<li>A new flow for moveFromABCtoD</li>\n<li>A new flow for moveFromDtoABC</li>\n<li>A refreshed flow for moveBetweenGroupsD</li>\n<li>Lastly, moveBetweenABC should remain the same.</li>\n</ul>\n<p>As you can see, all the relationships are based on whether the origin or target includes the D group.</p>\n<p>Each of them would trigger a different sequence of modals, with varying API calls and all the bells and whistles. So, it looks like four flows, right?</p>\n<p>Yes‚Ä¶<strong> four flows but for 16 different cases</strong>. As you can see, just because ABC shares the same flow today doesn‚Äôt mean it will tomorrow. After all, they are different types for a reason.</p>\n<p>If today I have 16 flows, that 4 of them are repetitive, I can say that a) I am lucky, b) that doesn‚Äôt mean that tomorrow it won‚Äôt change. Putting that into another AI image on a budget, my 4 groups on each interaction with another one would form a grid like this one:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/455/1*OfEEFoocMcToFeQsfk3DVA.jpeg\"><figcaption>Don‚Äôt ask me why the AI tool choose to use squares that hold squares</figcaption></figure><p>While these four cases represent all the possibilities <strong>today</strong>, I aimed to design it so that it allows for <strong>easy adaptation if requirements change in the future</strong>. As <a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\">Uncle Bob</a> would say,<em> open for extension, but closed for modification.</em> Because tomorrow, I could be dealing with this one:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/1*N9Jcg6D_j-TepaRU6OhVZA.jpeg\"><figcaption>Looks like a nice apartment building, doesn‚Äôt it?</figcaption></figure><h3>Implementing a more scalable solution</h3>\n<p>So instead of using four if statements, we could represent all the scenarios in a 2D matrix, where each index corresponds to a group type, and at the correct array location, assign the appropriate move function.</p>\n<pre>// Move flows<br>const moveBetweenABC = () =&gt; console.log('Move between groups A, B, C');<br>const moveFromABCtoD = () =&gt; console.log('Move from ABC to group D');<br>const moveFromDtoABC = () =&gt; console.log('Move from group D to ABC');<br>const moveBetweenGroupsD = () =&gt; console.log('Move between group D');<br><br>// Group name to index mapping<br>const groupIndexes = {<br>  Recurring: 0, // Group A<br>  Event: 1,     // Group B<br>  LeanEvent: 2, // Group C<br>  Rolling: 3    // Group D<br>};<br><br>// Matrix representation of group moves<br>// Rows: Source Group (Recurring, Event, LeanEvent, Rolling)<br>// Columns: Target Group (Recurring, Event, LeanEvent, Rolling)<br>const moveMatrix = [<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Recurring (A)<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Event (B)<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From LeanEvent (C)<br>  [moveFromDtoABC, moveFromDtoABC, moveFromDtoABC, moveBetweenGroupsD]  // From Rolling (D)<br>];<br><br>// Example: Moving from Recurring (A) to Rolling (D)<br>moveMatrix[groupIndexes.Recurring][groupIndexes.Rolling](); // Output: \"Move from ABC to group D\"<br><br>// Example: Moving from Rolling (D) to Event (B)<br>moveMatrix[groupIndexes.Rolling][groupIndexes.Event](); // Output: \"Move from group D to ABC\"</pre>\n<p>However, while this solution is scalable and has an O(1) complexity, it can be somewhat difficult to read and maintain. And since me and my coworkers are all human, we need to read the code at ease.</p>\n<h3>A second approach: A mapping strategy</h3>\n<p>To tackle the problems mentioned with the matrix, I decided to declare a map; where each key is a combination of the origin group type and the destination group type, separated by a dot:</p>\n<pre>// Define the move functions for the different flows<br>const moveBetweenABC = () =&gt; console.log('Move between Recurring, Event, and LeanEvent groups');<br>const moveFromABCtoRolling = () =&gt; console.log('Move from Recurring, Event, or LeanEvent to Rolling');<br>const moveFromRollingtoABC = () =&gt; console.log('Move from Rolling to Recurring, Event, or LeanEvent');<br>const moveBetweenRolling = () =&gt; console.log('Move between Rolling groups');<br><br>// Group names<br>const groups = {<br>  Recurring: 'Recurring',<br>  Event: 'Event',<br>  LeanEvent: 'LeanEvent',<br>  Rolling: 'Rolling'<br>};<br><br>// Map of move functions where key is 'originGroup.targetGroup'<br>const moveMap = {<br>  'Recurring.Recurring': moveBetweenABC,<br>  'Recurring.Event': moveBetweenABC,<br>  'Recurring.LeanEvent': moveBetweenABC,<br>  'Recurring.Rolling': moveFromABCtoRolling,<br><br>  'Event.Recurring': moveBetweenABC,<br>  'Event.Event': moveBetweenABC,<br>  'Event.LeanEvent': moveBetweenABC,<br>  'Event.Rolling': moveFromABCtoRolling,<br><br>  'LeanEvent.Recurring': moveBetweenABC,<br>  'LeanEvent.Event': moveBetweenABC,<br>  'LeanEvent.LeanEvent': moveBetweenABC,<br>  'LeanEvent.Rolling': moveFromABCtoRolling,<br><br>  'Rolling.Recurring': moveFromRollingtoABC,<br>  'Rolling.Event': moveFromRollingtoABC,<br>  'Rolling.LeanEvent': moveFromRollingtoABC,<br>  'Rolling.Rolling': moveBetweenRolling<br>};<br><br>// Example: Moving from Recurring to Rolling<br>moveMap[`${groups.Recurring}.${groups.Rolling}`](); // Output: \"Move from Recurring, Event, or LeanEvent to Rolling\"<br><br>// Example: Moving from Rolling to Event<br>moveMap[`${groups.Rolling}.${groups.Event}`](); // Output: \"Move from Rolling to Recurring, Event, or LeanEvent\"</pre>\n<p>With this pattern (thanks Redis for the idea), I can manage future requirements easily without needing to alter existing code. By defining moves through a mapping structure, I ensure clarity and scalability, making it easier to add or modify flows without disrupting the underlying logic.</p>\n<p>This approach not only adheres to the Open/Closed Principle advocated by Uncle Bob but also enhances maintainability, allowing other developers to quickly grasp the relationships between different group types.</p>\n<p>Moreover, this solution minimises the risk of bugs introduced by additional if statements, creating a more robust and reliable codebase.</p>\n<h3>My Takeaway</h3>\n<p>Just as understanding user requirements is crucial for developing scalable solutions, developers must also grasp product requirements and translate them into appropriate data structures and design patterns. This skill develops over time.</p>\n<p>As a developer, your goal should be to make your code easily comprehensible for your coworkers at first glance, eliminating the need for them to delve deeper to understand the logic. In addition, you and your code must be prepared for unplanned changes that the Product team may request in the future.</p>\n<p>This mindset‚Ää‚Äî‚Ääcombining a structured approach to current problems with flexibility for potential changes‚Ää‚Äî‚Ääultimately distinguishes valuable code from subpar implementations and<strong> </strong>a senior developer from a junior one.</p>\n<h3>Conclusion</h3>\n<p>Implementing a <strong>mapping strategy</strong> to handle complex scenarios like user group movement provides a cleaner, more adaptable solution than using logical blocks that can evolve with changing requirements or unreadable matrixes.</p>\n<p>This case study highlights the importance of writing code that not only solves current problems but is also prepared for future challenges, ensuring that our applications remain agile and maintainable over time.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b95a77853701\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701\">Building Features in React the Right Way: A Scalable Solution Case Study</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<p><em>Exploring how thoughtful refactoring and design principles can simplify complex user flows and future-proof your codebase.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*X_ML5Wfh7-QdlFAL4LmLCQ.jpeg\"><figcaption>React on top of an AI generated map ‚Äîwith cars that drive on water.</figcaption></figure><h3>Introduction</h3>\n<p>I was recently tasked with extending the capabilities of ‚Äú<strong>The move users to different groups</strong>‚Äù feature. We currently have 4 different kinds of groups were users can be assigned:</p>\n<ul>\n<li>\n<strong>Recurring (A)</strong>: Where users receive the same budget each month independently ‚Äîno possibility to ‚Äúdrag‚Äù previous‚Äô months budgets</li>\n<li>\n<strong>Event (B)</strong>: A group with date limitations</li>\n<li>\n<strong>Lean Event (C):</strong> A subcategory of Event, where it has less configuration options.</li>\n<li>\n<strong>Rolling (D)</strong>: The unused budget from previous months is allocated to the new month (accumulative).</li>\n</ul>\n<p>As you see, four different groups with different options.</p>\n<p>Due to system limitations, the platform only allowed to move users from groups A, B and C between them, while users from group D could only be moved to another D group. If I needed to represent it with some AI image creator on a budget and some rusted Photoshop skills, it would look something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/788/1*C5F1X6hHO9BFRdF1sWOr3Q.jpeg\"><figcaption>ABC can move users between them, D is a different case.</figcaption></figure><p>As you can infer, there were two different kinds of moves. Between non ‚ÄúD‚Äù groups, and the rest. Code wise, it looked something like this:</p>\n<pre>if (targetGroupType === typeD){<br>  handleMoveUsersToGroupD() // the special case<br>} else {<br>  handleMoveBetweenGroupsABC()<br>}</pre>\n<p>This code lived beautifully for as long as it needed to until the infrastructure to handle move between any of the combinations was ready.</p>\n<p>As you can guess, the time had come, and that is the reason I am writing this article.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Understanding the Real Requirements</h3>\n<p>The Product team provided me the new flows:</p>\n<ul>\n<li>A new flow for moveFromABCtoD</li>\n<li>A new flow for moveFromDtoABC</li>\n<li>A refreshed flow for moveBetweenGroupsD</li>\n<li>Lastly, moveBetweenABC should remain the same.</li>\n</ul>\n<p>As you can see, all the relationships are based on whether the origin or target includes the D group.</p>\n<p>Each of them would trigger a different sequence of modals, with varying API calls and all the bells and whistles. So, it looks like four flows, right?</p>\n<p>Yes‚Ä¶<strong> four flows but for 16 different cases</strong>. As you can see, just because ABC shares the same flow today doesn‚Äôt mean it will tomorrow. After all, they are different types for a reason.</p>\n<p>If today I have 16 flows, that 4 of them are repetitive, I can say that a) I am lucky, b) that doesn‚Äôt mean that tomorrow it won‚Äôt change. Putting that into another AI image on a budget, my 4 groups on each interaction with another one would form a grid like this one:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/455/1*OfEEFoocMcToFeQsfk3DVA.jpeg\"><figcaption>Don‚Äôt ask me why the AI tool choose to use squares that hold squares</figcaption></figure><p>While these four cases represent all the possibilities <strong>today</strong>, I aimed to design it so that it allows for <strong>easy adaptation if requirements change in the future</strong>. As <a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\">Uncle Bob</a> would say,<em> open for extension, but closed for modification.</em> Because tomorrow, I could be dealing with this one:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/1*N9Jcg6D_j-TepaRU6OhVZA.jpeg\"><figcaption>Looks like a nice apartment building, doesn‚Äôt it?</figcaption></figure><h3>Implementing a more scalable solution</h3>\n<p>So instead of using four if statements, we could represent all the scenarios in a 2D matrix, where each index corresponds to a group type, and at the correct array location, assign the appropriate move function.</p>\n<pre>// Move flows<br>const moveBetweenABC = () =&gt; console.log('Move between groups A, B, C');<br>const moveFromABCtoD = () =&gt; console.log('Move from ABC to group D');<br>const moveFromDtoABC = () =&gt; console.log('Move from group D to ABC');<br>const moveBetweenGroupsD = () =&gt; console.log('Move between group D');<br><br>// Group name to index mapping<br>const groupIndexes = {<br>  Recurring: 0, // Group A<br>  Event: 1,     // Group B<br>  LeanEvent: 2, // Group C<br>  Rolling: 3    // Group D<br>};<br><br>// Matrix representation of group moves<br>// Rows: Source Group (Recurring, Event, LeanEvent, Rolling)<br>// Columns: Target Group (Recurring, Event, LeanEvent, Rolling)<br>const moveMatrix = [<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Recurring (A)<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Event (B)<br>  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From LeanEvent (C)<br>  [moveFromDtoABC, moveFromDtoABC, moveFromDtoABC, moveBetweenGroupsD]  // From Rolling (D)<br>];<br><br>// Example: Moving from Recurring (A) to Rolling (D)<br>moveMatrix[groupIndexes.Recurring][groupIndexes.Rolling](); // Output: \"Move from ABC to group D\"<br><br>// Example: Moving from Rolling (D) to Event (B)<br>moveMatrix[groupIndexes.Rolling][groupIndexes.Event](); // Output: \"Move from group D to ABC\"</pre>\n<p>However, while this solution is scalable and has an O(1) complexity, it can be somewhat difficult to read and maintain. And since me and my coworkers are all human, we need to read the code at ease.</p>\n<h3>A second approach: A mapping strategy</h3>\n<p>To tackle the problems mentioned with the matrix, I decided to declare a map; where each key is a combination of the origin group type and the destination group type, separated by a dot:</p>\n<pre>// Define the move functions for the different flows<br>const moveBetweenABC = () =&gt; console.log('Move between Recurring, Event, and LeanEvent groups');<br>const moveFromABCtoRolling = () =&gt; console.log('Move from Recurring, Event, or LeanEvent to Rolling');<br>const moveFromRollingtoABC = () =&gt; console.log('Move from Rolling to Recurring, Event, or LeanEvent');<br>const moveBetweenRolling = () =&gt; console.log('Move between Rolling groups');<br><br>// Group names<br>const groups = {<br>  Recurring: 'Recurring',<br>  Event: 'Event',<br>  LeanEvent: 'LeanEvent',<br>  Rolling: 'Rolling'<br>};<br><br>// Map of move functions where key is 'originGroup.targetGroup'<br>const moveMap = {<br>  'Recurring.Recurring': moveBetweenABC,<br>  'Recurring.Event': moveBetweenABC,<br>  'Recurring.LeanEvent': moveBetweenABC,<br>  'Recurring.Rolling': moveFromABCtoRolling,<br><br>  'Event.Recurring': moveBetweenABC,<br>  'Event.Event': moveBetweenABC,<br>  'Event.LeanEvent': moveBetweenABC,<br>  'Event.Rolling': moveFromABCtoRolling,<br><br>  'LeanEvent.Recurring': moveBetweenABC,<br>  'LeanEvent.Event': moveBetweenABC,<br>  'LeanEvent.LeanEvent': moveBetweenABC,<br>  'LeanEvent.Rolling': moveFromABCtoRolling,<br><br>  'Rolling.Recurring': moveFromRollingtoABC,<br>  'Rolling.Event': moveFromRollingtoABC,<br>  'Rolling.LeanEvent': moveFromRollingtoABC,<br>  'Rolling.Rolling': moveBetweenRolling<br>};<br><br>// Example: Moving from Recurring to Rolling<br>moveMap[`${groups.Recurring}.${groups.Rolling}`](); // Output: \"Move from Recurring, Event, or LeanEvent to Rolling\"<br><br>// Example: Moving from Rolling to Event<br>moveMap[`${groups.Rolling}.${groups.Event}`](); // Output: \"Move from Rolling to Recurring, Event, or LeanEvent\"</pre>\n<p>With this pattern (thanks Redis for the idea), I can manage future requirements easily without needing to alter existing code. By defining moves through a mapping structure, I ensure clarity and scalability, making it easier to add or modify flows without disrupting the underlying logic.</p>\n<p>This approach not only adheres to the Open/Closed Principle advocated by Uncle Bob but also enhances maintainability, allowing other developers to quickly grasp the relationships between different group types.</p>\n<p>Moreover, this solution minimises the risk of bugs introduced by additional if statements, creating a more robust and reliable codebase.</p>\n<h3>My Takeaway</h3>\n<p>Just as understanding user requirements is crucial for developing scalable solutions, developers must also grasp product requirements and translate them into appropriate data structures and design patterns. This skill develops over time.</p>\n<p>As a developer, your goal should be to make your code easily comprehensible for your coworkers at first glance, eliminating the need for them to delve deeper to understand the logic. In addition, you and your code must be prepared for unplanned changes that the Product team may request in the future.</p>\n<p>This mindset‚Ää‚Äî‚Ääcombining a structured approach to current problems with flexibility for potential changes‚Ää‚Äî‚Ääultimately distinguishes valuable code from subpar implementations and<strong> </strong>a senior developer from a junior one.</p>\n<h3>Conclusion</h3>\n<p>Implementing a <strong>mapping strategy</strong> to handle complex scenarios like user group movement provides a cleaner, more adaptable solution than using logical blocks that can evolve with changing requirements or unreadable matrixes.</p>\n<p>This case study highlights the importance of writing code that not only solves current problems but is also prepared for future challenges, ensuring that our applications remain agile and maintainable over time.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b95a77853701\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701\">Building Features in React the Right Way: A Scalable Solution Case Study</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "user-experience",
        "data-structures",
        "software-development",
        "javascript",
        "react"
      ]
    },
    {
      "title": "Why Years of Experience Don‚Äôt Matter‚Ää‚Äî‚ÄäHow to Keep Your Skills Relevant in Tech",
      "pubDate": "2024-11-14 21:23:29",
      "link": "https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/9dbb2dc4e86e",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<h3><strong>Why Years of Experience Don‚Äôt Matter‚Ää‚Äî‚ÄäHow to Keep Your Skills Relevant in Tech</strong></h3>\n<p>It‚Äôs what you do with your time that counts</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/1*DTIQzOjSInEacHW5O2yPtg.jpeg\"></figure><h3>Introduction</h3>\n<p>Not long ago, I had a bit of a reality check. Seeing developers with seven or eight years of experience, people you‚Äôd expect to bring a certain polish, writing code that felt like it was fresh out of a beginner‚Äôs workshop surprised me.</p>\n<p>Now, don‚Äôt get me wrong‚Äîthere is nothing wrong with beginner code. But there‚Äôs a certain head-tilt moment when you see a ‚Äúsenior‚Äù engineer that seems to struggle with the basics or deliver code that‚Äôs barely holding together.</p>\n<p>Everyone progresses at their own pace, of course. But experiences like these raise the question: <strong>how much do ‚Äúyears of experience‚Äù really mean in our field</strong>?</p>\n<h3>When YOE Just Means ‚ÄúYears of Exposure‚Äù</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*PV99t1DCMPVBXY7M\"><figcaption>Photo by <a href=\"https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral\">NordWood Themes</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>I‚Äôm not a fan of measuring experience solely by years. Adding years to your career takes no effort at all. If that were our only measure, we‚Äôd always hire the oldest person‚Ää‚Äî‚Ääyet we know experience is about more than just time.</p>\n<p>Plenty of devs rack up years in the industry but seem to forget that <strong>feedback and growth are actually part of the job.</strong></p>\n<p>The result? A version of ‚Äúexperience‚Äù that‚Äôs like watching the same TV episode over and over‚Ää‚Äî‚Ääfamiliar, but not exactly enlightening. They‚Äôll say they‚Äôve got a decade in tech, but‚Ä¶ have they really <em>done</em> anything with it?</p>\n<p>That is what I call <strong>‚Äú1 year of experience‚Äù on repeat</strong>. The ‚ÄúYOE‚Äù acronym for ‚Äúyears of experience‚Äù shifts to ‚Äúyears of exposure‚Äù.</p>\n<p><strong>I had a dose of this myself. </strong>I started my career writing code that wasn‚Äôt always destined to see the light of day‚Ää‚Äî‚Äämore like code meant to teach concepts, not get into production in real-world applications. Then I moved to a bigger company, and bam‚Ää‚Äî‚Ääreality check.</p>\n<p>My new lead‚Äôs face said it all when I fumbled through cross-team communication and realized I had a bit to learn about scalable code. I will always be thankful for that shock therapy I received.</p>\n<p>Suddenly, I was in a bigger pond where people treat code quality like it actually matters. (Who knew?)</p>\n<h3>How good are you?</h3>\n<p>The real question isn‚Äôt how good you are‚Ää‚Äî‚Ääit‚Äôs <strong>how consistently you improve.</strong> It‚Äôs easy to get stuck on comparing your abilities to others, but that won‚Äôt help you grow.</p>\n<p>If you‚Äôre not actively seeking out challenges that push you to level up, you‚Äôre probably missing out on some key growth opportunities.</p>\n<p>Perhaps there‚Äôs a certification you‚Äôve been considering, not because it‚Äôs necessary, but because it will push you to dive deeper into a subject you might have overlooked. Or perhaps you enjoy the challenge of occasional interviews, putting yourself in situations that force you to raise your game.</p>\n<p>There are a thousand ways to improve. You choose your path.</p>\n<p>But, if you don‚Äôt know where to start, here are some ideas below.</p>\n<h3>Practical Tips for Staying Relevant</h3>\n<ol>\n<li>\n<strong>Learn from Different Sources</strong>: It‚Äôs not just about ‚Äúgrinding LeetCode.‚Äù Besides books like <em>Clean Code</em> or <em>Effective Java</em> that keep your problem-solving skills sharp, you can also read less technical books (not all coding books are boring!), like <em>The Pragmatic Programmer</em>, or even novels like <em>The Phoenix Project</em>. After all, writing code is just <em>a part</em> of our job.</li>\n<li>\n<strong>Expand Your Scope</strong>: It‚Äôs great to be the go-to JavaScript person, but if you never venture beyond what‚Äôs comfortable, you‚Äôll stagnate. Learn new tools, take on different responsibilities, and expand your scope to product and business if you want to grow beyond just technical depth.</li>\n<li>\n<strong>Seek Feedback and Stay Humble</strong>: People who take feedback well are rare‚Ää‚Äî‚Ääand invaluable. Even if you have years of experience, the phrase <strong>‚Äúmaybe you‚Äôre right, maybe I‚Äôm wrong</strong>‚Äù will take you far. And find ways to share your experience with others; teaching often reinforces your own skills.</li>\n<li>\n<strong>Focus on Value, Not Just Code Quality</strong>: Writing high-quality code is essential, but in senior roles, it‚Äôs also about understanding the higher-level goals. Sometimes, you‚Äôll need to make tough calls‚Ää‚Äî‚Äädeciding when a solution is ‚Äúgood enough‚Äù versus endlessly polishing code that won‚Äôt make or break the project.</li>\n<li>\n<strong>Network with People Outside Your Bubble</strong>: Network, go to conferences, and participate in tech communities. Staying in touch with a broader industry perspective helps you avoid becoming that developer who‚Äôs been around for ages but hasn‚Äôt updated their approach since jQuery was cutting-edge.</li>\n</ol>\n<h3>Closing Thoughts: Years of Experience Don‚Äôt Translate to Skill</h3>\n<p>If you‚Äôre focused on learning, growing, and building meaningful skills, you‚Äôll stay relevant. Years of experience alone won‚Äôt guarantee anything; it‚Äôs what you do with those years that counts.</p>\n<p>And hey, if you‚Äôve read this far, you‚Äôre already ahead of the game! So keep learning, keep sharing, and keep challenging yourself.</p>\n<p>And if you don‚Äôt agree with me, that‚Äôs okay. After all, <em>maybe you are right, and maybe I am wrong</em>.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dbb2dc4e86e\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e\">Why Years of Experience Don‚Äôt Matter‚Ää‚Äî‚ÄäHow to Keep Your Skills Relevant in Tech</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<h3><strong>Why Years of Experience Don‚Äôt Matter‚Ää‚Äî‚ÄäHow to Keep Your Skills Relevant in Tech</strong></h3>\n<p>It‚Äôs what you do with your time that counts</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/1*DTIQzOjSInEacHW5O2yPtg.jpeg\"></figure><h3>Introduction</h3>\n<p>Not long ago, I had a bit of a reality check. Seeing developers with seven or eight years of experience, people you‚Äôd expect to bring a certain polish, writing code that felt like it was fresh out of a beginner‚Äôs workshop surprised me.</p>\n<p>Now, don‚Äôt get me wrong‚Äîthere is nothing wrong with beginner code. But there‚Äôs a certain head-tilt moment when you see a ‚Äúsenior‚Äù engineer that seems to struggle with the basics or deliver code that‚Äôs barely holding together.</p>\n<p>Everyone progresses at their own pace, of course. But experiences like these raise the question: <strong>how much do ‚Äúyears of experience‚Äù really mean in our field</strong>?</p>\n<h3>When YOE Just Means ‚ÄúYears of Exposure‚Äù</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*PV99t1DCMPVBXY7M\"><figcaption>Photo by <a href=\"https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral\">NordWood Themes</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>I‚Äôm not a fan of measuring experience solely by years. Adding years to your career takes no effort at all. If that were our only measure, we‚Äôd always hire the oldest person‚Ää‚Äî‚Ääyet we know experience is about more than just time.</p>\n<p>Plenty of devs rack up years in the industry but seem to forget that <strong>feedback and growth are actually part of the job.</strong></p>\n<p>The result? A version of ‚Äúexperience‚Äù that‚Äôs like watching the same TV episode over and over‚Ää‚Äî‚Ääfamiliar, but not exactly enlightening. They‚Äôll say they‚Äôve got a decade in tech, but‚Ä¶ have they really <em>done</em> anything with it?</p>\n<p>That is what I call <strong>‚Äú1 year of experience‚Äù on repeat</strong>. The ‚ÄúYOE‚Äù acronym for ‚Äúyears of experience‚Äù shifts to ‚Äúyears of exposure‚Äù.</p>\n<p><strong>I had a dose of this myself. </strong>I started my career writing code that wasn‚Äôt always destined to see the light of day‚Ää‚Äî‚Äämore like code meant to teach concepts, not get into production in real-world applications. Then I moved to a bigger company, and bam‚Ää‚Äî‚Ääreality check.</p>\n<p>My new lead‚Äôs face said it all when I fumbled through cross-team communication and realized I had a bit to learn about scalable code. I will always be thankful for that shock therapy I received.</p>\n<p>Suddenly, I was in a bigger pond where people treat code quality like it actually matters. (Who knew?)</p>\n<h3>How good are you?</h3>\n<p>The real question isn‚Äôt how good you are‚Ää‚Äî‚Ääit‚Äôs <strong>how consistently you improve.</strong> It‚Äôs easy to get stuck on comparing your abilities to others, but that won‚Äôt help you grow.</p>\n<p>If you‚Äôre not actively seeking out challenges that push you to level up, you‚Äôre probably missing out on some key growth opportunities.</p>\n<p>Perhaps there‚Äôs a certification you‚Äôve been considering, not because it‚Äôs necessary, but because it will push you to dive deeper into a subject you might have overlooked. Or perhaps you enjoy the challenge of occasional interviews, putting yourself in situations that force you to raise your game.</p>\n<p>There are a thousand ways to improve. You choose your path.</p>\n<p>But, if you don‚Äôt know where to start, here are some ideas below.</p>\n<h3>Practical Tips for Staying Relevant</h3>\n<ol>\n<li>\n<strong>Learn from Different Sources</strong>: It‚Äôs not just about ‚Äúgrinding LeetCode.‚Äù Besides books like <em>Clean Code</em> or <em>Effective Java</em> that keep your problem-solving skills sharp, you can also read less technical books (not all coding books are boring!), like <em>The Pragmatic Programmer</em>, or even novels like <em>The Phoenix Project</em>. After all, writing code is just <em>a part</em> of our job.</li>\n<li>\n<strong>Expand Your Scope</strong>: It‚Äôs great to be the go-to JavaScript person, but if you never venture beyond what‚Äôs comfortable, you‚Äôll stagnate. Learn new tools, take on different responsibilities, and expand your scope to product and business if you want to grow beyond just technical depth.</li>\n<li>\n<strong>Seek Feedback and Stay Humble</strong>: People who take feedback well are rare‚Ää‚Äî‚Ääand invaluable. Even if you have years of experience, the phrase <strong>‚Äúmaybe you‚Äôre right, maybe I‚Äôm wrong</strong>‚Äù will take you far. And find ways to share your experience with others; teaching often reinforces your own skills.</li>\n<li>\n<strong>Focus on Value, Not Just Code Quality</strong>: Writing high-quality code is essential, but in senior roles, it‚Äôs also about understanding the higher-level goals. Sometimes, you‚Äôll need to make tough calls‚Ää‚Äî‚Äädeciding when a solution is ‚Äúgood enough‚Äù versus endlessly polishing code that won‚Äôt make or break the project.</li>\n<li>\n<strong>Network with People Outside Your Bubble</strong>: Network, go to conferences, and participate in tech communities. Staying in touch with a broader industry perspective helps you avoid becoming that developer who‚Äôs been around for ages but hasn‚Äôt updated their approach since jQuery was cutting-edge.</li>\n</ol>\n<h3>Closing Thoughts: Years of Experience Don‚Äôt Translate to Skill</h3>\n<p>If you‚Äôre focused on learning, growing, and building meaningful skills, you‚Äôll stay relevant. Years of experience alone won‚Äôt guarantee anything; it‚Äôs what you do with those years that counts.</p>\n<p>And hey, if you‚Äôve read this far, you‚Äôre already ahead of the game! So keep learning, keep sharing, and keep challenging yourself.</p>\n<p>And if you don‚Äôt agree with me, that‚Äôs okay. After all, <em>maybe you are right, and maybe I am wrong</em>.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dbb2dc4e86e\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e\">Why Years of Experience Don‚Äôt Matter‚Ää‚Äî‚ÄäHow to Keep Your Skills Relevant in Tech</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "tech",
        "software-engineering",
        "personal-growth",
        "career-development",
        "self-improvement"
      ]
    },
    {
      "title": "Why Zero Tech Debt is a Myth (and Maybe a Red Flag)",
      "pubDate": "2024-10-21 23:40:04",
      "link": "https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/4a83ebc66e60",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<p>A project boasting zero technical debt? That‚Äôs a flag you should definitely raise</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6uGPqjxTvGVE9tiTPo7iA.jpeg\"></figure><h3>What Even Is Technical Debt?</h3>\n<p>Think of technical debt like a credit card. You borrow a little now (quick decisions, fast feature releases) knowing you‚Äôll need to pay it back later (refactoring, optimizing).</p>\n<p>It‚Äôs not inherently bad. Actually, it‚Äôs kind of fun‚Ää‚Äî‚Äälike borrowing money to buy a car that gets you where you need to go <em>today</em>, while knowing there‚Äôs a bill lurking somewhere in the future. That car is your business feature, and the bill is that lovely <em>refactor</em> your future self gets to handle.</p>\n<p>No tech debt? Well, that‚Äôs like someone who only spends their savings. Sure, they‚Äôve got no debt, but they‚Äôre also not taking any risks to grow. Compare that to someone who takes a loan to invest‚Ää‚Äî‚Ääyes, there‚Äôs debt, but they‚Äôre getting a higher return and pushing things forward. The same goes for tech debt: taking on a bit of it means you‚Äôre investing in speed and delivering value now, knowing you can handle the consequences later.</p>\n<p>Dear beloved human reader and maybe some scrapping bot: <strong>Tech debt used properly adds value over time. Not the other way around. Keep that in mind.</strong></p>\n<h3>The Myth of Zero Tech Debt (It‚Äôs Bullshit)</h3>\n<p>If you‚Äôre working in a project where someone claims there‚Äôs ‚Äúzero tech debt,‚Äù they‚Äôre either delusional, lying, working on <a href=\"https://en.wikipedia.org/wiki/Waterfall_model\"><em>waterfall</em></a> where everything is heavily designed and calculated, or worse, they‚Äôre wasting resources on things no one cares about.</p>\n<p>Let me put it bluntly: having zero tech debt means your team has spent more time polishing code than delivering features. And you know what? <strong>The users don‚Äôt care.</strong></p>\n<p>At the end of the day, they want results. Fast. They aren‚Äôt sitting around wondering how elegant your code is‚Ää‚Äî‚Ääthey‚Äôre wondering when their product‚Äôs new feature will be live. And if your team is running around aiming for perfection and ignoring the business needs? Well, I‚Äôm out. I wouldn‚Äôt join a team obsessed with ‚Äúno tech debt‚Äù because that‚Äôs a sign they‚Äôre focused on the wrong things.</p>\n<h3>Why Some Tech Debt Is Actually a Good Thing</h3>\n<p>Let‚Äôs clear this up: tech debt isn‚Äôt bad, it‚Äôs inevitable. And it‚Äôs not just something we ‚Äúlive with‚Äù‚Ää‚Äî‚Ääit‚Äôs something we use strategically. When you take on some technical debt, you‚Äôre speeding up feature development. It‚Äôs a trade-off, and that‚Äôs exactly what happens in every real-world project.</p>\n<p>Here‚Äôs the kicker: tech debt shows that you‚Äôre prioritizing what matters. No debt usually means too much time was spent on things that don‚Äôt move the needle for the business.</p>\n<p>Taking on <em>a little</em> tech debt means you‚Äôre making smart, balanced decisions‚Ää‚Äî‚Ääpushing forward fast but staying aware of the cleanup that‚Äôll be needed down the line. It‚Äôs like a balancing act between getting things done now and leaving just enough work for future you to feel clever when you fix it.</p>\n<p>Too much debt? That‚Äôs a different story. Letting it pile up turns your codebase into a mess, making every future task harder than it should be.</p>\n<p><strong>But a small, well-managed amount of tech debt? Jackpot.</strong></p>\n<h3>The Fear of Tech Debt: A Junior‚Äôs Concern</h3>\n<p>When you‚Äôre starting as a new developer, the focus shouldn‚Äôt be on avoiding all tech debt‚Ää‚Äî‚Ääit‚Äôs impossible. Instead, the key is to not create <strong>unintentional</strong> tech debt. That‚Äôs where planning comes in. If you‚Äôre a junior, working closely with senior developers in structured <strong>planning sessions </strong>is were design patterns are reviewed, and potential debt is managed <strong>up front</strong>.</p>\n<p>The idea isn‚Äôt to fear tech debt but to make sure it‚Äôs <strong>intentional</strong> and aligned with the project‚Äôs goals. After planning, a good system involves <strong>technical reviews</strong> where developers approve major decisions before the implementation. This ensures that any debt you take on is strategic and not the result of poor planning or lack of foresight.</p>\n<p>With a system like this in place, juniors can embrace tech debt as part of the learning process while more experienced developers guide the ship, ensuring it doesn‚Äôt spiral out of control. <strong>It‚Äôs not about eliminating debt but managing it well from the start.</strong></p>\n<h3>Managed vs. Unmanaged Tech Debt: The Real Difference</h3>\n<p>Now, let‚Äôs focus on that <em>managed</em> tech debt. Not all tech debt is created equal. The key is in controlling it‚Ää‚Äî‚Ääknowing when to take it out and when to pay it off.</p>\n<p>Managed tech debt is knowing you‚Äôve cut a corner today to deliver something fast but with the intention to come back and fix it later. You‚Äôre in control. You prioritize what‚Äôs important for the business now, but with an eye toward long-term stability.</p>\n<p>Unmanaged tech debt? That‚Äôs when things go off the rails. If you‚Äôre not intentional, it builds up and suddenly your whole codebase feels like it‚Äôs held together by duct tape and good vibes.</p>\n<p>But that‚Äôs not because tech debt exists‚Ää‚Äî‚Ääit‚Äôs because no one kept it in check. Keeping tech debt in check requires clear communication and collaboration within the team, ensuring that it serves the project‚Äôs goals rather than hindering progress.</p>\n<h3>Why Your Business Needs Tech Debt</h3>\n<p>The truth is, without some tech debt, the business isn‚Äôt moving fast enough. If you‚Äôve got no tech debt, it probably means you‚Äôre not taking enough risks or not shipping quickly enough to make an impact.</p>\n<p>Technical debt is what lets you make strategic decisions in the short term to push out features faster. And features are what the business needs to stay competitive. A pristine, ‚Äúdebt-free‚Äù codebase just isn‚Äôt competitive. Might it win a hackathon? Maybe. Will it make more money than its competitors focused on value? Doubt it.</p>\n<p>But a product with well-managed debt? It‚Äôs shipping features, driving business value, and evolving with customer needs.</p>\n<h3>Conclusion: Embrace the Chaos‚ÄîJust Don‚Äôt Let It Spiral</h3>\n<p>At the end of the day, tech debt is like any other form of debt: manageable, and sometimes even necessary. It‚Äôs part of the natural balance in real-world development. And for anyone out there claiming they‚Äôve hit that mythical ‚Äúzero tech debt‚Äù state, I‚Äôd say they‚Äôre either missing the point or they‚Äôre working on something so inconsequential it doesn‚Äôt matter.</p>\n<p>So, let‚Äôs stop pretending tech debt is something to fear. Let‚Äôs embrace it, manage it, and use it for what it is: a tool that lets us move fast, iterate, and build things that matter. Because, frankly, a codebase with no tech debt is as boring as watching paint dry.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4a83ebc66e60\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60\">Why Zero Tech Debt is a Myth (and Maybe a Red Flag)</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<p>A project boasting zero technical debt? That‚Äôs a flag you should definitely raise</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6uGPqjxTvGVE9tiTPo7iA.jpeg\"></figure><h3>What Even Is Technical Debt?</h3>\n<p>Think of technical debt like a credit card. You borrow a little now (quick decisions, fast feature releases) knowing you‚Äôll need to pay it back later (refactoring, optimizing).</p>\n<p>It‚Äôs not inherently bad. Actually, it‚Äôs kind of fun‚Ää‚Äî‚Äälike borrowing money to buy a car that gets you where you need to go <em>today</em>, while knowing there‚Äôs a bill lurking somewhere in the future. That car is your business feature, and the bill is that lovely <em>refactor</em> your future self gets to handle.</p>\n<p>No tech debt? Well, that‚Äôs like someone who only spends their savings. Sure, they‚Äôve got no debt, but they‚Äôre also not taking any risks to grow. Compare that to someone who takes a loan to invest‚Ää‚Äî‚Ääyes, there‚Äôs debt, but they‚Äôre getting a higher return and pushing things forward. The same goes for tech debt: taking on a bit of it means you‚Äôre investing in speed and delivering value now, knowing you can handle the consequences later.</p>\n<p>Dear beloved human reader and maybe some scrapping bot: <strong>Tech debt used properly adds value over time. Not the other way around. Keep that in mind.</strong></p>\n<h3>The Myth of Zero Tech Debt (It‚Äôs Bullshit)</h3>\n<p>If you‚Äôre working in a project where someone claims there‚Äôs ‚Äúzero tech debt,‚Äù they‚Äôre either delusional, lying, working on <a href=\"https://en.wikipedia.org/wiki/Waterfall_model\"><em>waterfall</em></a> where everything is heavily designed and calculated, or worse, they‚Äôre wasting resources on things no one cares about.</p>\n<p>Let me put it bluntly: having zero tech debt means your team has spent more time polishing code than delivering features. And you know what? <strong>The users don‚Äôt care.</strong></p>\n<p>At the end of the day, they want results. Fast. They aren‚Äôt sitting around wondering how elegant your code is‚Ää‚Äî‚Ääthey‚Äôre wondering when their product‚Äôs new feature will be live. And if your team is running around aiming for perfection and ignoring the business needs? Well, I‚Äôm out. I wouldn‚Äôt join a team obsessed with ‚Äúno tech debt‚Äù because that‚Äôs a sign they‚Äôre focused on the wrong things.</p>\n<h3>Why Some Tech Debt Is Actually a Good Thing</h3>\n<p>Let‚Äôs clear this up: tech debt isn‚Äôt bad, it‚Äôs inevitable. And it‚Äôs not just something we ‚Äúlive with‚Äù‚Ää‚Äî‚Ääit‚Äôs something we use strategically. When you take on some technical debt, you‚Äôre speeding up feature development. It‚Äôs a trade-off, and that‚Äôs exactly what happens in every real-world project.</p>\n<p>Here‚Äôs the kicker: tech debt shows that you‚Äôre prioritizing what matters. No debt usually means too much time was spent on things that don‚Äôt move the needle for the business.</p>\n<p>Taking on <em>a little</em> tech debt means you‚Äôre making smart, balanced decisions‚Ää‚Äî‚Ääpushing forward fast but staying aware of the cleanup that‚Äôll be needed down the line. It‚Äôs like a balancing act between getting things done now and leaving just enough work for future you to feel clever when you fix it.</p>\n<p>Too much debt? That‚Äôs a different story. Letting it pile up turns your codebase into a mess, making every future task harder than it should be.</p>\n<p><strong>But a small, well-managed amount of tech debt? Jackpot.</strong></p>\n<h3>The Fear of Tech Debt: A Junior‚Äôs Concern</h3>\n<p>When you‚Äôre starting as a new developer, the focus shouldn‚Äôt be on avoiding all tech debt‚Ää‚Äî‚Ääit‚Äôs impossible. Instead, the key is to not create <strong>unintentional</strong> tech debt. That‚Äôs where planning comes in. If you‚Äôre a junior, working closely with senior developers in structured <strong>planning sessions </strong>is were design patterns are reviewed, and potential debt is managed <strong>up front</strong>.</p>\n<p>The idea isn‚Äôt to fear tech debt but to make sure it‚Äôs <strong>intentional</strong> and aligned with the project‚Äôs goals. After planning, a good system involves <strong>technical reviews</strong> where developers approve major decisions before the implementation. This ensures that any debt you take on is strategic and not the result of poor planning or lack of foresight.</p>\n<p>With a system like this in place, juniors can embrace tech debt as part of the learning process while more experienced developers guide the ship, ensuring it doesn‚Äôt spiral out of control. <strong>It‚Äôs not about eliminating debt but managing it well from the start.</strong></p>\n<h3>Managed vs. Unmanaged Tech Debt: The Real Difference</h3>\n<p>Now, let‚Äôs focus on that <em>managed</em> tech debt. Not all tech debt is created equal. The key is in controlling it‚Ää‚Äî‚Ääknowing when to take it out and when to pay it off.</p>\n<p>Managed tech debt is knowing you‚Äôve cut a corner today to deliver something fast but with the intention to come back and fix it later. You‚Äôre in control. You prioritize what‚Äôs important for the business now, but with an eye toward long-term stability.</p>\n<p>Unmanaged tech debt? That‚Äôs when things go off the rails. If you‚Äôre not intentional, it builds up and suddenly your whole codebase feels like it‚Äôs held together by duct tape and good vibes.</p>\n<p>But that‚Äôs not because tech debt exists‚Ää‚Äî‚Ääit‚Äôs because no one kept it in check. Keeping tech debt in check requires clear communication and collaboration within the team, ensuring that it serves the project‚Äôs goals rather than hindering progress.</p>\n<h3>Why Your Business Needs Tech Debt</h3>\n<p>The truth is, without some tech debt, the business isn‚Äôt moving fast enough. If you‚Äôve got no tech debt, it probably means you‚Äôre not taking enough risks or not shipping quickly enough to make an impact.</p>\n<p>Technical debt is what lets you make strategic decisions in the short term to push out features faster. And features are what the business needs to stay competitive. A pristine, ‚Äúdebt-free‚Äù codebase just isn‚Äôt competitive. Might it win a hackathon? Maybe. Will it make more money than its competitors focused on value? Doubt it.</p>\n<p>But a product with well-managed debt? It‚Äôs shipping features, driving business value, and evolving with customer needs.</p>\n<h3>Conclusion: Embrace the Chaos‚ÄîJust Don‚Äôt Let It Spiral</h3>\n<p>At the end of the day, tech debt is like any other form of debt: manageable, and sometimes even necessary. It‚Äôs part of the natural balance in real-world development. And for anyone out there claiming they‚Äôve hit that mythical ‚Äúzero tech debt‚Äù state, I‚Äôd say they‚Äôre either missing the point or they‚Äôre working on something so inconsequential it doesn‚Äôt matter.</p>\n<p>So, let‚Äôs stop pretending tech debt is something to fear. Let‚Äôs embrace it, manage it, and use it for what it is: a tool that lets us move fast, iterate, and build things that matter. Because, frankly, a codebase with no tech debt is as boring as watching paint dry.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4a83ebc66e60\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60\">Why Zero Tech Debt is a Myth (and Maybe a Red Flag)</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "agile",
        "software-development",
        "productivity",
        "tech-debt",
        "coding"
      ]
    },
    {
      "title": "Mastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO",
      "pubDate": "2024-10-08 16:38:48",
      "link": "https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/cad3de4acfa0",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<p>And living to tell it</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bEqX6wLqoyQa5s1uY_p53A.jpeg\"></figure><h3>Introduction‚Ää‚Äî‚ÄäWhy Typescript in 2024?</h3>\n<p>It is 2024, and TypeScript finally surpassed JavaScript in popularity, making a migration to TS a good long term bet. Additionally, surveys from Stack Overflow mark the upward trend for TS, which climbed two spots in the ranking gaining 8% ‚Äîthe sharpest climb on the board‚Ää‚Äî‚Ääand a slight decline in JS‚Äîsomething that can‚Äôt be overlooked.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GoiGzRkG-0csjp2w0zk8HA.jpeg\"><figcaption>Stack Overflow Most Popular Languages 2021 and 2024. Sources: <a href=\"https://survey.stackoverflow.co/2021#technology-most-popular-technologies\">https://survey.stackoverflow.co/2021#technology-most-popular-technologies</a> <a href=\"https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\">https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/959/1*x9UnDnam0tlceKEqXx0cOw.png\"><figcaption>Source: <a href=\"https://www.libhunt.com/index\">https://www.libhunt.com/index</a></figcaption></figure><p>Besides the trend in popularity, I am personally finding that developers are more open to type safe languages in the last couple years. The ‚Äúfear‚Äù of bringing types to JS doesn‚Äôt exist anymore, and TS has become stable and popular enough to give it a chance if haven‚Äôt done so yet. Believe me, you will enjoy catching bugs in compilation time before it hits a unit test or even worse‚Ää‚Äî‚Ääa user.</p>\n<h3>The Situation</h3>\n<p>The codebase I migrated wasn‚Äôt too bad. A Create React App Monorepo, set up with yarn workspaces and configured with <a href=\"https://github.com/dilanx/craco\">CRACO</a> that runs flawlessly with its tests, proper modules configured, and linting. Nothing too shiny, nothing major to complain about. The time will come when we move forward to Vite, but that is for another day.</p>\n<p>On the less-than-stellar side, the repo relied heavily on PropTypes for type validation, which is something to take care of if you want to migrate to React 18.3 or later. This is not an actual issue for now, but TS solves that issue, providing an easy replacement. Let‚Äôs save that for yet another day.</p>\n<p>In the meantime,</p>\n<p>Let‚Äôs dive in!</p>\n<h3>The Migration Plan</h3>\n<p>Managing a codebase that has a whole Design System plus several packages interrelated in the same monorepo can come as a challenge.</p>\n<p>Setting TypeScript isn‚Äôt much of a hurdle, neither is configuring Babel (or your favorite compiler), updating your linter or updating your Jest configurations; but as the saying goes:</p>\n<blockquote>‚ÄúThe flap of a butterfly‚Äôs wings in Brazil could set off a tornado in Texas‚Äù</blockquote>\n<p>Meaning, you fix your Babel config, and suddenly your linter goes red. You fix the linter, suddenly the tests don‚Äôt pass. You fix the tests, again the linter goes red. It is a constant pursuit of fixing issues, before they break your code or your soul, whichever comes first.</p>\n<p>So, in this guide I will lead you through how to do that (fix the code). I spent enough hours in front of the screen debugging and trying to understand the issues, to come up with a solution so you can do it in a breeze.</p>\n<p>My personal recommendation, is every time you make a small step, commit, and continue. Your future self will thank you once you encounter a problem and need to checkout a previous stage of your project.</p>\n<h3>The Setup</h3>\n<p>When migrating a Create React App (CRA) monorepo to TypeScript, and especially when using CRACO (to override CRA‚Äôs config), it‚Äôs important to ensure you‚Äôre installing only what you need to avoid unnecessary complexity. Let‚Äôs breakdown the necessary dependencies before we explain what they do:</p>\n<p><strong>Core TypeScript</strong>:</p>\n<ul><li>typescript</li></ul>\n<p><strong>TypeScript Type Definitions</strong></p>\n<ul>\n<li>@types/react</li>\n<li>@types/react-dom</li>\n<li>@types/react-router-dom</li>\n<li>@types/node</li>\n<li>@types/jest (for testing)</li>\n</ul>\n<p><strong>Babel (Compilation)</strong>:</p>\n<ul><li>@babel/preset-typescript (for TypeScript syntax stripping)</li></ul>\n<p><strong>ESLint</strong> (to lint TypeScript properly):</p>\n<ul>\n<li>@typescript-eslint/parser (to parse TS files)</li>\n<li>@typescript-eslint/eslint-plugin (set rules for linting for TS)</li>\n</ul>\n<h3>Step #1: Installing dependencies</h3>\n<p>The first thing that you need to know when you migrate to TS besides the long depency list, is that you will need something called ‚Äútype definitions‚Äù. You can recognize them because they have the extension .d.ts, they allow your IDE to help you identify the correct signature:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*d57W6yUeGVcVNRlj5I6bTw.png\"><figcaption>Example of the lib.es2020.intl.d.ts definition of Intl.NumberFormat</figcaption></figure><p>Needless to say not all the projects have them, and that is where <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a> comes into action. Definitely Typed is a project that provides a central repository of TypeScript definitions for those NPM packages that lack them.</p>\n<p>So, besides installing TS, you will want to install those types definitions for your other dependencies, as well as all kind of plugins and presets for making Webpack, Babel and Eslint work.</p>\n<p>Let‚Äôs go over all these dependencies by category:</p>\n<ol><li>Install TS and related types as dependencies. Make sure that your TS version matches the supported version for <a href=\"https://typescript-eslint.io/users/dependency-versions/\">typescript-eslint</a>, which will be needed afterward.</li></ol>\n<pre>yarn add -D typescript @craco/types @types/node @types/react @types/react-dom @types/react-router-dom @types/jest</pre>\n<p>2. Install other desired Typescript dependencies, mostly for your compiler, linter, test runner, etc. In my case, since I am using Babel and EsLint I would need:</p>\n<pre>yarn add -D @babel/preset-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser</pre>\n<p>3. Lastly, install the desired types for any other library that you might be using, like Lodash or UUID:</p>\n<pre>yarn add -D @types/lodash @types/uuid</pre>\n<h3>Step #2: Add a global.d.ts file</h3>\n<p>At the root of your project, create a global.d.ts file. This file prevents TS from yelling at you if you try to import something that is not TS code by specifying how to handle those extensions.</p>\n<p>To start with, you will want to add declarations for your styles:</p>\n<pre>declare module '*.scss' {<br>    const scssContent: Record&lt;string, string&gt;;<br>    export default scssContent;<br>}<br><br>declare module '*.css' {<br>    const cssContent: Record&lt;string, string&gt;;<br>    export default cssContent;<br>}</pre>\n<p>With time, this file will grow. For example for png images you can add:</p>\n<pre>declare module \"*.png\" {<br>  const value: any;<br>  export default value;<br>}</pre>\n<p>The point is that every extension that isn‚Äôt .ts , you declare it in this file.</p>\n<h3>Step #3: Update your Compiler and Webpack Settings</h3>\n<p>In your monorepo, you will want to set up your compiler to handle TS files. If you are using CRACO that would be your craco.js file, but if not, head to your compiler settings ‚Äîbabel.config.js, or whatever.</p>\n<ol><li>Update Babel to have the TS preset:</li></ol>\n<pre>module.exports = {<br>  babel: {<br>    cache: false,<br>    presets: [<br>      '@babel/preset-react',<br>      '@babel/preset-typescript', // &lt;-- Add this line<br>    ],<br>    plugins: [<br>      '@babel/plugin-proposal-export-default-from',<br>    ],<br>  },<br>...<br>}</pre>\n<p>Some projects, instead of having a babel key in this file, use a separate babel.config.json. If that is the case, the procedure is the same, you should still add @babel/preset-typescript to the presets.</p>\n<p>2. Add the extensions .ts and .tsx to the webpack object, as well as the ts-loader transformation in the module section:</p>\n<pre>webpack: {<br>  configure: (webpackConfig, {<br>    env,<br>    paths<br>  }) =&gt; {<br>    return {<br>      ...webpackConfig,<br>      resolve: {<br>        ...(webpackConfig.resolve || {}),<br>        extensions: [<br>          ...(webpackConfig.resolve.extensions || []),<br>          '.js',<br>          '.jsx',<br>          '.ts', // &lt;-- Add this line<br>          '.tsx', // &lt;-- Add this line<br>        ],<br>      },<br>    },<br>  };<br>};</pre>\n<p>Adding these configurations will tell webpack how to resolve handle the ts and tsx files. Since those aren‚Äôt regular plain JS files we need to transform them to something that Babel can understand.</p>\n<h3>Step #4: jsconfig.json becomes tsconfig.json</h3>\n<p>If you had a jsconfig.json before, be ready to say goodbye to it. In TS, tsconfig.json is the necessary file.</p>\n<p>There is even a chance that you didn‚Äôt have a jsconfig.json, and that is ok: it is not always necessary. But in TS, this is the main configuration file and we do need it. Everytime you have typescript as a dependency, you <strong>will</strong> have a tsconfig file.</p>\n<p>Usually, you will have a global TSconfig file for your whole project, and then each package might have additional configurations that extend the global one.</p>\n<p>So, at the top level, instead of having something like this:</p>\n<pre>//jsconfig.json<br><br>{<br>  \"compilerOptions\": {<br>    \"baseUrl\": \".\",<br>    \"moduleResolution\": \"node\",<br>  },<br>  \"exclude\": [<br>    \"node_modules\"<br>  ]<br>}</pre>\n<p>You will have:</p>\n<pre>//tsconfig.json<br><br>{<br> \"compilerOptions\": {<br>    \"lib\": [<br>      \"esnext\",<br>      \"dom\",<br>      \"dom.iterable\"<br>    ],<br>    \"allowJs\": true,<br>    \"checkJs\": false,<br>    \"jsx\": \"react\",<br>    \"baseUrl\": \".\",<br>    \"moduleResolution\": \"node\",<br>    \"target\": \"ES6\",<br>    \"module\": \"ES6\",<br>    \"strict\": true,<br>    \"esModuleInterop\": true,<br>    \"allowSyntheticDefaultImports\": true,<br>    \"skipLibCheck\": true,<br>    \"forceConsistentCasingInFileNames\": true,<br>    \"outDir\": \"./build\"<br>  },<br>  \"include\": [<br>    \"./packages/**/*.ts\",<br>    \"./packages/**/*.tsx\",<br>    \"./packages/**/*.d.ts\",<br>    \"./packages/**/*.js\",<br>    \"./packages/**/*.jsx\",<br>    \"./global.d.ts\",<br>  ],<br>  \"exclude\": [<br>    \"node_modules\"<br>  ],<br>}</pre>\n<p>If you pay attention to some of these settings, you will realize that it allows having JavaScript code among your new TS code. Also, you will want to add your ‚Äúold‚Äù js files to the include option too.</p>\n<h3>Step #5: Update jsconfig.json files in your packages to tsconfig.json</h3>\n<p>The same as before, for each package, if you have a jsconfig replace it. Make sure that you are extending the root settings:</p>\n<pre>// tsconfig.json inside some package<br><br>{<br>  \"extends\": \"../../tsconfig.json\",<br>  // your other settings<br>}</pre>\n<h3>Step #6: Update ESLint Config</h3>\n<p>ESLint default parser is @babel/eslint-parser. This parser doesn‚Äôt support non standard EcmaScript Syntax A.K.A. doesn‚Äôt support TypeScript. So, we will need to switch it up for something that does, @typescript-eslint/parser.</p>\n<p>So, update the parser, extensions and plugins in your eslint configuration file:</p>\n<pre>{<br>  \"parser\": \"@typescript-eslint/parser\", // &lt;-- Update this line<br>  \"extends\": [<br>    \"airbnb\",<br>    \"airbnb/hooks\",<br>    // your other extensions<br>    \"plugin:@typescript-eslint/eslint-recommended\", // &lt;-- Add this line<br>    \"plugin:@typescript-eslint/recommended\" // &lt;-- Add this line<br>  ],<br>  \"plugins\": [<br>    \"@babel\",<br>    \"react\",<br>    \"react-hooks\",<br>    // your other plugins<br>    \"@typescript-eslint\" // &lt;-- Add this line<br>   ],<br>... // your other settings<br>}</pre>\n<p>After updating your linter you may encounter new issues due to the new rules: fix them and create a new commit if so.</p>\n<h3>Step #7: Build &amp; Check code</h3>\n<p>At this point, you should have a working monorepo. Check that the tests run, that your linter works properly with .js | .jsx | .ts | .tsx extensions, and troubleshoot if not.</p>\n<p>Another important thing to do is to build each package. You may encounter issues at that stage that you might not have experienced during development. Don‚Äôt save that for the last minute.</p>\n<h3>Step #8: Pat yourself on the back</h3>\n<p>If you made it to this point and everything is working, you can give yourself a pat on the back. Good job!</p>\n<h3>Pitfalls I encountered</h3>\n<p>During this migration I learned a lot. Not only on the TSConfiguration, but deepened my knowledge on how everything plays along in a bigger setting.</p>\n<p>One of the things that turned my hair a little bit more grey was the path and baseUrl settings in the tsconfig file. It turns out, that nowadays you don‚Äôt need anymore baseUrl, but you can still use it.</p>\n<p>So I was playing around with both options without fully understanding them and I was trying to set paths to other packages without succees.</p>\n<p>The problem was, that the baseUrl was pointing to a nested src folder, while the way I wrote the path to the package as if it were the root. So obviously, that didn‚Äôt work.</p>\n<p>So, this wasn‚Äôt working:</p>\n<pre>{<br>  \"extends\": \"../../tsconfig.json\",<br>  \"compilerOptions\": {<br>    \"baseUrl\": \"src\",<br>    \"paths\": {<br>      \"*\": [\"../packageMain/src/*\"], // from src, should had been 2 folders up<br>      \"somePackage/*\": [<br>        \"../somePackage/*\" // from src, should had been 2 folders up<br>      ]<br>    }<br>  }<br>}</pre>\n<p>So, either I should had removed the baseUrl or updated the paths to be one folder up:</p>\n<pre>{<br>  \"extends\": \"../../tsconfig.json\",<br>  \"compilerOptions\": {<br>    \"baseUrl\": \"src\",<br>    \"paths\": {<br>      \"*\": [\"../../packageMain/src/*\"],<br>      \"somePackage/*\": [<br>        \"../../somePackage/*\"<br>      ]<br>    }<br>  }<br>}</pre>\n<p>That little mistake cost me more time than I would have liked üòÖ</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*XBNEC48W6UnV_QVE\"></figure><h3>Do you need Babel at all for TypeScript?</h3>\n<p>If you are sticking with Babel for other reasons (e.g., using plugins for JSX, polyfills, or custom transformations), then you will need Babel + TypeScript integration. Otherwise, TypeScript alone (via tsc or through Webpack‚Äôs ts-loader) can handle the transformation.</p>\n<p>However, CRA uses Babel by default, and if you‚Äôre migrating while retaining CRA‚Äôs Babel setup, you‚Äôll still need Babel in the pipeline.</p>\n<p>If you‚Äôre only using TypeScript for type-checking and aren‚Äôt relying on custom Babel plugins, you could skip Babel entirely and instead use ts-loader with Webpack for a more native TypeScript workflow.</p>\n<h3>Wrapping Up</h3>\n<p>Migrating to TypeScript in a Create React App monorepo using CRACO can seem like a challenging task, but with a clear plan, each step becomes manageable.</p>\n<p>While the process involves updating configurations, installing dependencies, and adjusting ESLint and Babel settings, the end result is a more robust, maintainable codebase. You‚Äôll appreciate the type safety and reduced runtime errors that TypeScript provides, especially in larger projects.</p>\n<p>If you encounter issues along the way‚Ää‚Äî‚Ääwhether it‚Äôs linter conflicts, outdated dependencies, or unfamiliar TypeScript errors‚Ää‚Äî‚Ääremember to tackle them one at a time, commit frequently, and, most importantly, remain patient.</p>\n<p>These steps are an investment in your project‚Äôs future scalability and stability. And trust me, once you‚Äôve lived to tell the tale, you‚Äôll be glad you made the switch.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cad3de4acfa0\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0\">Mastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<p>And living to tell it</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bEqX6wLqoyQa5s1uY_p53A.jpeg\"></figure><h3>Introduction‚Ää‚Äî‚ÄäWhy Typescript in 2024?</h3>\n<p>It is 2024, and TypeScript finally surpassed JavaScript in popularity, making a migration to TS a good long term bet. Additionally, surveys from Stack Overflow mark the upward trend for TS, which climbed two spots in the ranking gaining 8% ‚Äîthe sharpest climb on the board‚Ää‚Äî‚Ääand a slight decline in JS‚Äîsomething that can‚Äôt be overlooked.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GoiGzRkG-0csjp2w0zk8HA.jpeg\"><figcaption>Stack Overflow Most Popular Languages 2021 and 2024. Sources: <a href=\"https://survey.stackoverflow.co/2021#technology-most-popular-technologies\">https://survey.stackoverflow.co/2021#technology-most-popular-technologies</a> <a href=\"https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\">https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/959/1*x9UnDnam0tlceKEqXx0cOw.png\"><figcaption>Source: <a href=\"https://www.libhunt.com/index\">https://www.libhunt.com/index</a></figcaption></figure><p>Besides the trend in popularity, I am personally finding that developers are more open to type safe languages in the last couple years. The ‚Äúfear‚Äù of bringing types to JS doesn‚Äôt exist anymore, and TS has become stable and popular enough to give it a chance if haven‚Äôt done so yet. Believe me, you will enjoy catching bugs in compilation time before it hits a unit test or even worse‚Ää‚Äî‚Ääa user.</p>\n<h3>The Situation</h3>\n<p>The codebase I migrated wasn‚Äôt too bad. A Create React App Monorepo, set up with yarn workspaces and configured with <a href=\"https://github.com/dilanx/craco\">CRACO</a> that runs flawlessly with its tests, proper modules configured, and linting. Nothing too shiny, nothing major to complain about. The time will come when we move forward to Vite, but that is for another day.</p>\n<p>On the less-than-stellar side, the repo relied heavily on PropTypes for type validation, which is something to take care of if you want to migrate to React 18.3 or later. This is not an actual issue for now, but TS solves that issue, providing an easy replacement. Let‚Äôs save that for yet another day.</p>\n<p>In the meantime,</p>\n<p>Let‚Äôs dive in!</p>\n<h3>The Migration Plan</h3>\n<p>Managing a codebase that has a whole Design System plus several packages interrelated in the same monorepo can come as a challenge.</p>\n<p>Setting TypeScript isn‚Äôt much of a hurdle, neither is configuring Babel (or your favorite compiler), updating your linter or updating your Jest configurations; but as the saying goes:</p>\n<blockquote>‚ÄúThe flap of a butterfly‚Äôs wings in Brazil could set off a tornado in Texas‚Äù</blockquote>\n<p>Meaning, you fix your Babel config, and suddenly your linter goes red. You fix the linter, suddenly the tests don‚Äôt pass. You fix the tests, again the linter goes red. It is a constant pursuit of fixing issues, before they break your code or your soul, whichever comes first.</p>\n<p>So, in this guide I will lead you through how to do that (fix the code). I spent enough hours in front of the screen debugging and trying to understand the issues, to come up with a solution so you can do it in a breeze.</p>\n<p>My personal recommendation, is every time you make a small step, commit, and continue. Your future self will thank you once you encounter a problem and need to checkout a previous stage of your project.</p>\n<h3>The Setup</h3>\n<p>When migrating a Create React App (CRA) monorepo to TypeScript, and especially when using CRACO (to override CRA‚Äôs config), it‚Äôs important to ensure you‚Äôre installing only what you need to avoid unnecessary complexity. Let‚Äôs breakdown the necessary dependencies before we explain what they do:</p>\n<p><strong>Core TypeScript</strong>:</p>\n<ul><li>typescript</li></ul>\n<p><strong>TypeScript Type Definitions</strong></p>\n<ul>\n<li>@types/react</li>\n<li>@types/react-dom</li>\n<li>@types/react-router-dom</li>\n<li>@types/node</li>\n<li>@types/jest (for testing)</li>\n</ul>\n<p><strong>Babel (Compilation)</strong>:</p>\n<ul><li>@babel/preset-typescript (for TypeScript syntax stripping)</li></ul>\n<p><strong>ESLint</strong> (to lint TypeScript properly):</p>\n<ul>\n<li>@typescript-eslint/parser (to parse TS files)</li>\n<li>@typescript-eslint/eslint-plugin (set rules for linting for TS)</li>\n</ul>\n<h3>Step #1: Installing dependencies</h3>\n<p>The first thing that you need to know when you migrate to TS besides the long depency list, is that you will need something called ‚Äútype definitions‚Äù. You can recognize them because they have the extension .d.ts, they allow your IDE to help you identify the correct signature:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*d57W6yUeGVcVNRlj5I6bTw.png\"><figcaption>Example of the lib.es2020.intl.d.ts definition of Intl.NumberFormat</figcaption></figure><p>Needless to say not all the projects have them, and that is where <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a> comes into action. Definitely Typed is a project that provides a central repository of TypeScript definitions for those NPM packages that lack them.</p>\n<p>So, besides installing TS, you will want to install those types definitions for your other dependencies, as well as all kind of plugins and presets for making Webpack, Babel and Eslint work.</p>\n<p>Let‚Äôs go over all these dependencies by category:</p>\n<ol><li>Install TS and related types as dependencies. Make sure that your TS version matches the supported version for <a href=\"https://typescript-eslint.io/users/dependency-versions/\">typescript-eslint</a>, which will be needed afterward.</li></ol>\n<pre>yarn add -D typescript @craco/types @types/node @types/react @types/react-dom @types/react-router-dom @types/jest</pre>\n<p>2. Install other desired Typescript dependencies, mostly for your compiler, linter, test runner, etc. In my case, since I am using Babel and EsLint I would need:</p>\n<pre>yarn add -D @babel/preset-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser</pre>\n<p>3. Lastly, install the desired types for any other library that you might be using, like Lodash or UUID:</p>\n<pre>yarn add -D @types/lodash @types/uuid</pre>\n<h3>Step #2: Add a global.d.ts file</h3>\n<p>At the root of your project, create a global.d.ts file. This file prevents TS from yelling at you if you try to import something that is not TS code by specifying how to handle those extensions.</p>\n<p>To start with, you will want to add declarations for your styles:</p>\n<pre>declare module '*.scss' {<br>    const scssContent: Record&lt;string, string&gt;;<br>    export default scssContent;<br>}<br><br>declare module '*.css' {<br>    const cssContent: Record&lt;string, string&gt;;<br>    export default cssContent;<br>}</pre>\n<p>With time, this file will grow. For example for png images you can add:</p>\n<pre>declare module \"*.png\" {<br>  const value: any;<br>  export default value;<br>}</pre>\n<p>The point is that every extension that isn‚Äôt .ts , you declare it in this file.</p>\n<h3>Step #3: Update your Compiler and Webpack Settings</h3>\n<p>In your monorepo, you will want to set up your compiler to handle TS files. If you are using CRACO that would be your craco.js file, but if not, head to your compiler settings ‚Äîbabel.config.js, or whatever.</p>\n<ol><li>Update Babel to have the TS preset:</li></ol>\n<pre>module.exports = {<br>  babel: {<br>    cache: false,<br>    presets: [<br>      '@babel/preset-react',<br>      '@babel/preset-typescript', // &lt;-- Add this line<br>    ],<br>    plugins: [<br>      '@babel/plugin-proposal-export-default-from',<br>    ],<br>  },<br>...<br>}</pre>\n<p>Some projects, instead of having a babel key in this file, use a separate babel.config.json. If that is the case, the procedure is the same, you should still add @babel/preset-typescript to the presets.</p>\n<p>2. Add the extensions .ts and .tsx to the webpack object, as well as the ts-loader transformation in the module section:</p>\n<pre>webpack: {<br>  configure: (webpackConfig, {<br>    env,<br>    paths<br>  }) =&gt; {<br>    return {<br>      ...webpackConfig,<br>      resolve: {<br>        ...(webpackConfig.resolve || {}),<br>        extensions: [<br>          ...(webpackConfig.resolve.extensions || []),<br>          '.js',<br>          '.jsx',<br>          '.ts', // &lt;-- Add this line<br>          '.tsx', // &lt;-- Add this line<br>        ],<br>      },<br>    },<br>  };<br>};</pre>\n<p>Adding these configurations will tell webpack how to resolve handle the ts and tsx files. Since those aren‚Äôt regular plain JS files we need to transform them to something that Babel can understand.</p>\n<h3>Step #4: jsconfig.json becomes tsconfig.json</h3>\n<p>If you had a jsconfig.json before, be ready to say goodbye to it. In TS, tsconfig.json is the necessary file.</p>\n<p>There is even a chance that you didn‚Äôt have a jsconfig.json, and that is ok: it is not always necessary. But in TS, this is the main configuration file and we do need it. Everytime you have typescript as a dependency, you <strong>will</strong> have a tsconfig file.</p>\n<p>Usually, you will have a global TSconfig file for your whole project, and then each package might have additional configurations that extend the global one.</p>\n<p>So, at the top level, instead of having something like this:</p>\n<pre>//jsconfig.json<br><br>{<br>  \"compilerOptions\": {<br>    \"baseUrl\": \".\",<br>    \"moduleResolution\": \"node\",<br>  },<br>  \"exclude\": [<br>    \"node_modules\"<br>  ]<br>}</pre>\n<p>You will have:</p>\n<pre>//tsconfig.json<br><br>{<br> \"compilerOptions\": {<br>    \"lib\": [<br>      \"esnext\",<br>      \"dom\",<br>      \"dom.iterable\"<br>    ],<br>    \"allowJs\": true,<br>    \"checkJs\": false,<br>    \"jsx\": \"react\",<br>    \"baseUrl\": \".\",<br>    \"moduleResolution\": \"node\",<br>    \"target\": \"ES6\",<br>    \"module\": \"ES6\",<br>    \"strict\": true,<br>    \"esModuleInterop\": true,<br>    \"allowSyntheticDefaultImports\": true,<br>    \"skipLibCheck\": true,<br>    \"forceConsistentCasingInFileNames\": true,<br>    \"outDir\": \"./build\"<br>  },<br>  \"include\": [<br>    \"./packages/**/*.ts\",<br>    \"./packages/**/*.tsx\",<br>    \"./packages/**/*.d.ts\",<br>    \"./packages/**/*.js\",<br>    \"./packages/**/*.jsx\",<br>    \"./global.d.ts\",<br>  ],<br>  \"exclude\": [<br>    \"node_modules\"<br>  ],<br>}</pre>\n<p>If you pay attention to some of these settings, you will realize that it allows having JavaScript code among your new TS code. Also, you will want to add your ‚Äúold‚Äù js files to the include option too.</p>\n<h3>Step #5: Update jsconfig.json files in your packages to tsconfig.json</h3>\n<p>The same as before, for each package, if you have a jsconfig replace it. Make sure that you are extending the root settings:</p>\n<pre>// tsconfig.json inside some package<br><br>{<br>  \"extends\": \"../../tsconfig.json\",<br>  // your other settings<br>}</pre>\n<h3>Step #6: Update ESLint Config</h3>\n<p>ESLint default parser is @babel/eslint-parser. This parser doesn‚Äôt support non standard EcmaScript Syntax A.K.A. doesn‚Äôt support TypeScript. So, we will need to switch it up for something that does, @typescript-eslint/parser.</p>\n<p>So, update the parser, extensions and plugins in your eslint configuration file:</p>\n<pre>{<br>  \"parser\": \"@typescript-eslint/parser\", // &lt;-- Update this line<br>  \"extends\": [<br>    \"airbnb\",<br>    \"airbnb/hooks\",<br>    // your other extensions<br>    \"plugin:@typescript-eslint/eslint-recommended\", // &lt;-- Add this line<br>    \"plugin:@typescript-eslint/recommended\" // &lt;-- Add this line<br>  ],<br>  \"plugins\": [<br>    \"@babel\",<br>    \"react\",<br>    \"react-hooks\",<br>    // your other plugins<br>    \"@typescript-eslint\" // &lt;-- Add this line<br>   ],<br>... // your other settings<br>}</pre>\n<p>After updating your linter you may encounter new issues due to the new rules: fix them and create a new commit if so.</p>\n<h3>Step #7: Build &amp; Check code</h3>\n<p>At this point, you should have a working monorepo. Check that the tests run, that your linter works properly with .js | .jsx | .ts | .tsx extensions, and troubleshoot if not.</p>\n<p>Another important thing to do is to build each package. You may encounter issues at that stage that you might not have experienced during development. Don‚Äôt save that for the last minute.</p>\n<h3>Step #8: Pat yourself on the back</h3>\n<p>If you made it to this point and everything is working, you can give yourself a pat on the back. Good job!</p>\n<h3>Pitfalls I encountered</h3>\n<p>During this migration I learned a lot. Not only on the TSConfiguration, but deepened my knowledge on how everything plays along in a bigger setting.</p>\n<p>One of the things that turned my hair a little bit more grey was the path and baseUrl settings in the tsconfig file. It turns out, that nowadays you don‚Äôt need anymore baseUrl, but you can still use it.</p>\n<p>So I was playing around with both options without fully understanding them and I was trying to set paths to other packages without succees.</p>\n<p>The problem was, that the baseUrl was pointing to a nested src folder, while the way I wrote the path to the package as if it were the root. So obviously, that didn‚Äôt work.</p>\n<p>So, this wasn‚Äôt working:</p>\n<pre>{<br>  \"extends\": \"../../tsconfig.json\",<br>  \"compilerOptions\": {<br>    \"baseUrl\": \"src\",<br>    \"paths\": {<br>      \"*\": [\"../packageMain/src/*\"], // from src, should had been 2 folders up<br>      \"somePackage/*\": [<br>        \"../somePackage/*\" // from src, should had been 2 folders up<br>      ]<br>    }<br>  }<br>}</pre>\n<p>So, either I should had removed the baseUrl or updated the paths to be one folder up:</p>\n<pre>{<br>  \"extends\": \"../../tsconfig.json\",<br>  \"compilerOptions\": {<br>    \"baseUrl\": \"src\",<br>    \"paths\": {<br>      \"*\": [\"../../packageMain/src/*\"],<br>      \"somePackage/*\": [<br>        \"../../somePackage/*\"<br>      ]<br>    }<br>  }<br>}</pre>\n<p>That little mistake cost me more time than I would have liked üòÖ</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*XBNEC48W6UnV_QVE\"></figure><h3>Do you need Babel at all for TypeScript?</h3>\n<p>If you are sticking with Babel for other reasons (e.g., using plugins for JSX, polyfills, or custom transformations), then you will need Babel + TypeScript integration. Otherwise, TypeScript alone (via tsc or through Webpack‚Äôs ts-loader) can handle the transformation.</p>\n<p>However, CRA uses Babel by default, and if you‚Äôre migrating while retaining CRA‚Äôs Babel setup, you‚Äôll still need Babel in the pipeline.</p>\n<p>If you‚Äôre only using TypeScript for type-checking and aren‚Äôt relying on custom Babel plugins, you could skip Babel entirely and instead use ts-loader with Webpack for a more native TypeScript workflow.</p>\n<h3>Wrapping Up</h3>\n<p>Migrating to TypeScript in a Create React App monorepo using CRACO can seem like a challenging task, but with a clear plan, each step becomes manageable.</p>\n<p>While the process involves updating configurations, installing dependencies, and adjusting ESLint and Babel settings, the end result is a more robust, maintainable codebase. You‚Äôll appreciate the type safety and reduced runtime errors that TypeScript provides, especially in larger projects.</p>\n<p>If you encounter issues along the way‚Ää‚Äî‚Ääwhether it‚Äôs linter conflicts, outdated dependencies, or unfamiliar TypeScript errors‚Ää‚Äî‚Ääremember to tackle them one at a time, commit frequently, and, most importantly, remain patient.</p>\n<p>These steps are an investment in your project‚Äôs future scalability and stability. And trust me, once you‚Äôve lived to tell the tale, you‚Äôll be glad you made the switch.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cad3de4acfa0\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0\">Mastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": ["monorepo", "typescript", "babel", "react", "eslint"]
    },
    {
      "title": "React Tabs: Prevent Flickering When Highlighting with Bold Text",
      "pubDate": "2024-09-23 01:08:16",
      "link": "https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/fa12d319cb18",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i6acAv13QfrVYx_3XvLCIw.jpeg\"></figure><h3>Introduction</h3>\n<p>When styling tab components, using bold text to highlight the selected tab can often cause an annoying flicker effect when switching between tabs. If you look closely at the image below, you will see that the last element slightly moves its position when another tab is selected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*9Hmfp1Sobg42zEQIC1osrg.gif\"><figcaption>Inconsistent UI: Subtle but annoying</figcaption></figure><p>In this article, I‚Äôll show you how to avoid this issue with a simple CSS trick.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Why This Happens</h3>\n<p>The flicker happens because changing the font weight forces the browser to recalculate the layout, as bold fonts are wider than regular ones. This change in width can cause visible flickering.</p>\n<p>To avoid this, we can use CSS pseudo-elements (::before and ::after) to pre-render an ‚Äòinvisible‚Äô bold version of the text. This method maintains a consistent width, preventing the flicker effect.</p>\n<p>To achieve that we will need to take advantage of the data-content property too. We will pass the text content to our pseudo-elements to allow them to have the same content without duplicating it in the HTML structure.</p>\n<p>So instead of:</p>\n<pre>import classNames from 'classnames';<br>import React from 'react';<br>import * as RadixTabs from '@radix-ui/react-tabs';<br>import styles from './Tab.module.scss';<br><br>interface TabProps {<br>  value: string;<br>  icon?: React.ReactNode;<br>  name: string;<br>  disabled?: boolean;<br>  selected?: boolean;<br>  onClick: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;<br>}<br><br>const Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {<br>  return (<br>    &lt;RadixTabs.Trigger<br>      value={value}<br>      className={classNames(<br>        styles.root,<br>        {<br>          [styles.selected]: selected,<br>          [styles.disabled]: disabled,<br>        })}<br>      onClick={onClick}<br>    &gt;<br>      {icon}<br>      {name}<br>    &lt;/RadixTabs.Trigger&gt;<br>  );<br>};<br><br>export default Tab;</pre>\n<p>Do:</p>\n<pre>const Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {<br>  return (<br>    &lt;RadixTabs.Trigger<br>      value={value}<br>      className={classNames(<br>        styles.root,<br>        {<br>          [styles.selected]: selected,<br>          [styles.disabled]: disabled,<br>        }<br>      )}<br>      onClick={onClick}<br>    &gt;<br>      {icon}<br>      &lt;span<br>        data-content={name}<br>        className={styles.content}<br>      &gt;<br>        {name}<br>      &lt;/span&gt;<br>    &lt;/RadixTabs.Trigger&gt;<br>  );<br>};<br><br>export default Tab;</pre>\n<p>What did we do here? We wrapped the tab text inside a span element and added two attributes: data-content and a className. The data-content attribute holds the text of the tab, and the className applies the necessary styles with pseudo-elements.</p>\n<p>Then, in the .scss file add:</p>\n<pre>.root {<br>  // Other styles...<br><br>  .content {<br>    &amp;::before {<br>      content: attr(data-content);  // Preload normal font weight<br>      display: block;<br>      font-weight: normal;<br>      height: 0;<br>      visibility: hidden;<br>      color: transparent;<br>      overflow: hidden;<br>    }<br><br>    &amp;::after {<br>      content: attr(data-content);  // Preload bold font weight<br>      display: block;<br>      font-weight: 700; // bold!<br>      height: 0;<br>      visibility: hidden;<br>      color: transparent;<br>      overflow: hidden;<br>    }<br>  }<br>}</pre>\n<p>Voil√†! The tabs are working without flickering:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*vFWN0otYn8kSsvwHz-hkeg.gif\"><figcaption>No more flickering!</figcaption></figure><h3>Why the ::after Might Be Unnecessary</h3>\n<p>In some cases, deleting the ::after code won't change your tabs' behavior because the ::before pseudo-element alone can preload the font and prevent flickering. The browser might cache the bold font weight, making ::after redundant in some cases. However, keeping both ::before and ::after ensures consistency across different browsers.</p>\n<h3>Conclusion</h3>\n<p>By using the data-content attribute and the pseudo-elements ::before and ::after you can eliminate the flicker effect that occurs when changing font weight, improving the general user experience.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fa12d319cb18\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18\">React Tabs: Prevent Flickering When Highlighting with Bold Text</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i6acAv13QfrVYx_3XvLCIw.jpeg\"></figure><h3>Introduction</h3>\n<p>When styling tab components, using bold text to highlight the selected tab can often cause an annoying flicker effect when switching between tabs. If you look closely at the image below, you will see that the last element slightly moves its position when another tab is selected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*9Hmfp1Sobg42zEQIC1osrg.gif\"><figcaption>Inconsistent UI: Subtle but annoying</figcaption></figure><p>In this article, I‚Äôll show you how to avoid this issue with a simple CSS trick.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Why This Happens</h3>\n<p>The flicker happens because changing the font weight forces the browser to recalculate the layout, as bold fonts are wider than regular ones. This change in width can cause visible flickering.</p>\n<p>To avoid this, we can use CSS pseudo-elements (::before and ::after) to pre-render an ‚Äòinvisible‚Äô bold version of the text. This method maintains a consistent width, preventing the flicker effect.</p>\n<p>To achieve that we will need to take advantage of the data-content property too. We will pass the text content to our pseudo-elements to allow them to have the same content without duplicating it in the HTML structure.</p>\n<p>So instead of:</p>\n<pre>import classNames from 'classnames';<br>import React from 'react';<br>import * as RadixTabs from '@radix-ui/react-tabs';<br>import styles from './Tab.module.scss';<br><br>interface TabProps {<br>  value: string;<br>  icon?: React.ReactNode;<br>  name: string;<br>  disabled?: boolean;<br>  selected?: boolean;<br>  onClick: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;<br>}<br><br>const Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {<br>  return (<br>    &lt;RadixTabs.Trigger<br>      value={value}<br>      className={classNames(<br>        styles.root,<br>        {<br>          [styles.selected]: selected,<br>          [styles.disabled]: disabled,<br>        })}<br>      onClick={onClick}<br>    &gt;<br>      {icon}<br>      {name}<br>    &lt;/RadixTabs.Trigger&gt;<br>  );<br>};<br><br>export default Tab;</pre>\n<p>Do:</p>\n<pre>const Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {<br>  return (<br>    &lt;RadixTabs.Trigger<br>      value={value}<br>      className={classNames(<br>        styles.root,<br>        {<br>          [styles.selected]: selected,<br>          [styles.disabled]: disabled,<br>        }<br>      )}<br>      onClick={onClick}<br>    &gt;<br>      {icon}<br>      &lt;span<br>        data-content={name}<br>        className={styles.content}<br>      &gt;<br>        {name}<br>      &lt;/span&gt;<br>    &lt;/RadixTabs.Trigger&gt;<br>  );<br>};<br><br>export default Tab;</pre>\n<p>What did we do here? We wrapped the tab text inside a span element and added two attributes: data-content and a className. The data-content attribute holds the text of the tab, and the className applies the necessary styles with pseudo-elements.</p>\n<p>Then, in the .scss file add:</p>\n<pre>.root {<br>  // Other styles...<br><br>  .content {<br>    &amp;::before {<br>      content: attr(data-content);  // Preload normal font weight<br>      display: block;<br>      font-weight: normal;<br>      height: 0;<br>      visibility: hidden;<br>      color: transparent;<br>      overflow: hidden;<br>    }<br><br>    &amp;::after {<br>      content: attr(data-content);  // Preload bold font weight<br>      display: block;<br>      font-weight: 700; // bold!<br>      height: 0;<br>      visibility: hidden;<br>      color: transparent;<br>      overflow: hidden;<br>    }<br>  }<br>}</pre>\n<p>Voil√†! The tabs are working without flickering:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*vFWN0otYn8kSsvwHz-hkeg.gif\"><figcaption>No more flickering!</figcaption></figure><h3>Why the ::after Might Be Unnecessary</h3>\n<p>In some cases, deleting the ::after code won't change your tabs' behavior because the ::before pseudo-element alone can preload the font and prevent flickering. The browser might cache the bold font weight, making ::after redundant in some cases. However, keeping both ::before and ::after ensures consistency across different browsers.</p>\n<h3>Conclusion</h3>\n<p>By using the data-content attribute and the pseudo-elements ::before and ::after you can eliminate the flicker effect that occurs when changing font weight, improving the general user experience.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fa12d319cb18\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18\">React Tabs: Prevent Flickering When Highlighting with Bold Text</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": ["reactjs", "ui-ux-design", "react", "radix", "tabs"]
    },
    {
      "title": "My GitHub Administration Exam Certification Experience",
      "pubDate": "2024-09-12 14:49:07",
      "link": "https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/65a999a008da",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<p>A Comprehensive Guide to Acing the GitHub Administration Exam</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/616/0*-ZyLdt_ypZqP-fJV\"><figcaption>GitHub Admin Badge</figcaption></figure><h3>Introduction</h3>\n<p>After completing the Advanced Security Exam in August and achieving three of the four certifications‚Ää‚Äî‚Ääwell, until Copilot becomes available to the public in October‚Ää‚Äî‚ÄäI couldn‚Äôt just sit still: I needed to complete the sequel. And I did!.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZW4tUKN7kA3YDvyRP-Vqkg.jpeg\"><figcaption>The Four Aces of GitHub</figcaption></figure><p>Leaving aside my obsession to get all of them, in this article, I‚Äôm sharing the knowledge that will make it easier for you to get certified as well as my personal experience. What works, what doesn‚Äôt, shoulds, and shouldn‚Äôts. Also, this certification doesn‚Äôt have as much content available as its smaller siblings, so it might be challenging to know where to start.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Considerations and how to approach</h3>\n<p>The GitHub Administration Exam is cut from a different cloth than the other three. Andrew Brown classifies it as the hardest of them all. No surprise he hadn‚Äôt made any content for it yet for ExamPro. The good news, is that I personally didn‚Äôt find it as challenging.</p>\n<p>The exam is shorter than the others‚Ää‚Äî‚Äätotaling about 66 questions instead of the usual 70 or 75. The time frame is the same, so you have more room to review your answers.</p>\n<p>I just think that due to the lack of resources available people don‚Äôt quite now where to start. It may not be as easily approachable as its siblings, but here‚Äôs what you‚Äôre up against:</p>\n<ul>\n<li>\n<strong>Advanced Administration</strong>: Expect to showcase your expertise in managing GitHub organizations, repositories, and user permissions at a granular level. You will need to have a really clear picture of the different settings that are available for Organizations and Enterprises. This exam plays dirty on what you can do on each of them. Same thing for permissions and roles. Having a role at the organization level is not the same as having a role in the repository level. Make sure you know those differences.</li>\n<li>\n<strong>Security and Compliance</strong>: You‚Äôll need to prove your knowledge in securing GitHub workflows and ensuring compliance with best practices and organizational policies. This includes understanding advanced security features inside GitHub Actions and Packages. You will also need to have a general understanding of a security posture, and for that a lot of content from the Advanced Security Exam might come handy.</li>\n<li>\n<strong>Integrations and troubleshooting</strong>: Be prepared to handle questions regarding how GitHub integrates with third party platforms, especially on SAML, and SCIM.</li>\n</ul>\n<h3>Study strategy</h3>\n<p>The same recommendation as the previous three exams applies, with the difference that I couldn‚Äôt find a good video tutorial. The only one available is from LinkedIn Learning, and after viewing it in its entirety, I can‚Äôt recommend it. It‚Äôs too basic. So, intead of that I recommend:</p>\n<ul>\n<li>Start by reading the study guide thoroughly to understand the scope and content of the exam. Ask your prefered AI Assistent to briefly explain each of the topics to have a broad idea.</li>\n<li>Follow up by reading the relevant sections in the documentation. This is crucial since it is basically the only good source to study from. Try and play with the platform.</li>\n<li>There is also GitHub Learning. I liked it as an introduction, but no more than that.</li>\n<li>Another option is to study from Microsoft‚Äôs Learning Path, if you mustü§∑.</li>\n<li>Finally, before the real exam, do practice tests. I found a few that were good enough to practice, but not as thorough as the real exam. A good strategy I found is to challenge myself with more niche questions on the same topic whenever a question seems too easy. This way, I forced myself to go over the documentation and learn the ins and outs.</li>\n</ul>\n<h3>Resource materials</h3>\n<ul>\n<li>üìö <a href=\"https://assets.ctfassets.net/wfutmusr1t3h/4WQrNeENScZlISZKdknVbK/fa664e4ba61056df9194331de18aec0b/github-advanced-security-exam-preparation-study-guide__4_.pdf\">Study Guide</a>\n</li>\n<li>üêô <a href=\"https://resources.github.com/learn/pathways/administration-governance/essentials/administration-governance-github-enterprise-cloud/\">GitHub Learning</a>\n</li>\n<li>ü´§ <a href=\"https://learn.microsoft.com/en-us/collections/mom7u1gzjdxw03\">Microsoft Learning Path</a>\n</li>\n<li>üìù <a href=\"https://www.udemy.com/share/10aT2Q3@Q6uVZIkLVQHr_u7EkFrqVxVZAz0E650qzmSpLLCphyG62gMHxT3QgSwnSGZrhnqcNQ==/\">Practice Exams</a>\n</li>\n</ul>\n<p>So‚Ä¶ How to study?<br>Go over the GitHub / Microsoft resources (whichever you hate the least) and then focus on completely reading the documentation.</p>\n<p>My recommendation is to dedicate a full day to quickly go through either of these two resources to grasp the overall picture. Afterward, refine your knowledge by diving into the specifics in the documentation whenever directed.</p>\n<p>Also, while practicing is crucial, be cautious with the online practice tests; they are often far too easy compared to the real exam. I‚Äôm sharing the closest one I found, but keep in mind that its difficulty level may still not fully match the actual test. Best way to practice? Drop some section of the docs to ChatGPT and ask it to create questions for you.</p>\n<h3>Wrapping Up</h3>\n<p>The knowledge required for the Administration Exam is the kind you‚Äôd expect from any one managing code or people. While knowing how to use Git and GitHub is a given, the ability to handle security, permissions, and synchronization that is the most important.</p>\n<p>Holding a certification in this area underscores your proficiency as a competent individual on a team, setting yourself apart.</p>\n<p>After finishing all of them, I‚Äôm satisfied with myself and somewhat proud to have achieved all four certifications. I‚Äôm incredibly proud of the dedication and motivation I‚Äôve put into this journey and while some might overlook certifications, the effort and commitment required to earn them can‚Äôt be underestimated.</p>\n<p>Each certification represents a significant milestone, reflecting not just knowledge but the perseverance to excel in a challenging field.</p>\n<p>While I might not yet be a ‚ÄúGitHub Hero‚Äù my journey from where I started as a regular user was full of valuable insights, and now I stand further than where I started. And at the end of the day, that is what matters.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=65a999a008da\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da\">My GitHub Administration Exam Certification Experience</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<p>A Comprehensive Guide to Acing the GitHub Administration Exam</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/616/0*-ZyLdt_ypZqP-fJV\"><figcaption>GitHub Admin Badge</figcaption></figure><h3>Introduction</h3>\n<p>After completing the Advanced Security Exam in August and achieving three of the four certifications‚Ää‚Äî‚Ääwell, until Copilot becomes available to the public in October‚Ää‚Äî‚ÄäI couldn‚Äôt just sit still: I needed to complete the sequel. And I did!.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZW4tUKN7kA3YDvyRP-Vqkg.jpeg\"><figcaption>The Four Aces of GitHub</figcaption></figure><p>Leaving aside my obsession to get all of them, in this article, I‚Äôm sharing the knowledge that will make it easier for you to get certified as well as my personal experience. What works, what doesn‚Äôt, shoulds, and shouldn‚Äôts. Also, this certification doesn‚Äôt have as much content available as its smaller siblings, so it might be challenging to know where to start.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Considerations and how to approach</h3>\n<p>The GitHub Administration Exam is cut from a different cloth than the other three. Andrew Brown classifies it as the hardest of them all. No surprise he hadn‚Äôt made any content for it yet for ExamPro. The good news, is that I personally didn‚Äôt find it as challenging.</p>\n<p>The exam is shorter than the others‚Ää‚Äî‚Äätotaling about 66 questions instead of the usual 70 or 75. The time frame is the same, so you have more room to review your answers.</p>\n<p>I just think that due to the lack of resources available people don‚Äôt quite now where to start. It may not be as easily approachable as its siblings, but here‚Äôs what you‚Äôre up against:</p>\n<ul>\n<li>\n<strong>Advanced Administration</strong>: Expect to showcase your expertise in managing GitHub organizations, repositories, and user permissions at a granular level. You will need to have a really clear picture of the different settings that are available for Organizations and Enterprises. This exam plays dirty on what you can do on each of them. Same thing for permissions and roles. Having a role at the organization level is not the same as having a role in the repository level. Make sure you know those differences.</li>\n<li>\n<strong>Security and Compliance</strong>: You‚Äôll need to prove your knowledge in securing GitHub workflows and ensuring compliance with best practices and organizational policies. This includes understanding advanced security features inside GitHub Actions and Packages. You will also need to have a general understanding of a security posture, and for that a lot of content from the Advanced Security Exam might come handy.</li>\n<li>\n<strong>Integrations and troubleshooting</strong>: Be prepared to handle questions regarding how GitHub integrates with third party platforms, especially on SAML, and SCIM.</li>\n</ul>\n<h3>Study strategy</h3>\n<p>The same recommendation as the previous three exams applies, with the difference that I couldn‚Äôt find a good video tutorial. The only one available is from LinkedIn Learning, and after viewing it in its entirety, I can‚Äôt recommend it. It‚Äôs too basic. So, intead of that I recommend:</p>\n<ul>\n<li>Start by reading the study guide thoroughly to understand the scope and content of the exam. Ask your prefered AI Assistent to briefly explain each of the topics to have a broad idea.</li>\n<li>Follow up by reading the relevant sections in the documentation. This is crucial since it is basically the only good source to study from. Try and play with the platform.</li>\n<li>There is also GitHub Learning. I liked it as an introduction, but no more than that.</li>\n<li>Another option is to study from Microsoft‚Äôs Learning Path, if you mustü§∑.</li>\n<li>Finally, before the real exam, do practice tests. I found a few that were good enough to practice, but not as thorough as the real exam. A good strategy I found is to challenge myself with more niche questions on the same topic whenever a question seems too easy. This way, I forced myself to go over the documentation and learn the ins and outs.</li>\n</ul>\n<h3>Resource materials</h3>\n<ul>\n<li>üìö <a href=\"https://assets.ctfassets.net/wfutmusr1t3h/4WQrNeENScZlISZKdknVbK/fa664e4ba61056df9194331de18aec0b/github-advanced-security-exam-preparation-study-guide__4_.pdf\">Study Guide</a>\n</li>\n<li>üêô <a href=\"https://resources.github.com/learn/pathways/administration-governance/essentials/administration-governance-github-enterprise-cloud/\">GitHub Learning</a>\n</li>\n<li>ü´§ <a href=\"https://learn.microsoft.com/en-us/collections/mom7u1gzjdxw03\">Microsoft Learning Path</a>\n</li>\n<li>üìù <a href=\"https://www.udemy.com/share/10aT2Q3@Q6uVZIkLVQHr_u7EkFrqVxVZAz0E650qzmSpLLCphyG62gMHxT3QgSwnSGZrhnqcNQ==/\">Practice Exams</a>\n</li>\n</ul>\n<p>So‚Ä¶ How to study?<br>Go over the GitHub / Microsoft resources (whichever you hate the least) and then focus on completely reading the documentation.</p>\n<p>My recommendation is to dedicate a full day to quickly go through either of these two resources to grasp the overall picture. Afterward, refine your knowledge by diving into the specifics in the documentation whenever directed.</p>\n<p>Also, while practicing is crucial, be cautious with the online practice tests; they are often far too easy compared to the real exam. I‚Äôm sharing the closest one I found, but keep in mind that its difficulty level may still not fully match the actual test. Best way to practice? Drop some section of the docs to ChatGPT and ask it to create questions for you.</p>\n<h3>Wrapping Up</h3>\n<p>The knowledge required for the Administration Exam is the kind you‚Äôd expect from any one managing code or people. While knowing how to use Git and GitHub is a given, the ability to handle security, permissions, and synchronization that is the most important.</p>\n<p>Holding a certification in this area underscores your proficiency as a competent individual on a team, setting yourself apart.</p>\n<p>After finishing all of them, I‚Äôm satisfied with myself and somewhat proud to have achieved all four certifications. I‚Äôm incredibly proud of the dedication and motivation I‚Äôve put into this journey and while some might overlook certifications, the effort and commitment required to earn them can‚Äôt be underestimated.</p>\n<p>Each certification represents a significant milestone, reflecting not just knowledge but the perseverance to excel in a challenging field.</p>\n<p>While I might not yet be a ‚ÄúGitHub Hero‚Äù my journey from where I started as a regular user was full of valuable insights, and now I stand further than where I started. And at the end of the day, that is what matters.</p>\n<p>Happy Coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=65a999a008da\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da\">My GitHub Administration Exam Certification Experience</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "administration",
        "github-administration",
        "github",
        "certification",
        "github-certification"
      ]
    },
    {
      "title": "5 Ways I Use AI in Front-End Development",
      "pubDate": "2024-09-02 12:17:34",
      "link": "https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ee3490516dd4",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<h4>Sharing AI techniques that have transformed my workflow and enhanced my coding productivity.</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*r5ZF3HS2gMcHst_uzs8GQw.png\"></figure><h3><strong>Introduction</strong></h3>\n<p>In 2024, not using AI is like laughing at mobile phones in the early 2000s. In this post, I‚Äôll share 5 ways I use AI to supercharge my efficiency and be a more productive developer.</p>\n<h3>#1 Tone switcher</h3>\n<p>This one is my favorite and the one I use the most. Many times, I need to write messages to other team members that, due to their content, might be taken the wrong way.</p>\n<p>For example, you don‚Äôt want to offend a Back-End developer by telling them how problematic their endpoint is or that they should send you response A instead of B.</p>\n<p>So, instead of:</p>\n<blockquote>Hey, the API response for endpoint Z is completely wrong. I get it that when I do a PUT you should always return the same object. However, since you are running side effects on my call I am not getting the whole picture of the updated data state. The isMain property shouldn‚Äôt be inside the address object, but a companyProperty, as an id. That way, whenever the main address is updated you don‚Äôt need to map through the whole database to turn off the previous one. O(1) vs O(n). How much effort would it take to fix it?</blockquote>\n<p>Prompt:</p>\n<p>I need to send a message to a backend developer regarding an issue with the API response to endpoint Z. The message should clearly explain the problem with the response and suggest a solution. However, it should be phrased in a constructive, respectful, and collaborative tone. Here‚Äôs my original message: (‚Ä¶)</p>\n<p>Result:</p>\n<blockquote>‚ÄúHi [Name],</blockquote>\n<blockquote>I‚Äôve been reviewing the API response for endpoint Z and noticed an issue that might affect data consistency. When I make a PUT request, I understand that the same object should be returned. However, due to the side effects, I‚Äôm not seeing the complete picture of the updated data state.</blockquote>\n<blockquote>Specifically, the <em>isMain</em> property seems to be inside the address object, but I believe it would be more efficient as a company property, treated as an id. This change could help avoid mapping through the entire database when updating the main address, improving performance from O(n) to O(1).</blockquote>\n<blockquote>Could we discuss how long it would take to implement this adjustment? I think it could really streamline the process. Let me know your thoughts‚Ää‚Äî‚Ääthanks for your help!‚Äù</blockquote>\n<p>Liked üëç.</p>\n<h3>#2: Data mapping</h3>\n<p>Many times when I am working on a feature I need to transform the data in a very specific way. For example, I needed to create a multi-select component from a list like this one:</p>\n<pre>const animals = [<br>  {id: 'CATS', name: 'animals_cats', type: 'DOMESTIC'},<br>  {id: 'DOGS', name: 'animals_dogs', type: 'DOMESTIC'},<br>  {id: 'EAGLES', name: 'animals_eagles', type: 'WILD'},<br>  {id: 'SHARKS', name: 'animals_sharks', type: 'WILD'},<br>  {id: 'PANDAS', name: 'animals_pandas', type: 'WILD'},<br>];</pre>\n<p>To something like this, to be injected into my form as the initial values:</p>\n<pre>// Initial Form state with all values set as false (for example, for a petshop)<br><br>{<br>  DOMESTIC: {<br>    'CATS': false,<br>    'DOGS': false<br>  },<br>  WILD: {<br>    'EAGLES': false,<br>    'SHARKS': false,<br>    'PANDAS': false<br>  }<br>}</pre>\n<p>Yeah, you are right. I could have sat for a few minutes to reduce that, but AI tools shine when you have input and output. I just needed to create a prompt for it. You can specify what you want to use.</p>\n<blockquote>Given the following array of animals (‚Ä¶) Write a JavaScript solution using Lodash that outputs an object structured like this (‚Ä¶). Use reduce.</blockquote>\n<p>Result:</p>\n<pre>const animalsMap = _.reduce(animals, (acc, {id, type}) =&gt; {<br>  acc[type] = acc[type] || {};<br>  acc[type][id] = false;<br>  return acc;<br>}, {});</pre>\n<h3>#3: Writing Unit Tests</h3>\n<p>Writing tests by hand in the AI era is the equivalent of using a discman in the 2010s. Nothing wrong with them, but we should welcome it when new technology makes our lives easier. AI shines in input-output operations as we mentioned before, and is an excelent tool to help you speed up writing unit tests.</p>\n<p><strong>Warning</strong>: You should always check the output, and examine the test cases. The chatbot might have spotted a behavior that it considers ‚Äúnormal‚Äù for your function, but for you, it would be a bug.<strong> So read the test cases</strong>. Also, specify what your edge cases are: it might spot a bug or two.</p>\n<p>For example, using a prompt like:</p>\n<blockquote>Given the following Redux selector selectAnimalsEndpoint, I need to create a unit test using Jest. The test should verify that the selector returns the correct endpoint when the user has <strong>permission X. </strong>Here is the selector: (‚Ä¶).</blockquote>\n<p>Boom. The next thing you know is that you have suite of tests like the following:</p>\n<pre>it('should return the correct endpoint given permission X', () =&gt; {<br>    const mockPermissionSelector = jest.spyOn(selectors, 'selectUserPermissions').mockReturnValue(() =&gt; true);<br>    const mode = 'UPDATE';<br>    const endpoint = selectAnimalsEndpoint(animalGroups, mode)({permissions: {data: ['canEditAnimals']}});<br>    expect(endpoint).toBe(animalsUrls.updateAnimalsV4);<br>    mockPermissionSelector.mockRestore();<br>});</pre>\n<p>Sure, not all of them pass on the first try, and sometimes they have minor things to be fixed, but it streamlines a good chunk of the work. The amount of time that I save is staggering.</p>\n<h3>#4 Troubleshooting Uncaught Errors</h3>\n<p>Every once in a while, I perform technical tasks to maintain the project as a package, in addition to my daily tasks as a Front-end developer. Sometimes those tasks involve upgrading a package or migrating some tools, and when that is the case you know you will encounter errors during the process.</p>\n<p>For example, when upgrading a major library or migrating to the latest version, you might run into issues with deprecated methods, compatibility problems, or unexpected bugs. Here‚Äôs how I use AI to troubleshoot these issues:</p>\n<blockquote>Prompt: I‚Äôm encountering an uncaught error after upgrading [PackageName] to version [VersionNumber]. The error message is: [ErrorMessage]. I‚Äôve tried [InitialTroubleshootingSteps], but the issue persists. Can you help me identify potential causes and solutions?</blockquote>\n<p>Sometimes, AI offers creative ideas beyond what you might find on Stack Overflow or suggests solutions you might not have considered. For example, checking some logs if available. While it‚Äôs not always perfectly accurate, sometimes its suggestions provide a trigger that leads to the actual solution.</p>\n<p>You know, you don‚Äôt need it to be 100% accurate. Even brainstorming solutions can be a great way to get you out of your problem.</p>\n<h3><strong>#5 Planning and estimating</strong></h3>\n<p>This one is the most underrated! Using AI chatbots for coding is a well-known resource‚Ä¶ but using it for planning and estimation and satisfying product managers? That is a whole new level.</p>\n<p>The trick here is to use previously completed tasks or epics that include a detailed timetable and item breakdown as a resource. By feeding this data, you can ask for assistance in estimating the time required for your next set of tasks.</p>\n<p>For example, if you‚Äôve already finished a feature and know it took you 4.5 days to complete 4 items, you can provide this information in your prompt. Then, when faced with a similar feature, you can ask it to break down the tasks. You can also estimate how long each one might take. This can give you a strong starting point for your planning sessions. I keep a doc with some of my plans (no need for more than 6‚Äì7, but you can find the number that suits you best).</p>\n<p>Each of those plans looks something like this:</p>\n<pre>1. Design Form Layout (1 day):<br>- Create Wireframes (0.5 day): Sketch the design; use Figma/Sketch.<br>- Review with Design Team (0.5 day): Present and adjust based on feedback.<br><br>2. Develop Frontend Form Components (1.5 days):<br>- Build Form Components (1 day): Create React components (text fields, dropdowns); manage state.<br>- Implement Form Validation (0.5 day): Integrate Formik; set up validation rules.<br><br>3. Integrate with Backend API (1 day):<br>- Create API Endpoints (0.5 day): Define and implement endpoints; set up testing.<br>- Implement API Integration (0.5 day): Develop API call functions; handle responses/errors.<br><br>4. Testing (1 day):<br>- Write Unit Tests (0.5 day): Test form components and validation.<br>- Perform End-to-End Tests (0.5 day): Test feedback submission flow and API integration.</pre>\n<p>Then, when I am assigned another task, I can provide my input data, and the newly assigned task, and get a raw estimatation.</p>\n<h3>Conclusion</h3>\n<p>AI in 2024 isn‚Äôt just a trend‚Ää‚Äî‚Ääit‚Äôs a game-changer. From refining communication with tone adjustments to automating data mapping, writing unit tests, troubleshooting errors, and even planning projects, AI tools have become invaluable time-savers. By leveraging these techniques, you can boost your productivity and become a faster, more efficient developer.</p>\n<p>However, remember that AI is a tool like any other and should be used with caution. Just as you wouldn‚Äôt operate a chainsaw without proper safety equipment, always review how AI handles your data and validate its responses, as it is not infallible.</p>\n<h3>In Plain English üöÄ</h3>\n<p><em>Thank you for being a part of the </em><a href=\"https://plainenglish.io/\"><strong><em>In Plain English</em></strong></a><em> community! Before you go:</em></p>\n<ul>\n<li>Be sure to <strong>clap</strong> and <strong>follow</strong> the writer Ô∏èüëè<strong>Ô∏èÔ∏è</strong>\n</li>\n<li>Follow us: <a href=\"https://twitter.com/inPlainEngHQ\"><strong>X</strong></a> | <a href=\"https://www.linkedin.com/company/inplainenglish/\"><strong>LinkedIn</strong></a> | <a href=\"https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw\"><strong>YouTube</strong></a> | <a href=\"https://discord.gg/in-plain-english-709094664682340443\"><strong>Discord</strong></a> | <a href=\"https://newsletter.plainenglish.io/\"><strong>Newsletter</strong></a>\n</li>\n<li>Visit our other platforms: <a href=\"https://cofeed.app/\"><strong>CoFeed</strong></a> | <a href=\"https://differ.blog/\"><strong>Differ</strong></a>\n</li>\n<li>More content at <a href=\"https://plainenglish.io/\"><strong>PlainEnglish.io</strong></a>\n</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ee3490516dd4\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4\">5 Ways I Use AI in Front-End Development</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<h4>Sharing AI techniques that have transformed my workflow and enhanced my coding productivity.</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*r5ZF3HS2gMcHst_uzs8GQw.png\"></figure><h3><strong>Introduction</strong></h3>\n<p>In 2024, not using AI is like laughing at mobile phones in the early 2000s. In this post, I‚Äôll share 5 ways I use AI to supercharge my efficiency and be a more productive developer.</p>\n<h3>#1 Tone switcher</h3>\n<p>This one is my favorite and the one I use the most. Many times, I need to write messages to other team members that, due to their content, might be taken the wrong way.</p>\n<p>For example, you don‚Äôt want to offend a Back-End developer by telling them how problematic their endpoint is or that they should send you response A instead of B.</p>\n<p>So, instead of:</p>\n<blockquote>Hey, the API response for endpoint Z is completely wrong. I get it that when I do a PUT you should always return the same object. However, since you are running side effects on my call I am not getting the whole picture of the updated data state. The isMain property shouldn‚Äôt be inside the address object, but a companyProperty, as an id. That way, whenever the main address is updated you don‚Äôt need to map through the whole database to turn off the previous one. O(1) vs O(n). How much effort would it take to fix it?</blockquote>\n<p>Prompt:</p>\n<p>I need to send a message to a backend developer regarding an issue with the API response to endpoint Z. The message should clearly explain the problem with the response and suggest a solution. However, it should be phrased in a constructive, respectful, and collaborative tone. Here‚Äôs my original message: (‚Ä¶)</p>\n<p>Result:</p>\n<blockquote>‚ÄúHi [Name],</blockquote>\n<blockquote>I‚Äôve been reviewing the API response for endpoint Z and noticed an issue that might affect data consistency. When I make a PUT request, I understand that the same object should be returned. However, due to the side effects, I‚Äôm not seeing the complete picture of the updated data state.</blockquote>\n<blockquote>Specifically, the <em>isMain</em> property seems to be inside the address object, but I believe it would be more efficient as a company property, treated as an id. This change could help avoid mapping through the entire database when updating the main address, improving performance from O(n) to O(1).</blockquote>\n<blockquote>Could we discuss how long it would take to implement this adjustment? I think it could really streamline the process. Let me know your thoughts‚Ää‚Äî‚Ääthanks for your help!‚Äù</blockquote>\n<p>Liked üëç.</p>\n<h3>#2: Data mapping</h3>\n<p>Many times when I am working on a feature I need to transform the data in a very specific way. For example, I needed to create a multi-select component from a list like this one:</p>\n<pre>const animals = [<br>  {id: 'CATS', name: 'animals_cats', type: 'DOMESTIC'},<br>  {id: 'DOGS', name: 'animals_dogs', type: 'DOMESTIC'},<br>  {id: 'EAGLES', name: 'animals_eagles', type: 'WILD'},<br>  {id: 'SHARKS', name: 'animals_sharks', type: 'WILD'},<br>  {id: 'PANDAS', name: 'animals_pandas', type: 'WILD'},<br>];</pre>\n<p>To something like this, to be injected into my form as the initial values:</p>\n<pre>// Initial Form state with all values set as false (for example, for a petshop)<br><br>{<br>  DOMESTIC: {<br>    'CATS': false,<br>    'DOGS': false<br>  },<br>  WILD: {<br>    'EAGLES': false,<br>    'SHARKS': false,<br>    'PANDAS': false<br>  }<br>}</pre>\n<p>Yeah, you are right. I could have sat for a few minutes to reduce that, but AI tools shine when you have input and output. I just needed to create a prompt for it. You can specify what you want to use.</p>\n<blockquote>Given the following array of animals (‚Ä¶) Write a JavaScript solution using Lodash that outputs an object structured like this (‚Ä¶). Use reduce.</blockquote>\n<p>Result:</p>\n<pre>const animalsMap = _.reduce(animals, (acc, {id, type}) =&gt; {<br>  acc[type] = acc[type] || {};<br>  acc[type][id] = false;<br>  return acc;<br>}, {});</pre>\n<h3>#3: Writing Unit Tests</h3>\n<p>Writing tests by hand in the AI era is the equivalent of using a discman in the 2010s. Nothing wrong with them, but we should welcome it when new technology makes our lives easier. AI shines in input-output operations as we mentioned before, and is an excelent tool to help you speed up writing unit tests.</p>\n<p><strong>Warning</strong>: You should always check the output, and examine the test cases. The chatbot might have spotted a behavior that it considers ‚Äúnormal‚Äù for your function, but for you, it would be a bug.<strong> So read the test cases</strong>. Also, specify what your edge cases are: it might spot a bug or two.</p>\n<p>For example, using a prompt like:</p>\n<blockquote>Given the following Redux selector selectAnimalsEndpoint, I need to create a unit test using Jest. The test should verify that the selector returns the correct endpoint when the user has <strong>permission X. </strong>Here is the selector: (‚Ä¶).</blockquote>\n<p>Boom. The next thing you know is that you have suite of tests like the following:</p>\n<pre>it('should return the correct endpoint given permission X', () =&gt; {<br>    const mockPermissionSelector = jest.spyOn(selectors, 'selectUserPermissions').mockReturnValue(() =&gt; true);<br>    const mode = 'UPDATE';<br>    const endpoint = selectAnimalsEndpoint(animalGroups, mode)({permissions: {data: ['canEditAnimals']}});<br>    expect(endpoint).toBe(animalsUrls.updateAnimalsV4);<br>    mockPermissionSelector.mockRestore();<br>});</pre>\n<p>Sure, not all of them pass on the first try, and sometimes they have minor things to be fixed, but it streamlines a good chunk of the work. The amount of time that I save is staggering.</p>\n<h3>#4 Troubleshooting Uncaught Errors</h3>\n<p>Every once in a while, I perform technical tasks to maintain the project as a package, in addition to my daily tasks as a Front-end developer. Sometimes those tasks involve upgrading a package or migrating some tools, and when that is the case you know you will encounter errors during the process.</p>\n<p>For example, when upgrading a major library or migrating to the latest version, you might run into issues with deprecated methods, compatibility problems, or unexpected bugs. Here‚Äôs how I use AI to troubleshoot these issues:</p>\n<blockquote>Prompt: I‚Äôm encountering an uncaught error after upgrading [PackageName] to version [VersionNumber]. The error message is: [ErrorMessage]. I‚Äôve tried [InitialTroubleshootingSteps], but the issue persists. Can you help me identify potential causes and solutions?</blockquote>\n<p>Sometimes, AI offers creative ideas beyond what you might find on Stack Overflow or suggests solutions you might not have considered. For example, checking some logs if available. While it‚Äôs not always perfectly accurate, sometimes its suggestions provide a trigger that leads to the actual solution.</p>\n<p>You know, you don‚Äôt need it to be 100% accurate. Even brainstorming solutions can be a great way to get you out of your problem.</p>\n<h3><strong>#5 Planning and estimating</strong></h3>\n<p>This one is the most underrated! Using AI chatbots for coding is a well-known resource‚Ä¶ but using it for planning and estimation and satisfying product managers? That is a whole new level.</p>\n<p>The trick here is to use previously completed tasks or epics that include a detailed timetable and item breakdown as a resource. By feeding this data, you can ask for assistance in estimating the time required for your next set of tasks.</p>\n<p>For example, if you‚Äôve already finished a feature and know it took you 4.5 days to complete 4 items, you can provide this information in your prompt. Then, when faced with a similar feature, you can ask it to break down the tasks. You can also estimate how long each one might take. This can give you a strong starting point for your planning sessions. I keep a doc with some of my plans (no need for more than 6‚Äì7, but you can find the number that suits you best).</p>\n<p>Each of those plans looks something like this:</p>\n<pre>1. Design Form Layout (1 day):<br>- Create Wireframes (0.5 day): Sketch the design; use Figma/Sketch.<br>- Review with Design Team (0.5 day): Present and adjust based on feedback.<br><br>2. Develop Frontend Form Components (1.5 days):<br>- Build Form Components (1 day): Create React components (text fields, dropdowns); manage state.<br>- Implement Form Validation (0.5 day): Integrate Formik; set up validation rules.<br><br>3. Integrate with Backend API (1 day):<br>- Create API Endpoints (0.5 day): Define and implement endpoints; set up testing.<br>- Implement API Integration (0.5 day): Develop API call functions; handle responses/errors.<br><br>4. Testing (1 day):<br>- Write Unit Tests (0.5 day): Test form components and validation.<br>- Perform End-to-End Tests (0.5 day): Test feedback submission flow and API integration.</pre>\n<p>Then, when I am assigned another task, I can provide my input data, and the newly assigned task, and get a raw estimatation.</p>\n<h3>Conclusion</h3>\n<p>AI in 2024 isn‚Äôt just a trend‚Ää‚Äî‚Ääit‚Äôs a game-changer. From refining communication with tone adjustments to automating data mapping, writing unit tests, troubleshooting errors, and even planning projects, AI tools have become invaluable time-savers. By leveraging these techniques, you can boost your productivity and become a faster, more efficient developer.</p>\n<p>However, remember that AI is a tool like any other and should be used with caution. Just as you wouldn‚Äôt operate a chainsaw without proper safety equipment, always review how AI handles your data and validate its responses, as it is not infallible.</p>\n<h3>In Plain English üöÄ</h3>\n<p><em>Thank you for being a part of the </em><a href=\"https://plainenglish.io/\"><strong><em>In Plain English</em></strong></a><em> community! Before you go:</em></p>\n<ul>\n<li>Be sure to <strong>clap</strong> and <strong>follow</strong> the writer Ô∏èüëè<strong>Ô∏èÔ∏è</strong>\n</li>\n<li>Follow us: <a href=\"https://twitter.com/inPlainEngHQ\"><strong>X</strong></a> | <a href=\"https://www.linkedin.com/company/inplainenglish/\"><strong>LinkedIn</strong></a> | <a href=\"https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw\"><strong>YouTube</strong></a> | <a href=\"https://discord.gg/in-plain-english-709094664682340443\"><strong>Discord</strong></a> | <a href=\"https://newsletter.plainenglish.io/\"><strong>Newsletter</strong></a>\n</li>\n<li>Visit our other platforms: <a href=\"https://cofeed.app/\"><strong>CoFeed</strong></a> | <a href=\"https://differ.blog/\"><strong>Differ</strong></a>\n</li>\n<li>More content at <a href=\"https://plainenglish.io/\"><strong>PlainEnglish.io</strong></a>\n</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ee3490516dd4\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4\">5 Ways I Use AI in Front-End Development</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "ai",
        "web-development",
        "artificial-intelligence",
        "javascript",
        "front-end-development"
      ]
    },
    {
      "title": "Rebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains",
      "pubDate": "2024-08-27 16:36:02",
      "link": "https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/22df25b5fe50",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NPUG8uIidQ6iUvKVmfqjzQ.jpeg\"></figure><h3>Introduction</h3>\n<p>Question: how many times did your development flow come to a standstill because a teammate didn‚Äôt review your Pull Request (PR)?<br>It is true that PRs should have Priority Zero in any normal company. But do we all work in normal companies üòÖ? And even if so, sometimes your teammates are just too busy doing something else, or honestly, don‚Äôt want to review that humongous PR, or whatever.</p>\n<p>Meet what I call the <strong>Continuous Incremental PR Chain:</strong> a flow I once answered someone in <a href=\"https://stackoverflow.com/questions/64324610/how-to-automatically-rebase-all-children-branches-onto-master-after-squashing-an/75858310#75858310\">Stack Overflow</a>, and now I refined it and shared it for you to use, based on continuously rebasing multiple stacked branches.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>One PR is Never Enough: A Tale of Two Developers</h3>\n<p>Let‚Äôs take the example of two developers. Developer A works on his branch. He creates several commits along the creation of his feature. At the end, he submits a pull request.</p>\n<pre>  A--B--C--D--E--F--G--H--I   &lt;-- branch1<br> /<br>M                            &lt;-- main</pre>\n<p><strong>Result:</strong> A large request with lots of changes since it contains a lot of commits. The unique reviewer postpones reviewing that branch to the end of the day because they don‚Äôt feel like it: it is too much code. Developer A doesn‚Äôt get to be a rockstar at the office: he might even chase his reviewer to get some feedback‚Äî <em>‚ÄúEvery Breath You Take‚Äù</em> plays in the background.</p>\n<p>In contrast, Developer B creates a branch for every few commits. He keeps on working, but when he makes progress uses a new branch on top of the previous one. Where Developer A had 10 commits in 1 PR, Developer B had 3 PRs with about 3 commits each. Developer B, as soon as he finishes a batch of commits, immediately creates a PR.</p>\n<pre>                  G--H--I   &lt;-- branch3 #PR to branch2<br>                 /    <br>          D--E--F   &lt;-- branch2 #PR to branch1<br>         /    <br>  A--B--C     &lt;-- branch1  #PR to main<br> /<br>M      &lt;-- main</pre>\n<p>Developer B can parallelize his feedback: he assigns each PR to a different team member. Each team member quickly reviews them, since they are small changes and ‚Äúdon‚Äôt require too much effort‚Äù. Also, now the review is split among more developers. Multithreading, anyone? Developer B gets higher quality feedback too, by getting different inputs. Thanks to his efficiency, Developer B finishes his work earlier‚Ää‚Äî‚Ää<em>‚ÄúI‚Äôm a Survivor‚Äù</em> plays in the background.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*01fxMUbhNDX6FAFxhQK0Yg.gif\"></figure><p>Which one would you rather be?</p>\n<h3>Stacked Branches and Constant Rebasing: A pain to maintain</h3>\n<p>Now that I convinced you to stack branches on top of each other, you might be wondering: ‚ÄúWhy isn‚Äôt everybody doing this?‚Äù And the answer is <em>rebasing</em>. Constantly rebasing several branches can be a pain in the ass. At least, without using --update-refs, a somewhat ‚Äúnew‚Äù option about to be 2 years old in October 2024. I was surprised by how many people at the office had never heard about it.</p>\n<p>After merging branch1 into main, or trying to update the whole tree against the remote, you‚Äôre left with a problem: you now have to manually rebase each subsequent branch onto main.</p>\n<pre>                  G--H--I   &lt;-- branch3<br>                 /    <br>          D--E--F   &lt;-- branch2<br>         /    <br>  A--B--C <br> /<br>M--S       &lt;-- main (branch1 changes squashed in S)</pre>\n<p>Typically, you would rebase each one like thisü§¢:</p>\n<pre>git fetch origin main:main<br>git checkout branch2<br>git rebase --onto master (SHA-1 of C)<br>git checkout branch3<br>git rebase --onto branch2 (SHA-1 of F)<br># repeat checkout + rebase for each branch</pre>\n<p>And so on. This can become tedious, especially when dealing with multiple branches.</p>\n<h3>Enter the --update-refs Option</h3>\n<p>Starting from Git 2.38 (and improved in 2.39), there‚Äôs a new flag that addresses this problem directly: --update-refs.</p>\n<p>The --update-refs option is designed to automatically rebase your entire branch stack, updating all references in one go. So, instead of manually rebasing each branch, you can now do the following instead:</p>\n<pre>git fetch origin main:main<br>git checkout branch3  # Checkout the farthest branch in your stack<br>git rebase main --update-refs  # This will rebase the entire tree</pre>\n<p>Achieving it effectively in one command:</p>\n<pre>                  G'--H'--I'   &lt;-- branch3<br>                 /<br>       D'--E'--F'   &lt;-- branch2<br>      /<br>  M--S  &lt;-- main, origin/main</pre>\n<blockquote>Tip: If you want to avoid adding the --update-refs flag every time you rebase you can set this as the default behavior by adding the following configuration to your .gitconfig:</blockquote>\n<pre>git config --global --add rebase.updateRefs true</pre>\n<p>But we aren‚Äôt done yet. We still need to push them to the remote‚Ä¶ And nobody likes to do that one by one‚Ä¶</p>\n<h3>The Final Hurdle: Pushing Updated Branches</h3>\n<p>After rebasing, pushing all the updated branches can still be a bit of a hassle. Thankfully, you can loop through them with the for-each-ref command with the merged option and push them:</p>\n<pre>git fetch origin main:main &amp;&amp; \\<br>git rebase --update-refs main &amp;&amp; \\<br>git for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\<br>xargs -I {} git push --force-with-lease origin {}</pre>\n<blockquote>The for-each-ref combined with the --merged option only loops through your current tree without touching other unrelated branches. Use the force-with-lease to make sure you aren‚Äôt unintentionally force-pushing changes that you don‚Äôt have locally.</blockquote>\n<p>Voil√†! Your 2, 3, 5 or 1000 branches were all rebased and pushed to the remote in one command ü§Ø!</p>\n<p>These lines summarize the whole article:</p>\n<ol>\n<li>Create a new branch</li>\n<li>Commit. Commit even more.</li>\n<li>Create PR</li>\n<li>Branch out from this point, and repeat from step 1.</li>\n<li>When your branches are merged, rebase with update-refs and push.</li>\n</ol>\n<p>Now, every small step forward in your development can quickly enter the code base by creating a small PR. If the previous PR wasn‚Äôt merged yet, not much of a problem; you can continuously rebase and push until it is merged.</p>\n<h3>Wrapping up / TLDR;</h3>\n<p>By adopting this workflow, you can significantly reduce the complexity of your PRs. Instead of creating a single massive PR with thousands of commits, you can stack smaller branches, each representing a different stage of your work, and assign slices of it to different teammates. Make sure that the target branch for each increment isn‚Äôt the main one, but the previous branch in the tree.</p>\n<p>That way your teammates review only the relevant slice. Once the PR is approved, you can change back the target branch to main. At merging time, all the PR‚Äôs will enter like dominos since git has the avalibity to recognize the previously applied commit.</p>\n<p>This approach makes it easier for reviewers to digest your changes and allows you to ‚Äòparallelize‚Äô the review.</p>\n<p>Using the before-mentioned commands:</p>\n<pre>git checkout farestBranch<br>git fetch origin main:main &amp;&amp; \\<br>git rebase --update-refs main &amp;&amp; \\ <br>git for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\<br>xargs -I {} git push --force-with-lease origin {}</pre>\n<p>Ensures that rebasing and pushing updated branches is no longer a tedious, manual process. With this flow, you can focus more on writing quality code and less on managing your Git history.</p>\n<h3>Conclusion</h3>\n<p>Managing a stack of branches isn‚Äôt a headache anymore. By using Git‚Äôs --update-refs option and automating the push process, you can maintain a clean, organized codebase and make life easier for both yourself and your reviewers.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22df25b5fe50\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50\">Rebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NPUG8uIidQ6iUvKVmfqjzQ.jpeg\"></figure><h3>Introduction</h3>\n<p>Question: how many times did your development flow come to a standstill because a teammate didn‚Äôt review your Pull Request (PR)?<br>It is true that PRs should have Priority Zero in any normal company. But do we all work in normal companies üòÖ? And even if so, sometimes your teammates are just too busy doing something else, or honestly, don‚Äôt want to review that humongous PR, or whatever.</p>\n<p>Meet what I call the <strong>Continuous Incremental PR Chain:</strong> a flow I once answered someone in <a href=\"https://stackoverflow.com/questions/64324610/how-to-automatically-rebase-all-children-branches-onto-master-after-squashing-an/75858310#75858310\">Stack Overflow</a>, and now I refined it and shared it for you to use, based on continuously rebasing multiple stacked branches.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>One PR is Never Enough: A Tale of Two Developers</h3>\n<p>Let‚Äôs take the example of two developers. Developer A works on his branch. He creates several commits along the creation of his feature. At the end, he submits a pull request.</p>\n<pre>  A--B--C--D--E--F--G--H--I   &lt;-- branch1<br> /<br>M                            &lt;-- main</pre>\n<p><strong>Result:</strong> A large request with lots of changes since it contains a lot of commits. The unique reviewer postpones reviewing that branch to the end of the day because they don‚Äôt feel like it: it is too much code. Developer A doesn‚Äôt get to be a rockstar at the office: he might even chase his reviewer to get some feedback‚Äî <em>‚ÄúEvery Breath You Take‚Äù</em> plays in the background.</p>\n<p>In contrast, Developer B creates a branch for every few commits. He keeps on working, but when he makes progress uses a new branch on top of the previous one. Where Developer A had 10 commits in 1 PR, Developer B had 3 PRs with about 3 commits each. Developer B, as soon as he finishes a batch of commits, immediately creates a PR.</p>\n<pre>                  G--H--I   &lt;-- branch3 #PR to branch2<br>                 /    <br>          D--E--F   &lt;-- branch2 #PR to branch1<br>         /    <br>  A--B--C     &lt;-- branch1  #PR to main<br> /<br>M      &lt;-- main</pre>\n<p>Developer B can parallelize his feedback: he assigns each PR to a different team member. Each team member quickly reviews them, since they are small changes and ‚Äúdon‚Äôt require too much effort‚Äù. Also, now the review is split among more developers. Multithreading, anyone? Developer B gets higher quality feedback too, by getting different inputs. Thanks to his efficiency, Developer B finishes his work earlier‚Ää‚Äî‚Ää<em>‚ÄúI‚Äôm a Survivor‚Äù</em> plays in the background.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*01fxMUbhNDX6FAFxhQK0Yg.gif\"></figure><p>Which one would you rather be?</p>\n<h3>Stacked Branches and Constant Rebasing: A pain to maintain</h3>\n<p>Now that I convinced you to stack branches on top of each other, you might be wondering: ‚ÄúWhy isn‚Äôt everybody doing this?‚Äù And the answer is <em>rebasing</em>. Constantly rebasing several branches can be a pain in the ass. At least, without using --update-refs, a somewhat ‚Äúnew‚Äù option about to be 2 years old in October 2024. I was surprised by how many people at the office had never heard about it.</p>\n<p>After merging branch1 into main, or trying to update the whole tree against the remote, you‚Äôre left with a problem: you now have to manually rebase each subsequent branch onto main.</p>\n<pre>                  G--H--I   &lt;-- branch3<br>                 /    <br>          D--E--F   &lt;-- branch2<br>         /    <br>  A--B--C <br> /<br>M--S       &lt;-- main (branch1 changes squashed in S)</pre>\n<p>Typically, you would rebase each one like thisü§¢:</p>\n<pre>git fetch origin main:main<br>git checkout branch2<br>git rebase --onto master (SHA-1 of C)<br>git checkout branch3<br>git rebase --onto branch2 (SHA-1 of F)<br># repeat checkout + rebase for each branch</pre>\n<p>And so on. This can become tedious, especially when dealing with multiple branches.</p>\n<h3>Enter the --update-refs Option</h3>\n<p>Starting from Git 2.38 (and improved in 2.39), there‚Äôs a new flag that addresses this problem directly: --update-refs.</p>\n<p>The --update-refs option is designed to automatically rebase your entire branch stack, updating all references in one go. So, instead of manually rebasing each branch, you can now do the following instead:</p>\n<pre>git fetch origin main:main<br>git checkout branch3  # Checkout the farthest branch in your stack<br>git rebase main --update-refs  # This will rebase the entire tree</pre>\n<p>Achieving it effectively in one command:</p>\n<pre>                  G'--H'--I'   &lt;-- branch3<br>                 /<br>       D'--E'--F'   &lt;-- branch2<br>      /<br>  M--S  &lt;-- main, origin/main</pre>\n<blockquote>Tip: If you want to avoid adding the --update-refs flag every time you rebase you can set this as the default behavior by adding the following configuration to your .gitconfig:</blockquote>\n<pre>git config --global --add rebase.updateRefs true</pre>\n<p>But we aren‚Äôt done yet. We still need to push them to the remote‚Ä¶ And nobody likes to do that one by one‚Ä¶</p>\n<h3>The Final Hurdle: Pushing Updated Branches</h3>\n<p>After rebasing, pushing all the updated branches can still be a bit of a hassle. Thankfully, you can loop through them with the for-each-ref command with the merged option and push them:</p>\n<pre>git fetch origin main:main &amp;&amp; \\<br>git rebase --update-refs main &amp;&amp; \\<br>git for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\<br>xargs -I {} git push --force-with-lease origin {}</pre>\n<blockquote>The for-each-ref combined with the --merged option only loops through your current tree without touching other unrelated branches. Use the force-with-lease to make sure you aren‚Äôt unintentionally force-pushing changes that you don‚Äôt have locally.</blockquote>\n<p>Voil√†! Your 2, 3, 5 or 1000 branches were all rebased and pushed to the remote in one command ü§Ø!</p>\n<p>These lines summarize the whole article:</p>\n<ol>\n<li>Create a new branch</li>\n<li>Commit. Commit even more.</li>\n<li>Create PR</li>\n<li>Branch out from this point, and repeat from step 1.</li>\n<li>When your branches are merged, rebase with update-refs and push.</li>\n</ol>\n<p>Now, every small step forward in your development can quickly enter the code base by creating a small PR. If the previous PR wasn‚Äôt merged yet, not much of a problem; you can continuously rebase and push until it is merged.</p>\n<h3>Wrapping up / TLDR;</h3>\n<p>By adopting this workflow, you can significantly reduce the complexity of your PRs. Instead of creating a single massive PR with thousands of commits, you can stack smaller branches, each representing a different stage of your work, and assign slices of it to different teammates. Make sure that the target branch for each increment isn‚Äôt the main one, but the previous branch in the tree.</p>\n<p>That way your teammates review only the relevant slice. Once the PR is approved, you can change back the target branch to main. At merging time, all the PR‚Äôs will enter like dominos since git has the avalibity to recognize the previously applied commit.</p>\n<p>This approach makes it easier for reviewers to digest your changes and allows you to ‚Äòparallelize‚Äô the review.</p>\n<p>Using the before-mentioned commands:</p>\n<pre>git checkout farestBranch<br>git fetch origin main:main &amp;&amp; \\<br>git rebase --update-refs main &amp;&amp; \\ <br>git for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\<br>xargs -I {} git push --force-with-lease origin {}</pre>\n<p>Ensures that rebasing and pushing updated branches is no longer a tedious, manual process. With this flow, you can focus more on writing quality code and less on managing your Git history.</p>\n<h3>Conclusion</h3>\n<p>Managing a stack of branches isn‚Äôt a headache anymore. By using Git‚Äôs --update-refs option and automating the push process, you can maintain a clean, organized codebase and make life easier for both yourself and your reviewers.</p>\n<p>Happy coding!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22df25b5fe50\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50\">Rebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
      "enclosure": {},
      "categories": [
        "pull-request",
        "git",
        "version-control",
        "gitlab",
        "github"
      ]
    }
  ]
}
