{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@jonakrusze",
    "title": "Stories by Jonatan Kruszewski on Medium",
    "link": "https://medium.com/@jonakrusze?source=rss-9d104c42e755------2",
    "author": "",
    "description": "Stories by Jonatan Kruszewski on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/1*H7UvB9BbyPEkZkwgAht5tw.jpeg"
  },
  "items": [
    {
      "title": "Migrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0",
      "pubDate": "2024-12-31 21:37:40",
      "link": "https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ed7faec2a8b6",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Ch3\u003EMigrating a Large Sass Codebase in a Monorepo To SASS ^1.80.0\u003C/h3\u003E\n\u003Ch3\u003EStraight to the Point: Why Avoid the Migration Tool?\u003C/h3\u003E\n\u003Cp\u003EBefore we dive in, you might wonder, “Why wouldn’t you just use the \u003Ca href=\"https://www.npmjs.com/package/sass-migrator\"\u003ESass migration\u003C/a\u003E tool?”\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoqvvPBiZIX8grEvwWVeVA.jpeg\"\u003E\u003C/figure\u003E\u003Cp\u003EThe answer is simple: with 13K downloads per week, it just doesn’t meet the bar. Besides, after a first run, I realized I can’t pass a whole path where all my .scss files are— so, if I need to write a script to run the migration tool, I will just do it myself. That, and also:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/239/1*YkFzeDWY2Sc3AvLZz0F6Bw.png\"\u003E\u003Cfigcaption\u003EA small screenshot of how the migration tool failed gracefully.\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EAt the same time, manual control has its benefits: you can cleanup other stuff on the go, have what is called a human-on-the-loop and double check each time that the project compiles and builds properly. When you are in a monorepo, you would like to avoid breaking things unexpectedly.\u003C/p\u003E\n\u003Cp\u003EUndoubtedly, this made the process slower but more deliberate — and taught me a ton in the process.\u003C/p\u003E\n\u003Ch3\u003EWhy Migrate at All?\u003C/h3\u003E\n\u003Cp\u003EWith the release of Dart Sass 1.80.0, the use of @import is officially deprecated. Meaning, that all the usages need to be migrated to @use and @forward. On the positive side, it brings improved namespace management (whether you like it or not) and enhanced performance.\u003C/p\u003E\n\u003Cp\u003EFor those using @importthis means you will need to say goodbye to them. Instead, the @use allows you to load a Sass file once and avoid polluting the global namespace, while @forward enables sharing styles across multiple modules without duplicating code.\u003C/p\u003E\n\u003Cp\u003EI can’t say I wasn’t aware of this: it has been in their deprecation roadmap since \u003Cstrong\u003E1.23.0\u003C/strong\u003E, and the reason behind that change makes total sense: it solves the issue that global variables and mixins can conflict across stylesheets.\u003C/p\u003E\n\u003Ch3\u003EThe Challenges Faced\u003C/h3\u003E\n\u003Ch4\u003E\u003Cstrong\u003E1. I Didn’t Know How to Use the New Syntax\u003C/strong\u003E\u003C/h4\u003E\n\u003Cp\u003EThe hardest part was simply understanding how to implement @use and @forward effectively. I was so used to @import that the new syntax felt like a whole different world.\u003C/p\u003E\n\u003Cp\u003EUse @use when you want to load a file and bring its variables, mixins, or functions into your current file, and @forward when you want to re-export those styles from one file to another, making them available without direct imports.\u003C/p\u003E\n\u003Cp\u003E@use usage:\u003C/p\u003E\n\u003Cpre\u003E// _colors.scss\u003Cbr\u003E$primary-color: #3498db;\u003Cbr\u003E\u003Cbr\u003E// styles.scss\u003Cbr\u003E@use 'colors'; // instead of @import 'colors';\u003Cbr\u003E\u003Cbr\u003Ebody {\u003Cbr\u003E  background-color: colors.$primary-color; // instead of $primary.color\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003E@forward usage:\u003C/p\u003E\n\u003Cpre\u003E// _abstract.scss\u003Cbr\u003E@use 'colors';\u003Cbr\u003E@use 'spacing';\u003Cbr\u003E\u003Cbr\u003E// _index.scss (re-exports abstract file)\u003Cbr\u003E@forward 'abstract';\u003Cbr\u003E\u003Cbr\u003E// styles.scss\u003Cbr\u003E@use 'index';\u003Cbr\u003E\u003Cbr\u003E.header {\u003Cbr\u003E  background-color: index.$primary-color;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Plan where and how you would change the most important files, then execute.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E2. Don’t Do It in One Go.\u003C/h4\u003E\n\u003Cp\u003EMigrating everything at once can be overwhelming. Split the work by sections, files, folders or whatever works for you. I used about nine branches to split the work, making it easier to test and control.\u003C/p\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Go step by step.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E3. Watch Out for Errors\u003C/h4\u003E\n\u003Cp\u003EWhen you’re in a monorepo, nothing lives in isolation. Modifying one SCSS file often unintentionally breaks something else in another package. Dependencies are everywhere, and fixing issues sometimes feels like playing Whac-A-Mole.\u003C/p\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Constantly check that the dev server compiles and the project builds. Read the errors and fix them.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E4. Scalability vs. Speed\u003C/h4\u003E\n\u003Cp\u003EThere’s a natural tension between wanting to refactor everything for long-term scalability and the pressure to move quickly. Sometimes, you have to choose \u003Cstrong\u003Epragmatism over perfection\u003C/strong\u003E.\u003C/p\u003E\n\u003Cp\u003EWhile I encountered several other things to fix on the fly, I kept it minimal. The purpose was to migrate, not to fix what should have been done already. Keeping the focus on the migration is what ultimately brought the most value.\u003C/p\u003E\n\u003Cp\u003ENot every file needs a full makeover. If it’s something small and can be fixed quickly, go ahead. Otherwise, follow a ‘good enough’ approach — leaving unrelated issues for later (or never).\u003C/p\u003E\n\u003Ch3\u003EInsights and Wins\u003C/h3\u003E\n\u003Ch4\u003E1. Modularization Saved Me\u003C/h4\u003E\n\u003Cp\u003EOne of the best decisions made a while ago was to break the SCSS into smaller, modular chunks. Instead of one massive file, the project had component-specific styles. This made it easier to refactor and test changes without affecting other parts of the codebase.\u003C/p\u003E\n\u003Ch4\u003E2. Gradual Refactoring Works\u003C/h4\u003E\n\u003Cp\u003ERather than overhauling everything at once, I focused on refactoring one section at a time. This allowed me to tackle small, manageable tasks and minimize the risk of breaking something unexpectedly while keeping progress moving forward.\u003C/p\u003E\n\u003Ch4\u003E3. \u003Cstrong\u003ETaking Initiative Pays Off\u003C/strong\u003E\n\u003C/h4\u003E\n\u003Cp\u003ELeading a migration initiative accelerates your learning and makes you the go-to expert on the process. It also helps free other developers from a slow, fragmented migration by streamlining the work and creating momentum. Stepping up to solve problems, drive progress, and manage change is an essential quality of strong leadership.\u003C/p\u003E\n\u003Ch3\u003EThings I’d Do Differently Next Time\u003C/h3\u003E\n\u003Ch4\u003E1. \u003Cstrong\u003EPlan Ahead\u003C/strong\u003E\n\u003C/h4\u003E\n\u003Cp\u003EA bit more upfront planning would’ve saved me time.\u003C/p\u003E\n\u003Ch4\u003E2. Automate Where You Can\u003C/h4\u003E\n\u003Cp\u003EWhile I mainly relied on search and replace functions, maybe next time I could write a small script to automate the job. The codebase wasn’t large enough to justify it, but maybe other situations or repos might.\u003C/p\u003E\n\u003Ch4\u003E3. Test, Test, Test\u003C/h4\u003E\n\u003Cp\u003EI learned the hard way that even small changes can have big impacts. Comprehensive tests (both unit and visual) caught countless issues I would’ve otherwise missed. Having a robust UI testing tool is a good long term investment.\u003C/p\u003E\n\u003Ch3\u003EClosing Thoughts\u003C/h3\u003E\n\u003Cp\u003EMigrating a large SCSS codebase without a tool isn’t for everyone, but it’s definitely doable with the right mindset and approach. You’ll face roadblocks, no doubt, but you’ll also emerge with a deeper understanding.\u003C/p\u003E\n\u003Cp\u003EAnd hey, if you’re reading this and thinking, “Wow, that sounds like a lot of work,” you’re absolutely right. But trust me, the effort is worth it. Your future self (and your teammates) will thank you.\u003C/p\u003E\n\u003Cp\u003EHappy coding — and good luck on your migration journey!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ed7faec2a8b6\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6\"\u003EMigrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Ch3\u003EMigrating a Large Sass Codebase in a Monorepo To SASS ^1.80.0\u003C/h3\u003E\n\u003Ch3\u003EStraight to the Point: Why Avoid the Migration Tool?\u003C/h3\u003E\n\u003Cp\u003EBefore we dive in, you might wonder, “Why wouldn’t you just use the \u003Ca href=\"https://www.npmjs.com/package/sass-migrator\"\u003ESass migration\u003C/a\u003E tool?”\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoqvvPBiZIX8grEvwWVeVA.jpeg\"\u003E\u003C/figure\u003E\u003Cp\u003EThe answer is simple: with 13K downloads per week, it just doesn’t meet the bar. Besides, after a first run, I realized I can’t pass a whole path where all my .scss files are— so, if I need to write a script to run the migration tool, I will just do it myself. That, and also:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/239/1*YkFzeDWY2Sc3AvLZz0F6Bw.png\"\u003E\u003Cfigcaption\u003EA small screenshot of how the migration tool failed gracefully.\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EAt the same time, manual control has its benefits: you can cleanup other stuff on the go, have what is called a human-on-the-loop and double check each time that the project compiles and builds properly. When you are in a monorepo, you would like to avoid breaking things unexpectedly.\u003C/p\u003E\n\u003Cp\u003EUndoubtedly, this made the process slower but more deliberate — and taught me a ton in the process.\u003C/p\u003E\n\u003Ch3\u003EWhy Migrate at All?\u003C/h3\u003E\n\u003Cp\u003EWith the release of Dart Sass 1.80.0, the use of @import is officially deprecated. Meaning, that all the usages need to be migrated to @use and @forward. On the positive side, it brings improved namespace management (whether you like it or not) and enhanced performance.\u003C/p\u003E\n\u003Cp\u003EFor those using @importthis means you will need to say goodbye to them. Instead, the @use allows you to load a Sass file once and avoid polluting the global namespace, while @forward enables sharing styles across multiple modules without duplicating code.\u003C/p\u003E\n\u003Cp\u003EI can’t say I wasn’t aware of this: it has been in their deprecation roadmap since \u003Cstrong\u003E1.23.0\u003C/strong\u003E, and the reason behind that change makes total sense: it solves the issue that global variables and mixins can conflict across stylesheets.\u003C/p\u003E\n\u003Ch3\u003EThe Challenges Faced\u003C/h3\u003E\n\u003Ch4\u003E\u003Cstrong\u003E1. I Didn’t Know How to Use the New Syntax\u003C/strong\u003E\u003C/h4\u003E\n\u003Cp\u003EThe hardest part was simply understanding how to implement @use and @forward effectively. I was so used to @import that the new syntax felt like a whole different world.\u003C/p\u003E\n\u003Cp\u003EUse @use when you want to load a file and bring its variables, mixins, or functions into your current file, and @forward when you want to re-export those styles from one file to another, making them available without direct imports.\u003C/p\u003E\n\u003Cp\u003E@use usage:\u003C/p\u003E\n\u003Cpre\u003E// _colors.scss\u003Cbr\u003E$primary-color: #3498db;\u003Cbr\u003E\u003Cbr\u003E// styles.scss\u003Cbr\u003E@use 'colors'; // instead of @import 'colors';\u003Cbr\u003E\u003Cbr\u003Ebody {\u003Cbr\u003E  background-color: colors.$primary-color; // instead of $primary.color\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003E@forward usage:\u003C/p\u003E\n\u003Cpre\u003E// _abstract.scss\u003Cbr\u003E@use 'colors';\u003Cbr\u003E@use 'spacing';\u003Cbr\u003E\u003Cbr\u003E// _index.scss (re-exports abstract file)\u003Cbr\u003E@forward 'abstract';\u003Cbr\u003E\u003Cbr\u003E// styles.scss\u003Cbr\u003E@use 'index';\u003Cbr\u003E\u003Cbr\u003E.header {\u003Cbr\u003E  background-color: index.$primary-color;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Plan where and how you would change the most important files, then execute.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E2. Don’t Do It in One Go.\u003C/h4\u003E\n\u003Cp\u003EMigrating everything at once can be overwhelming. Split the work by sections, files, folders or whatever works for you. I used about nine branches to split the work, making it easier to test and control.\u003C/p\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Go step by step.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E3. Watch Out for Errors\u003C/h4\u003E\n\u003Cp\u003EWhen you’re in a monorepo, nothing lives in isolation. Modifying one SCSS file often unintentionally breaks something else in another package. Dependencies are everywhere, and fixing issues sometimes feels like playing Whac-A-Mole.\u003C/p\u003E\n\u003Cp\u003E\u003Cem\u003ETip: Constantly check that the dev server compiles and the project builds. Read the errors and fix them.\u003C/em\u003E\u003C/p\u003E\n\u003Ch4\u003E4. Scalability vs. Speed\u003C/h4\u003E\n\u003Cp\u003EThere’s a natural tension between wanting to refactor everything for long-term scalability and the pressure to move quickly. Sometimes, you have to choose \u003Cstrong\u003Epragmatism over perfection\u003C/strong\u003E.\u003C/p\u003E\n\u003Cp\u003EWhile I encountered several other things to fix on the fly, I kept it minimal. The purpose was to migrate, not to fix what should have been done already. Keeping the focus on the migration is what ultimately brought the most value.\u003C/p\u003E\n\u003Cp\u003ENot every file needs a full makeover. If it’s something small and can be fixed quickly, go ahead. Otherwise, follow a ‘good enough’ approach — leaving unrelated issues for later (or never).\u003C/p\u003E\n\u003Ch3\u003EInsights and Wins\u003C/h3\u003E\n\u003Ch4\u003E1. Modularization Saved Me\u003C/h4\u003E\n\u003Cp\u003EOne of the best decisions made a while ago was to break the SCSS into smaller, modular chunks. Instead of one massive file, the project had component-specific styles. This made it easier to refactor and test changes without affecting other parts of the codebase.\u003C/p\u003E\n\u003Ch4\u003E2. Gradual Refactoring Works\u003C/h4\u003E\n\u003Cp\u003ERather than overhauling everything at once, I focused on refactoring one section at a time. This allowed me to tackle small, manageable tasks and minimize the risk of breaking something unexpectedly while keeping progress moving forward.\u003C/p\u003E\n\u003Ch4\u003E3. \u003Cstrong\u003ETaking Initiative Pays Off\u003C/strong\u003E\n\u003C/h4\u003E\n\u003Cp\u003ELeading a migration initiative accelerates your learning and makes you the go-to expert on the process. It also helps free other developers from a slow, fragmented migration by streamlining the work and creating momentum. Stepping up to solve problems, drive progress, and manage change is an essential quality of strong leadership.\u003C/p\u003E\n\u003Ch3\u003EThings I’d Do Differently Next Time\u003C/h3\u003E\n\u003Ch4\u003E1. \u003Cstrong\u003EPlan Ahead\u003C/strong\u003E\n\u003C/h4\u003E\n\u003Cp\u003EA bit more upfront planning would’ve saved me time.\u003C/p\u003E\n\u003Ch4\u003E2. Automate Where You Can\u003C/h4\u003E\n\u003Cp\u003EWhile I mainly relied on search and replace functions, maybe next time I could write a small script to automate the job. The codebase wasn’t large enough to justify it, but maybe other situations or repos might.\u003C/p\u003E\n\u003Ch4\u003E3. Test, Test, Test\u003C/h4\u003E\n\u003Cp\u003EI learned the hard way that even small changes can have big impacts. Comprehensive tests (both unit and visual) caught countless issues I would’ve otherwise missed. Having a robust UI testing tool is a good long term investment.\u003C/p\u003E\n\u003Ch3\u003EClosing Thoughts\u003C/h3\u003E\n\u003Cp\u003EMigrating a large SCSS codebase without a tool isn’t for everyone, but it’s definitely doable with the right mindset and approach. You’ll face roadblocks, no doubt, but you’ll also emerge with a deeper understanding.\u003C/p\u003E\n\u003Cp\u003EAnd hey, if you’re reading this and thinking, “Wow, that sounds like a lot of work,” you’re absolutely right. But trust me, the effort is worth it. Your future self (and your teammates) will thank you.\u003C/p\u003E\n\u003Cp\u003EHappy coding — and good luck on your migration journey!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ed7faec2a8b6\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/migrating-a-large-scss-codebase-in-a-monorepo-to-sass-1-80-0-ed7faec2a8b6\"\u003EMigrating a Large SCSS Codebase in a Monorepo To SASS ^1.80.0\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "scss",
        "javascript",
        "sass",
        "monorepo",
        "react"
      ]
    },
    {
      "title": "Learn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics",
      "pubDate": "2024-12-17 21:08:18",
      "link": "https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ce6844f008ad",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cp\u003EWant to learn TypeScript in one post in the shortest time possible? You can. With examples. Lots of them. Save yourself lots of hours by just reading this comprehensive guide.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"Typescript logo with a crown\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJ73ynaAwbzLqZh-Nsf7Jw.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003ETS Snippets– A Quick Learning Approach\u003C/h3\u003E\n\u003Cp\u003EThis guide features minimal text and focuses on bite-sized code examples designed to quickly elevate your proficiency in TypeScript.\u003C/p\u003E\n\u003Cblockquote\u003E\u003Cem\u003EWhy snippets?\u003C/em\u003E\u003C/blockquote\u003E\n\u003Cblockquote\u003EBecause examples are easier to digest than extensive documentation, keeping the essentials front and center without the extra layers. This guide is selective and opinionated — it won’t replace full documentation, but it will get you writing TypeScript fast. Really fast.\u003C/blockquote\u003E\n\u003Cp\u003EThink of it as a jumpstart. In under an hour or two, this guide takes you from zero to coding, prioritizing simplicity and practicality.\u003C/p\u003E\n\u003Cp\u003ETopics are categorized so you can move seamlessly between sections.\u003C/p\u003E\n\u003Ch3\u003EWhat to Expect from This Mega Post\u003C/h3\u003E\n\u003Cp\u003EIn the upcoming sections, we will delve deeper into the following areas:\u003C/p\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EBasic Usage (BU)\u003C/strong\u003E: In this section, we’ll cover TypeScript’s essential building blocks, like setting up types, defining functions and more. It’s everything you need to confidently start writing TypeScript code.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ETypes (TPS), Interfaces (IN), Enums (EN)\u003C/strong\u003E: We’ll explore TypeScript’s tools for defining structured data, covering when to use types, interfaces, and enums to make your code more readable and robust.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EInference (INFR)\u003C/strong\u003E: Here, we’ll look at TypeScript’s type inference capabilities and learn how to guide the compiler when it makes assumptions that don’t align with your intentions.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EClasses (CLS), Deriving Types from Variables (DTV) and Generics (GEN)\u003C/strong\u003E: This section will dive into TypeScript’s object-oriented programming features, covering how to work with classes, derive new types from existing declarations, and use generics to write flexible and reusable code.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EUsing with React (REA)\u003C/strong\u003E: We’ll dive into typing Components. Yep, that’s it.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EThe Weird Parts (TWP) and Common Pitfalls (CPTF)\u003C/strong\u003E: We’ll dive into some quirky aspects of TypeScript that may trip you up, highlighting common pitfalls and how to avoid them for smoother coding.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Cp\u003EBy the end, you’ll have not only a deeper understanding of TypeScript but the practical know-how to apply it within your own projects and teams.\u003C/p\u003E\n\u003Cp\u003EYou won’t be the TS hero of your team, but no one will guess you started only 40 minutes ago.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003ELet’s dive in!\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003E01. Basic Usage (BU)\u003C/h3\u003E\n\u003Ch4\u003EBU.01: Basic Types in TS\u003C/h4\u003E\n\u003Cpre\u003Elet example1: string = \"Hello World!\";\u003Cbr\u003Elet example2: number = 42;\u003Cbr\u003Elet example3: boolean = true;\u003Cbr\u003Elet example4: symbol = Symbol();\u003Cbr\u003Elet example5: bigint = 123n;\u003C/pre\u003E\n\u003Ch4\u003EBU.02: Functions — Basic notation\u003C/h4\u003E\n\u003Cpre\u003Efunction calculateSpeed(distanceInKilometers: number, timeInHours: number): number {\u003Cbr\u003E  return distanceInKilometers / timeInHours;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst calculateFuelEfficiency = (kilometers: number, liters: number): number =&gt; kilometers / liters;\u003Cbr\u003Econst logCarInfo = (info: string): void =&gt; console.log(info);\u003C/pre\u003E\n\u003Ch4\u003EBU.03: Functions — Optional parameters\u003C/h4\u003E\n\u003Cpre\u003Econst formatCarDescription = (brand: string, model?: string): string =&gt; {\u003Cbr\u003E  if (!model) {\u003Cbr\u003E    return brand;\u003Cbr\u003E  }\u003Cbr\u003E  return `${brand} ${model}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.04: Functions — Default parameters\u003C/h4\u003E\n\u003Cpre\u003Econst createCar = (brand: string, year: number = 2024): string =&gt; {\u003Cbr\u003E  return `${brand}, Year: ${year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.05: Objects: Typing Object Literals (inline)\u003C/h4\u003E\n\u003Cpre\u003Econst displayCarInfo = (car: { brand: string; year: number }): string =&gt; {\u003Cbr\u003E  return `${car.brand}, Year: ${car.year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.06: Objects: Typing Objects in own type\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst displayCarInfo = (car: Car): string =&gt; {\u003Cbr\u003E  return `${car.brand}, Year: ${car.year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.07: Objects: Making properties optional\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model?: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst describeCar = (car: Car): void =&gt; {\u003Cbr\u003E  const { brand, model } = car;\u003Cbr\u003E  if (model) {\u003Cbr\u003E    console.log(`${brand} ${model}`);\u003Cbr\u003E    return;\u003Cbr\u003E  }\u003Cbr\u003E  console.log(`${brand}`);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.08: Objects: Using Record for Dynamically Typing\u003C/h4\u003E\n\u003Cpre\u003Econst carFeatures: Record&lt;string, string&gt; = {};\u003Cbr\u003E\u003Cbr\u003EcarFeatures.color = \"Red\";\u003Cbr\u003EcarFeatures.transmission = \"Automatic\";\u003Cbr\u003EcarFeatures.condition = \"New\";\u003C/pre\u003E\n\u003Ch4\u003EBU.09: Arrays — Basic notation\u003C/h4\u003E\n\u003Cp\u003EPrefer the [] syntax instead of the Array&lt;&gt; one\u003C/p\u003E\n\u003Cpre\u003Etype CarInventory = {\u003Cbr\u003E  dealerId: string;\u003Cbr\u003E  carBrands: string[]; // alternatively, Array&lt;string&gt;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.10: Arrays of objects\u003C/h4\u003E\n\u003Cp\u003EPrefer to define array of objects as types\u003C/p\u003E\n\u003Cpre\u003Etype Feature = {\u003Cbr\u003E  name: string;\u003Cbr\u003E  description: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype CarModel = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  features: Feature[];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst processCarModel = (carModel: CarModel) =&gt; {\u003Cbr\u003E  // Do something with the car model in here\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EprocessCarModel({\u003Cbr\u003E  brand: \"Toyota\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E  features: [\u003Cbr\u003E    { name: \"Safety Rating\", description: \"5 stars\" },\u003Cbr\u003E    { name: \"Fuel Efficiency\", description: \"30 km/L\" },\u003Cbr\u003E  ],\u003Cbr\u003E});\u003C/pre\u003E\n\u003Ch4\u003EBU.11: Rest params\u003C/h4\u003E\n\u003Cp\u003ETreat them as array\u003C/p\u003E\n\u003Cpre\u003Eexport function listCarModels(...models: string[]): string {\u003Cbr\u003E  return models.join(\", \");\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.12: Tuples\u003C/h4\u003E\n\u003Cp\u003ETuples are arrays of fixed length. Not necessarily 2 like in some coding languages. For example, useState returns a tuple.\u003C/p\u003E\n\u003Cpre\u003Econst setCarDetails = (car: [string, number]) =&gt; {\u003Cbr\u003E  const brand = car[0];\u003Cbr\u003E  const year = car[1];\u003Cbr\u003E  console.log(`Car: ${brand}, Year: ${year}`);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EsetCarDetails([\"Toyota\", 2024]);\u003C/pre\u003E\n\u003Ch4\u003EBU.13: Using Optional Tuple members in TS\u003C/h4\u003E\n\u003Cpre\u003Econst setCarSpecs = (specs: [string, number, number?]) =&gt; {\u003Cbr\u003E  const brand = specs[0];\u003Cbr\u003E  const year = specs[1];\u003Cbr\u003E  const kilometrage = specs[2];\u003Cbr\u003E\u003Cbr\u003E  console.log(`Car: ${brand}, Year: ${year}${kilometrage !== undefined ? `, Kilometrage: ${kilometrage} km` : ''}`);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EsetCarSpecs([\"Honda\", 2024]);\u003Cbr\u003EsetCarSpecs([\"Ford\", 2023, 15000]);\u003C/pre\u003E\n\u003Ch4\u003EBU.14: Using `any`\u003C/h4\u003E\n\u003Cp\u003EDon’t. The only placed allowed is when catching an error.\u003C/p\u003E\n\u003Cpre\u003Etry {\u003Cbr\u003E  someDangerousFunctionThatMightThrow();\u003Cbr\u003E} catch (error: any) { // Acceptable use of `any`\u003Cbr\u003E  console.error(\"Caught an error:\", error.message);\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.15: Typing an Event Listener\u003C/h4\u003E\n\u003Cp\u003EVoid just doesn’t care what you return. Better than any for functions.\u003C/p\u003E\n\u003Cpre\u003Econst addClickEventListener = (listener: (this: Document, ev: MouseEvent) =&gt; void) =&gt; {\u003Cbr\u003E  document.addEventListener(\"click\", listener);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EaddClickEventListener(() =&gt; {\u003Cbr\u003E  console.log(\"Clicked!\");\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003E// TypeScript will catch this as an error\u003Cbr\u003EaddClickEventListener(\u003Cbr\u003E  // @ts-expect-error\u003Cbr\u003E  \"abc\" // Incorrect type\u003Cbr\u003E);\u003C/pre\u003E\n\u003Ch4\u003EBU.16: Typing sets\u003C/h4\u003E\n\u003Cpre\u003Econst carBrands = new Set&lt;string&gt;();\u003C/pre\u003E\n\u003Ch4\u003EBU.17: Typing Maps\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carMap = new Map&lt;number, Car&gt;();\u003Cbr\u003E\u003Cbr\u003EcarMap.set(1, { brand: \"Toyota\", year: 2024 });\u003Cbr\u003EcarMap.set(2, { brand: \"Ford\", year: 2023 });\u003C/pre\u003E\n\u003Ch4\u003EBU.18: Typing Json.parse\u003C/h4\u003E\n\u003Cpre\u003Econst parsedCarData: { brand: string; year: number; } = JSON.parse('{\"brand\": \"Honda\", \"year\": 2024}');\u003C/pre\u003E\n\u003Cpre\u003Easync function fetchData(): Promise&lt;number&gt; {\u003Cbr\u003E  const response = await fetch('https://api.example.com/data');\u003Cbr\u003E  const data = await response.json(); //option b, type data\u003Cbr\u003E  return data;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.20: Using Union types\u003C/h4\u003E\n\u003Cp\u003EUnion types are the “or” operator of TypeScript:\u003C/p\u003E\n\u003Cpre\u003Efunction getCarDetails(brand: string | null) {\u003Cbr\u003E  if (brand !== null) {\u003Cbr\u003E    return `Car: ${brand}`;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  return \"Unknown Car\";\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003E02. Types, Interfaces, Enums\u003C/h3\u003E\n\u003Ch4\u003EObjects introduction\u003C/h4\u003E\n\u003Cp\u003EObjects in TypeScript can be typed using either type or interface. There is a never ending war about “which one is best” the truth is, just pick one and be consistent.\u003C/p\u003E\n\u003Cp\u003EBoth are similar, but type is more flexible for unions and complex types, while interface is extendable and better for defining class structures.\u003C/p\u003E\n\u003Cp\u003EFor the sake of this opinionated guide, we will prefer types, but also will explain interfaces.\u003C/p\u003E\n\u003Ch4\u003ETypes vs. Interfaces\u003C/h4\u003E\n\u003Cul\u003E\n\u003Cli\u003EInterfaces uses extend, Types uses &amp; to add properties to a definition\u003C/li\u003E\n\u003Cli\u003ETypes match React’s declarative syntax a little bit better\u003C/li\u003E\n\u003Cli\u003EInterfaces can only type classes or objects. Types can represent other elements besides objects.\u003C/li\u003E\n\u003Cli\u003EInterfaces are slightly more performant\u003C/li\u003E\n\u003Cli\u003EInterfaces can extend several interfaces\u003C/li\u003E\n\u003Cli\u003EInterfaces can be declared several times in the same scope. The ultimate definition will be the merge of all the interfaces. Types will error with same declarations in the same scope. Forces you to use the &amp; to create mixed types.\u003C/li\u003E\n\u003Cli\u003E\u003Cstrong\u003EMostly it’s a matter of style.\u003C/strong\u003E\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch4\u003ETypes\u003C/h4\u003E\n\u003Ch4\u003ETPS.01: A basic example\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst myCar: Car = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ETPS.02: Extending a type — Using intersections\u003C/h4\u003E\n\u003Cp\u003EYou can use the &amp; to extend an existing type. That is call an \u003Cem\u003Eintersection\u003C/em\u003E. Prefer composability, using types that ‘extend’ from other types rather than adding optional props that might create ambiguity (see Unions and Narrowing)\u003C/p\u003E\n\u003Cpre\u003Etype Vehicle = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ElectricVehicle = Vehicle &amp; {\u003Cbr\u003E  batteryCapacity: number; // in kWh\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst teslaModelS: ElectricVehicle = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ETPS.03: Typing objects dynamically\u003C/h4\u003E\n\u003Cp\u003ESometimes you want the object to have dynamic keys, but that they all match a format. For example, all the keys should be a number. For that, you can use Record&lt;&gt;\u003C/p\u003E\n\u003Cpre\u003Econst carRatings: Record&lt;string, number&gt; = {};\u003Cbr\u003E\u003Cbr\u003EcarRatings.performance = 95;\u003Cbr\u003EcarRatings.safety = 90;\u003Cbr\u003EcarRatings.comfort = 85;\u003C/pre\u003E\n\u003Ch4\u003ETPS.04: Supporting different types of Keys for Maps and Sets\u003C/h4\u003E\n\u003Cp\u003ETS has an own type that is the union of string | number | symbol. It is named PropertyKey.\u003C/p\u003E\n\u003Cpre\u003E// PropertyKey = string | number | symbol\u003Cbr\u003E\u003Cbr\u003Econst carMap = new Map&lt;PropertyKey, string&gt;();\u003Cbr\u003E\u003Cbr\u003Econst key1: string = \"brand\";\u003Cbr\u003Econst key2: number = 2024;\u003Cbr\u003Econst key3: symbol = Symbol(\"uniqueModel\");\u003Cbr\u003E\u003Cbr\u003EcarMap.set(key1, \"Toyota\");\u003Cbr\u003EcarMap.set(key2, \"Camry\");\u003Cbr\u003EcarMap.set(key3, \"SpecialEdition\");\u003C/pre\u003E\n\u003Ch4\u003ETPS.05: Restricting keys of an object to a list\u003C/h4\u003E\n\u003Cp\u003ELet’s say you want to generate an object where the keys are dynamic but restricted to a list. For example:\u003C/p\u003E\n\u003Cpre\u003Econst carConfigurations = {\u003Cbr\u003E  sedan: {\u003Cbr\u003E    fuelType: \"petrol\",\u003Cbr\u003E    doors: 4,\u003Cbr\u003E  },\u003Cbr\u003E  suv: {\u003Cbr\u003E    fuelType: \"diesel\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E  hatchback: {\u003Cbr\u003E    fuelType: \"electric\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAs you can see they all follow the same structure, yet you may want to add other environments. The way to type is to create a list of those possible keys:\u003C/p\u003E\n\u003Cpre\u003Etype CarType = 'sedan' | 'suv' | 'hatchback';\u003Cbr\u003E\u003Cbr\u003Etype CarConfigurations = {\u003Cbr\u003E  [Type in CarType]: {\u003Cbr\u003E    fuelType: string;\u003Cbr\u003E    doors: number;\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carConfigurations: CarConfigurations = {\u003Cbr\u003E  sedan: {\u003Cbr\u003E    fuelType: \"petrol\",\u003Cbr\u003E    doors: 4,\u003Cbr\u003E  },\u003Cbr\u003E  suv: {\u003Cbr\u003E    fuelType: \"diesel\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E  hatchback: {\u003Cbr\u003E    fuelType: \"electric\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAlternatively, this could be annotated too as:\u003C/p\u003E\n\u003Cpre\u003Etype CarType = 'sedan' | 'suv' | 'hatchback';\u003Cbr\u003E\u003Cbr\u003Etype Configurations = Record&lt;\u003Cbr\u003E  CarType,\u003Cbr\u003E  { apiBaseUrl: string; timeout: number; }\u003Cbr\u003E &gt;\u003Cbr\u003E\u003Cbr\u003Econst carConfigurations: CarConfigurations = {...} // the same object as before\u003C/pre\u003E\n\u003Ch4\u003ETPS.06: Creating a type that is a ‘slice’ from another one: Pick\u003C/h4\u003E\n\u003Cp\u003EPick allows to create a ‘slice’ of a type. Prefer using type composition (see second example). You can’t pick a key that doesn’t exist on the type.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  color: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype PickedCar = Pick&lt;Car, 'brand' | 'model'&gt;;\u003Cbr\u003E\u003Cbr\u003Econst TeslaCar: PickedCar = {brand: 'Tesla', model: 'CyberTruck'}\u003C/pre\u003E\n\u003Ch4\u003ETPS.07: Creating a type that is a ‘slice’ from another one: Omit\u003C/h4\u003E\n\u003Cp\u003ELike pick, but the opposite. Instead of keeping the marked keys, it removes them. Omit won’t complain if you pass a key that wasn’t declared 🤷\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  color: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst addCar = (carInfo: Omit&lt;Car, 'id'&gt;) =&gt; {\u003Cbr\u003E  // Do something with the carInfo\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EaddCar({\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E  color: \"Metallic\",\u003Cbr\u003E});\u003C/pre\u003E\n\u003Ch4\u003ETPS.08: Creating a type that is a ‘slice’ from another one: Omit in unions\u003C/h4\u003E\n\u003Cp\u003EOmit isn’t distributive.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  capacity: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Motorcycle = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  cc: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Car | Truck | Motorcycle;\u003Cbr\u003E\u003Cbr\u003Etype VehicleWithoutId = Omit&lt;Vehicle, \"id\"&gt;;\u003C/pre\u003E\n\u003Cp\u003EThe reason this happens is due to a technicality of how Omit processes union types.\u003C/p\u003E\n\u003Cp\u003EOmit doesn’t iterate over every member of the union. Instead, it squashes the union into a structure it comprehends, and then operates on this new construct. As a result, the outcome is different than what you might expect. To remedy this, let’s take a look at DistributiveOmit\u003C/p\u003E\n\u003Ch4\u003ETPS.09: DistributiveOmit\u003C/h4\u003E\n\u003Cp\u003EFollowing the previous snippet, if you want to create an union where ‘id’ is ommited in each case, you can apply a distributive omit:\u003C/p\u003E\n\u003Cpre\u003Etype DistributiveOmit&lt;T, K extends PropertyKey&gt; = T extends any\u003Cbr\u003E  ? Omit&lt;T, K&gt;\u003Cbr\u003E  : never;\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Car | Truck | Motorcycle;\u003Cbr\u003Etype VehicleWithoutId = DistributiveOmit&lt;Vehicle, \"id\"&gt;;\u003C/pre\u003E\n\u003Ch4\u003ETPS.10: Using Partials\u003C/h4\u003E\n\u003Cp\u003ESometimes, for example updates, you only want to pass 1 property to update.\u003C/p\u003E\n\u003Cp\u003EIt is tempting to fix it by making all props optional with ? but that would change the definition of Product, and that isn’t what we want.\u003C/p\u003E\n\u003Cp\u003EThe solution is to use Partial . Partial makes all the definition optional, like if it where with ?.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  description: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst updateCar = (id: number, carInfo: Partial&lt;Omit&lt;Car, \"id\"&gt;&gt;) =&gt; {\u003Cbr\u003E  // Do something with the carInfo\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  year: 2024,\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ENote: Partial doesn’t support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.\u003C/p\u003E\n\u003Ch4\u003ETPS.11: Using Required\u003C/h4\u003E\n\u003Cp\u003EThe Required utility type in TypeScript does the opposite of Partial—it makes all properties mandatory. This is useful when you want to ensure that every property of an object must be provided.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year?: number; \u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst createCar = (carInfo: Required&lt;Car&gt;) =&gt; {\u003Cbr\u003E  console.log(carInfo);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EcreateCar({\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  year: 2024\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ENote: Same as Partial, Required doesn’t support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.\u003C/p\u003E\n\u003Ch4\u003ETPS.12: Partial, Required, Pick, mixed together\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year?: number; // Optional\u003Cbr\u003E  color?: string; // Optional\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Make only 'brand' and 'model' required, while 'id', 'year', and 'color' remain optional\u003Cbr\u003Etype PartialCarWithRequired = Partial&lt;Car&gt; &amp; Required&lt;Pick&lt;Car, 'brand' | 'model'&gt;&gt;;\u003Cbr\u003E\u003Cbr\u003Econst createCar: PartialCarWithRequired = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  // id, year, and color can be omitted\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(createCar);\u003C/pre\u003E\n\u003Ch4\u003ETPS.13: Using Readonly\u003C/h4\u003E\n\u003Cp\u003EThe Readonly utility type allows you to create a type with all properties of an existing type set to \u003Cstrong\u003Ereadonly\u003C/strong\u003E. This means that the properties cannot be reassigned, providing a way to enforce immutability in your data structures. This is particularly useful when you want to ensure that certain data should not be changed after it has been created.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Create a readonly version of Car\u003Cbr\u003Etype ReadonlyCar = Readonly&lt;Car&gt;;\u003Cbr\u003E\u003Cbr\u003Econst car: ReadonlyCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EUsing it in arrays:\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ReadonlyCarArray = readonly Car[];\u003Cbr\u003E//alternatively \u003Cbr\u003E//type ReadonlyCarArray = ReadonlyArray&lt;Car&gt;;\u003Cbr\u003E\u003Cbr\u003Econst cars: ReadonlyCarArray = [\u003Cbr\u003E  { id: 1, brand: \"Tesla\", model: \"CyberTruck\" },\u003Cbr\u003E  { id: 2, brand: \"Ford\", model: \"F-150\" },\u003Cbr\u003E];\u003C/pre\u003E\n\u003Ch4\u003ETPS.14: Using NonNullable\u003C/h4\u003E\n\u003Cp\u003EThe NonNullable utility type is used to exclude null and undefined from a type. This is helpful when you want to ensure that a value is defined and not null, which can prevent runtime errors related to dereferencing null or undefined values.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  model: string | null;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Create a version of Car with a non-nullable model\u003Cbr\u003Etype NonNullableCar = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  model: NonNullable&lt;Car['model']&gt;;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst car: NonNullableCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  model: \"Tesla\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Assigning null will cause a compilation error\u003Cbr\u003E// car.model = null; // Error: Type 'null' is not assignable to type 'string'.\u003C/pre\u003E\n\u003Ch4\u003EInterfaces\u003C/h4\u003E\n\u003Cp\u003EInterfaces in TypeScript allow you to define the shape of objects and can be used in a similar way to types. They are particularly useful for defining class structures and can also be extended, providing a flexible way to create complex data structures. They suit better for classes.\u003C/p\u003E\n\u003Ch4\u003EINT.01: Basic Interface Definition\u003C/h4\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Which in this case could had been the same as:\u003Cbr\u003E// type Car = {\u003Cbr\u003E//   model: string;\u003Cbr\u003E//   year: number;\u003Cbr\u003E// }\u003Cbr\u003E\u003Cbr\u003Econst vehicle: Car = {\u003Cbr\u003E  model: \"Tesla Model 3\",\u003Cbr\u003E  year: 2020,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.02: Extending Interfaces\u003C/h4\u003E\n\u003Cp\u003EYou can create new interfaces by extending existing ones. This helps you build on top of existing structures without repeating code. This would be the way to compose other interfaces, the same way that types uses intersections, interfaces extend.\u003C/p\u003E\n\u003Cpre\u003Einterface Vehicle {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Einterface ElectricCar extends Vehicle {\u003Cbr\u003E  batteryCapacity: number; // in kWh\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst teslaModelS: ElectricCar = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.03: Squashing Interfaces in the Same Namespace\u003C/h4\u003E\n\u003Cp\u003EOne of the powerful features of interfaces is that they can be declared multiple times within the same scope. TypeScript automatically merges these declarations, allowing you to add properties to an interface as needed.\u003C/p\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Einterface Car {\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar: Car = {\u003Cbr\u003E  brand: \"Toyota\",\u003Cbr\u003E  model: \"Camry\",\u003Cbr\u003E  year: 2021,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.04: Extending Interfaces with Function Types\u003C/h4\u003E\n\u003Cp\u003EInterfaces can also define function types, enabling you to type functions more explicitly.\u003C/p\u003E\n\u003Cpre\u003Einterface CarProcessor {\u003Cbr\u003E  (car: Car): void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst processCar: CarProcessor = (car) =&gt; {\u003Cbr\u003E  console.log(`Processing car: ${car.brand} ${car.model}`);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.05: Namespaced Interfaces\u003C/h4\u003E\n\u003Cp\u003EYou can use namespaces to group related interfaces together, helping to organize your code better. Since ES Modules, this feature is less common, and prefered to be avoided.\u003C/p\u003E\n\u003Cpre\u003Enamespace CarModule {\u003Cbr\u003E  export interface Car {\u003Cbr\u003E    id: number;\u003Cbr\u003E    brand: string;\u003Cbr\u003E    model: string;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  export interface ElectricCar extends Car {\u003Cbr\u003E    batteryCapacity: number;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst tesla: CarModule.ElectricCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.06: Optional Properties\u003C/h4\u003E\n\u003Cp\u003EInterfaces can have optional properties, allowing you to define flexible structures\u003C/p\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  color?: string; // Optional property\u003Cbr\u003E}const tesla: Car = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model 3\",\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.07: Readonly Properties\u003C/h4\u003E\n\u003Cp\u003ETo create properties that cannot be modified after their initial assignment, you can use the readonly modifier.\u003C/p\u003E\n\u003Cpre\u003Einterface ImmutableUser {\u003Cbr\u003Einterface ImmutableCar {\u003Cbr\u003E  readonly id: number;\u003Cbr\u003E  readonly brand: string;\u003Cbr\u003E  readonly model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar: ImmutableCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// myCar.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.\u003C/pre\u003E\n\u003Ch3\u003EEnums\u003C/h3\u003E\n\u003Ch4\u003EEN.01: Enums — Please Don’t use them\u003C/h4\u003E\n\u003Cp\u003EEnums are widely unused since there are more modern approaches. Visit \u003Ca href=\"https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh#:~:text=Excessive%20use%20of%20regular%20ENUMs,new%20values%20can%20be%20added.\"\u003Ehere\u003C/a\u003E for more details.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Eenum CarType {\u003Cbr\u003E  SEDAN = \"sedan\",\u003Cbr\u003E  SUV = \"suv\",\u003Cbr\u003E  TRUCK = \"truck\",\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction createCar(type: CarType) {\u003Cbr\u003E  // Implementation here\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003EcreateCar(CarType.SEDAN); // Valid\u003Cbr\u003EcreateCar('sedan'); // Invalid\u003C/pre\u003E\n\u003Cp\u003EInstead, use as const combined with exporting the union of values:\u003C/p\u003E\n\u003Cpre\u003Eexport const CarTypes = {\u003Cbr\u003E  SEDAN: \"sedan\",\u003Cbr\u003E  SUV: \"suv\",\u003Cbr\u003E  TRUCK: \"truck\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003E// Exporting the type derived from the CarTypes constant\u003Cbr\u003Eexport type CarType = typeof CarTypes[keyof typeof CarTypes];\u003Cbr\u003E\u003Cbr\u003Econst handlerFunction = (carType: CarType) =&gt; {\u003Cbr\u003E  if (carType === CarTypes.SEDAN) {\u003Cbr\u003E    return 'This is a sedan';\u003Cbr\u003E  }\u003Cbr\u003E  return 'This is not a sedan';\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003EhandlerFunction('sedan'); // This will work\u003Cbr\u003EhandlerFunction(CarTypes.SEDAN); // This will work too.\u003C/pre\u003E\n\u003Ch4\u003EEN.02: Exporting nested enums as a flatten entity\u003C/h4\u003E\n\u003Cpre\u003Etype ApiEndpoint =\u003Cbr\u003E  | `/${string}`\u003Cbr\u003E  | Record&lt;string, ApiEndpoint&gt;;\u003Cbr\u003E\u003Cbr\u003Econst apiEndpoints = {\u003Cbr\u003E  cards: {\u003Cbr\u003E    GET_ALL: '/cards',\u003Cbr\u003E    GET_BY_ID: '/cards/:id',\u003Cbr\u003E    CREATE: '/cards/create',\u003Cbr\u003E    UPDATE: '/cards/update/:id',\u003Cbr\u003E    DELETE: '/cards/delete/:id',\u003Cbr\u003E    CATEGORIES: {\u003Cbr\u003E      GET_ALL: '/cards/categories',\u003Cbr\u003E      GET_BY_ID: '/cards/categories/:id',\u003Cbr\u003E      CREATE: '/cards/categories/create',\u003Cbr\u003E      UPDATE: '/cards/categories/update/:id',\u003Cbr\u003E      DELETE: '/cards/categories/delete/:id',\u003Cbr\u003E    },\u003Cbr\u003E    TAGS: {\u003Cbr\u003E      GET_ALL: '/cards/tags',\u003Cbr\u003E      GET_BY_ID: '/cards/tags/:id',\u003Cbr\u003E      CREATE: '/cards/tags/create',\u003Cbr\u003E      UPDATE: '/cards/tags/update/:id',\u003Cbr\u003E      DELETE: '/cards/tags/delete/:id',\u003Cbr\u003E    },\u003Cbr\u003E  },\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype Flatten&lt;T&gt; = T extends Record&lt;string, infer U&gt; ? Flatten&lt;U&gt; : T;\u003Cbr\u003E\u003Cbr\u003Eexport type ApiEndpoints = Flatten&lt;typeof apiEndpoints&gt;;\u003Cbr\u003E\u003Cbr\u003Econst someEndpoint: ApiEndpoints = apiEndpoints.cards.GET_ALL;\u003Cbr\u003Econst someOtherEndpoint: ApiEndpoints = '/cards/categories';\u003C/pre\u003E\n\u003Ch3\u003E03. Inference\u003C/h3\u003E\n\u003Cp\u003EInference is the way that TS ‘guesses’ what type some variable is. Sometimes, you need to help it a bit.\u003C/p\u003E\n\u003Ch4\u003EINFR.01: Inference: let and const change the way TS assigns types\u003C/h4\u003E\n\u003Cp\u003EUsing let allows reassignment, resulting in the type being inferred as string. In contrast, const can’t be reassigned, leading TypeScript to infer its type as a literal.\u003C/p\u003E\n\u003Cp\u003EFor example:\u003C/p\u003E\n\u003Cpre\u003Elet type = \"sedan\"; // inferred as string, because it can be reassigned\u003C/pre\u003E\n\u003Cp\u003EWhile:\u003C/p\u003E\n\u003Cpre\u003Econst type = \"sedan\"; // inferred as 'sedan' because it can't be reassigned\u003C/pre\u003E\n\u003Ch4\u003EINFR.02: Object property inference\u003C/h4\u003E\n\u003Cp\u003ETypeScript’s type inference can sometimes lead to unintended results when inferring object properties. Since objects are dynamically typed, a string in a key will default to string instead of maybe a literal.\u003C/p\u003E\n\u003Cp\u003EMost of the time, if you are using an approach like the following one, TS will infer ‘strings’ instead of your assigned type ButtonAttributes. To avoid that, just add the type.\u003C/p\u003E\n\u003Cp\u003EThis will error:\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: \"sedan\", // inferred as string\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes); // will error\u003C/pre\u003E\n\u003Cp\u003EBut this won’t\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  type: \"sedan\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.03: Using ‘as const’ to force inference\u003C/h4\u003E\n\u003Cp\u003EThe same example as before can be solved by instructing TS that it should be considered as const.\u003C/p\u003E\n\u003Cp\u003Eas const not only locks the type to a specific literal but also makes the properties of the object readonly. Better to use a type if you can, but sometimes this trick will also do. It all depends on if you want that readonly attribute as well or not.\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: 'sedan' | 'suv' | 'truck';\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: 'sedan' as const,\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.04: Using ‘satisfies’\u003C/h4\u003E\n\u003Cp\u003EAnother way to solve the previous issue is using satisfies. satisfies helps in the case the object doesn’t have the same structure as the type.\u003C/p\u003E\n\u003Cp\u003EUsing satisfies checks the object against the type at compile-time without requiring the object to match the type structure perfectly, thus enhancing flexibility.\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: 'sedan' | 'suv' | 'truck';\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: 'sedan',\u003Cbr\u003E} satisfies CarAttributes;\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.05: ‘Readonly’ and ‘as const’\u003C/h4\u003E\n\u003Cp\u003EUsing as const on an object makes it readonly, eliminating the need to define the type explicitly. This is important because immutability ensures that the values of properties can’t be changed after the object is created, reducing the risk of unintended side effects in your code.\u003C/p\u003E\n\u003Cp\u003EThe 2 following snippets are exactly the same:\u003C/p\u003E\n\u003Cpre\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  sport: {\u003Cbr\u003E    type: \"sedan\",\u003Cbr\u003E  },\u003Cbr\u003E  utility: {\u003Cbr\u003E    type: \"suv\",\u003Cbr\u003E  },\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype CarType = \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E\u003Cbr\u003Etype CarAttributes = {\u003Cbr\u003E  readonly sport: {\u003Cbr\u003E    readonly type: CarType;\u003Cbr\u003E  };\u003Cbr\u003E  readonly utility: {\u003Cbr\u003E    readonly type: CarType;\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  sport: {\u003Cbr\u003E    type: \"sedan\",\u003Cbr\u003E  },\u003Cbr\u003E  utility: {\u003Cbr\u003E    type: \"suv\",\u003Cbr\u003E  },\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EAs you can see, using as const is a nice shortcut for those readonly properties.\u003C/p\u003E\n\u003Ch4\u003EINFR.06: Function Overloading\u003C/h4\u003E\n\u003Cp\u003EFunction overloading allows you to define multiple signatures for a function, enabling it to accept different parameter types and return different types based on the parameters provided.\u003C/p\u003E\n\u003Cp\u003EIn an ideal world, this kind of thing shouldn’t happen often, but if you have some kind of “master” function that handles many cases with many types, it can be useful.\u003C/p\u003E\n\u003Cp\u003EThis can improve code readability and maintainability by allowing a single function name to handle multiple use cases.\u003C/p\u003E\n\u003Cp\u003ENeedless to say, try to avoid this kind of thing.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Efunction processCar(input: string): boolean; // Returns a boolean\u003Cbr\u003Efunction processCar(input: number): string; // Returns a string\u003Cbr\u003Efunction processCar(input: boolean): number; // Returns a number\u003Cbr\u003Efunction processCar(input: string | number | boolean): boolean | string | number {\u003Cbr\u003E  if (typeof input === \"string\") {\u003Cbr\u003E    return input.length &gt; 0; // Returns true if the string is non-empty\u003Cbr\u003E  } else if (typeof input === \"number\") {\u003Cbr\u003E    return `The car count is ${input}.`; // Returns a string representation\u003Cbr\u003E  } else if (typeof input === \"boolean\") {\u003Cbr\u003E    return input ? 1 : 0; // Returns 1 for true and 0 for false\u003Cbr\u003E  }\u003Cbr\u003E  throw new Error(\"Invalid input type.\");\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.07: Type Guards\u003C/h4\u003E\n\u003Cp\u003EType guards are a feature that allow you to narrow down the type of a variable within a conditional block. This can enhance type safety and prevent runtime errors by ensuring that the operations performed on variables are valid for their types.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Efunction logCar(value: string | number) {\u003Cbr\u003E  if (typeof value === \"string\") {\u003Cbr\u003E    console.log(`Car model: ${value}`);\u003Cbr\u003E  } else { // TS would know that value is a number\u003Cbr\u003E    console.log(`Car ID: ${value}`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.08: Scope Narrowing\u003C/h4\u003E\n\u003Cp\u003ESometimes TS won’t be able to detect the type of a variable. Lowering the declaration of the variable to the same scope sometimes fixes it:\u003C/p\u003E\n\u003Cpre\u003Econst findCarsByModel = (\u003Cbr\u003E  searchParams: { model?: string },\u003Cbr\u003E  cars: {\u003Cbr\u003E    id: string;\u003Cbr\u003E    model: string;\u003Cbr\u003E  }[],\u003Cbr\u003E) =&gt; {\u003Cbr\u003E  if (searchParams.model) {\u003Cbr\u003E    const { model } = searchParams; // Scope narrowing to avoid errors\u003Cbr\u003E    return cars.filter((car) =&gt; car.model.includes(model));\u003Cbr\u003E  }\u003Cbr\u003E  return cars;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINFR.09: Discriminated Unions and Types: don’t use one type to try to cover several entities (avoid ambiguity, segregate the entities)\u003C/h4\u003E\n\u003Cp\u003EIn this example Vehicle can represent both a circle and a rectangle. But it is not clear:\u003C/p\u003E\n\u003Cpre\u003Etype Vehicle = {\u003Cbr\u003E  kind: string;\u003Cbr\u003E  horsepower?: number;\u003Cbr\u003E  seatingCapacity?: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Efunction getSpecifications(vehicle: Vehicle) {\u003Cbr\u003E  if (vehicle.kind === \"sedan\") {\u003Cbr\u003E    return `Seating Capacity: ${vehicle.seatingCapacity}`;\u003Cbr\u003E  } else {\u003Cbr\u003E    return `Horsepower: ${vehicle.horsepower}`;\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EInstead:\u003C/p\u003E\n\u003Cpre\u003Etype Sedan = {\u003Cbr\u003E  kind: 'sedan';\u003Cbr\u003E  seatingCapacity: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  kind: \"truck\";\u003Cbr\u003E  horsepower: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Sedan | Truck;\u003Cbr\u003E\u003Cbr\u003Efunction getSpecifications(vehicle: Vehicle) {\u003Cbr\u003E  if (vehicle.kind === \"sedan\") {\u003Cbr\u003E    return `Seating Capacity: ${vehicle.seatingCapacity}`;\u003Cbr\u003E  }\u003Cbr\u003E  return `Horsepower: ${vehicle.horsepower}`;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.10: Avoid using ‘let’ without types:\u003C/h4\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Elet type = \"sedan\"; // inferred as string, using a const would prevent this\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  type, // error due to inferred string type\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINFR.11: The ‘Never’ Type\u003C/h4\u003E\n\u003Cp\u003EThe never type in TypeScript represents a value that never occurs. It's used in functions that throw errors or have infinite loops, as they never return a value.\u003C/p\u003E\n\u003Cpre\u003Efunction throwError(message: string): never {\u003Cbr\u003E  throw new Error(message);\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EIt also represents incompatible types. For example: string &amp; number is going to be never.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  id: number; // incompatible with Car's id\u003Cbr\u003E  model: string;\u003Cbr\u003E  payloadCapacity: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst impossible: Car &amp; Truck = {\u003Cbr\u003E  id: 'C123', // error because id must be both string and number, which is impossible\u003Cbr\u003E  model: 'X1',\u003Cbr\u003E  payloadCapacity: 3000\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch3\u003E04. Classes, deriving types, Generics\u003C/h3\u003E\n\u003Ch4\u003EClasses\u003C/h4\u003E\n\u003Ch4\u003ECLS.01: Default properties\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  readonly make: string;\u003Cbr\u003E  readonly model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(make = \"Generic\", model = \"Model\") {\u003Cbr\u003E    this.make = make;\u003Cbr\u003E    this.model = model;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E// Equivalent to:\u003Cbr\u003Eclass Car {\u003Cbr\u003E  readonly make: string = \"Generic\";\u003Cbr\u003E  readonly model: string = \"Model\";\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.02: Creating Constructors\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make = \"Generic\";\u003Cbr\u003E  model = \"Model\";\u003Cbr\u003E\u003Cbr\u003E  constructor(opts?: { make: string; model: string } = { make: \"Generic\", model: \"Model\" }) {\u003Cbr\u003E    this.make = opts.make;\u003Cbr\u003E    this.model = opts.model;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.03: Declaring Methods\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make = \"Generic\";\u003Cbr\u003E  model = \"Model\";\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.04: Getters\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.make, model: this.model };\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.05: Private properties\u003C/h4\u003E\n\u003Cp\u003EYou can use the private or # prefix in the member declaration to make it private. Both ways will work, it is a matter of style.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  private make: string;\u003Cbr\u003E  private model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.make, model: this.model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Or with `#` prefix:\u003Cbr\u003Eclass Car {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.#make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.06: Setters\u003C/h4\u003E\n\u003Cp\u003ETS understands the type of the setter by checking the getter. No need to define the type.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.#make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  // since the get details returns an object with make and model, the set expects the same signature\u003Cbr\u003E  set details(details) {\u003Cbr\u003E    this.#make = details.make;\u003Cbr\u003E    this.#model = details.model;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.07: Overriding\u003C/h4\u003E\n\u003Cp\u003EIf in the tsConfig the option noImplicitOverride is turned on, you will need to add the override keyword when extending a method from an inherited class.\u003C/p\u003E\n\u003Cpre\u003E// inside tsconfig.json\u003Cbr\u003E{\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    ...\u003Cbr\u003E    \"noImplicitOverride\": true\u003C/pre\u003E\n\u003Cpre\u003Eclass Vehicle {\u003Cbr\u003E  logType() {\u003Cbr\u003E    console.log(\"Vehicle type\");\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eclass Car extends Vehicle {\u003Cbr\u003E  override logType() {\u003Cbr\u003E    console.log(\"Car type\");\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.08: Implementing a ‘type’ or ‘interface’\u003C/h4\u003E\n\u003Cp\u003EClasses can implement interfaces or types. Stick to using interfaces. As you can see, it can handle both, but the industry prefers the first one.\u003C/p\u003E\n\u003Cpre\u003Einterface VehicleOptions {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype VehicleType = {\u003Cbr\u003E  details: { make: string; model: string };\u003Cbr\u003E  drive: (speed: number) =&gt; void;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eclass Car implements VehicleType {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(initial?: VehicleOptions) {\u003Cbr\u003E    this.#make = initial?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = initial?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.09: Abstract Classes\u003C/h4\u003E\n\u003Cp\u003Eabstract classes allow you to define methods that subclasses must implement, as well as methods with default behavior. This is useful when designing base classes for other classes to extend.\u003C/p\u003E\n\u003Cpre\u003Eabstract class Vehicle {\u003Cbr\u003E  abstract speed(): number;\u003Cbr\u003E\u003Cbr\u003E  describe(): string {\u003Cbr\u003E    return \"This is a vehicle.\";\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eclass Car extends Vehicle {\u003Cbr\u003E  constructor(public maxSpeed: number) {\u003Cbr\u003E    super();\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  speed(): number {\u003Cbr\u003E    return this.maxSpeed;\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.10: Static Properties and Methods\u003C/h4\u003E\n\u003Cp\u003Estatic members belong to the class itself rather than to any specific instance. This is useful for utility functions or properties that should be shared across all instances. So far, the static is nothing new to TS.\u003C/p\u003E\n\u003Cpre\u003Eclass VehicleUtils {\u003Cbr\u003E  static MAX_SPEED = 120;\u003Cbr\u003E\u003Cbr\u003E  static calculateDistance(time: number) {\u003Cbr\u003E    return this.MAX_SPEED * time;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(VehicleUtils.calculateDistance(2)); // 240\u003C/pre\u003E\n\u003Ch4\u003ECLS.11: Parameter Properties\u003C/h4\u003E\n\u003Cp\u003EThis shorthand allows you to define and initialize class members directly in the constructor’s parameter list, reducing boilerplate code.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  constructor(public make: string = \"Generic\", public model: string = \"Model\") {}\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst car = new Car(\"Toyota\", \"Corolla\");\u003Cbr\u003Econsole.log(car.make); // Toyota\u003C/pre\u003E\n\u003Cp\u003EThis equals to:\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  public make: string;\u003Cbr\u003E  public model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(make: string = \"Generic\", model: string = \"Model\") {\u003Cbr\u003E    this.make = make;\u003Cbr\u003E    this.model = model;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst car = new Car(\"Toyota\", \"Corolla\");\u003Cbr\u003Econsole.log(car.make); // Toyota\u003C/pre\u003E\n\u003Cp\u003EInstead of declaring properties and assigning them in the constructor, parameter properties allow you to do both in a single step, making your class definitions more concise.\u003C/p\u003E\n\u003Ch4\u003EDTV.01: Deriving Types from Variables\u003C/h4\u003E\n\u003Cp\u003EDeriving types from existing values or variables is a powerful feature in TypeScript, allowing you to dynamically infer types based on data structures, function signatures, and constants. Here’s a comprehensive guide on different techniques for deriving types in TypeScript.\u003C/p\u003E\n\u003Cp\u003EThis allows for a more dynamic and type-safe approach to working with complex data structures. Let’s explore key techniques like keyof, typeof, and more.\u003C/p\u003E\n\u003Ch4\u003EDTV.02: The ‘keyof’ Operator\u003C/h4\u003E\n\u003Cp\u003EThe keyof operator creates a union of string literal types from the keys of an interface or object. This is particularly useful for creating flexible types.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Einterface CarSpecs {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// carDetails will need to have the same keys as the interface\u003Cbr\u003Econst carDetails: Record&lt;keyof CarSpecs, { description: string; value: string | number }&gt; = {\u003Cbr\u003E  make: { description: \"Car Make\", value: \"Toyota\" },\u003Cbr\u003E  model: { description: \"Car Model\", value: \"Corolla\" },\u003Cbr\u003E  year: { description: \"Manufacturing Year\", value: 2021 },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EHere, keyof CarSpecs creates a union of \"make\" | \"model\" | \"year\", allowing carDetails to have the same keys as CarSpecs.\u003C/p\u003E\n\u003Ch4\u003EDTV.03: The 'typeof' Operator\u003C/h4\u003E\n\u003Cp\u003EThe typeof operator can be used to derive types directly from variables or objects.\u003C/p\u003E\n\u003Cp\u003EFor example:\u003C/p\u003E\n\u003Cpre\u003Econst configurations = {\u003Cbr\u003E  development: {\u003Cbr\u003E    apiBaseUrl: 'http://localhost:8080',\u003Cbr\u003E    timeout: 5000,\u003Cbr\u003E  },\u003Cbr\u003E  production: {\u003Cbr\u003E    apiBaseUrl: 'https://api.example.com',\u003Cbr\u003E    timeout: 10000,\u003Cbr\u003E  },\u003Cbr\u003E  staging: {\u003Cbr\u003E    apiBaseUrl: 'https://staging.example.com',\u003Cbr\u003E    timeout: 8000,\u003Cbr\u003E  },\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Environment = keyof typeof configurations; // 'development' | 'production' | 'staging'\u003C/pre\u003E\n\u003Cp\u003EIn this case, keyof typeof configurations extracts the keys ('development', 'production', 'staging') as a union type.\u003C/p\u003E\n\u003Ch4\u003EDTV.04: You Can Create Types from Values, but Not Values from Types\u003C/h4\u003E\n\u003Cp\u003Etypes and interfaces in TypeScript are erased at runtime, which means you can only derive types from existing values, but not the other way around. Type information doesn’t exist at runtime and only helps in static checking during development.\u003C/p\u003E\n\u003Ch4\u003EDTV.05: Deriving Types with Classes\u003C/h4\u003E\n\u003Cp\u003EClasses can be used as types directly in TypeScript. Any instance of a class can be typed as the class itself.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Eclass CarPosition {\u003Cbr\u003E  x = 0;\u003Cbr\u003E  y = 0;\u003Cbr\u003E\u003Cbr\u003E  move(x: number, y: number) {\u003Cbr\u003E    this.x = x;\u003Cbr\u003E    this.y = y;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst positionFromCar = (position: CarPosition) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    x: position.x,\u003Cbr\u003E    y: position.y,\u003Cbr\u003E  };\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EHere, CarPosition serves both as a class and a type.\u003C/p\u003E\n\u003Ch4\u003EDTV.06: Using the Same Name for Values and Types\u003C/h4\u003E\n\u003Cp\u003EYou can have the same name for a type and a constant.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Eexport const Logger = {\u003Cbr\u003E  log: (message: string) =&gt; console.log(message),\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport type Logger = typeof Logger;\u003C/pre\u003E\n\u003Cp\u003EHere, Logger refers both to a type (inferred from the constant) and the constant itself.\u003C/p\u003E\n\u003Ch4\u003EDTV.07: Deriving Types from Complex Function Parameters\u003C/h4\u003E\n\u003Cp\u003EYou can derive types from function parameters using Parameters&lt;&gt;.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst makeQuery = (\u003Cbr\u003E  url: string,\u003Cbr\u003E  opts?: {\u003Cbr\u003E    method?: string;\u003Cbr\u003E    headers?: {\u003Cbr\u003E      [key: string]: string;\u003Cbr\u003E    };\u003Cbr\u003E    body?: string;\u003Cbr\u003E  },\u003Cbr\u003E) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Etype MakeQueryParameters = Parameters&lt;typeof makeQuery&gt;;\u003C/pre\u003E\n\u003Cp\u003EHere, MakeQueryParameters extracts the type of the parameters from makeQuery.\u003C/p\u003E\n\u003Ch4\u003EDTV.08: Extracting a Type from a Function’s Return Type\u003C/h4\u003E\n\u003Cp\u003EYou can extract the return type of a function using ReturnType&lt;&gt;.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst createUser = (id: string) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    id,\u003Cbr\u003E    name: \"John Doe\",\u003Cbr\u003E    email: \"example@email.com\",\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype User = ReturnType&lt;typeof createUser&gt;;\u003C/pre\u003E\n\u003Ch4\u003EDTV.09: Extracting Type from an Async Function\u003C/h4\u003E\n\u003Cp\u003EWhen working with asynchronous functions, you can use Awaited&lt;&gt; to get the \u003Cem\u003Eresolved\u003C/em\u003E type.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst fetchUser = async (id: string) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    id,\u003Cbr\u003E    name: \"John Doe\",\u003Cbr\u003E    email: \"example@email.com\",\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;;\u003C/pre\u003E\n\u003Ch4\u003EDTV.10: Access Specific Values in an 'as const' Object\u003C/h4\u003E\n\u003Cp\u003EBy using as const, you can lock an object’s values as constants, which allows you to access them more precisely.\u003C/p\u003E\n\u003Cpre\u003Eexport const carBrandType = {\u003Cbr\u003E  SEDAN: \"sedan\",\u003Cbr\u003E  SUV: \"suv\",\u003Cbr\u003E  COUPE: \"coupe\",\u003Cbr\u003E  PICKUP: \"pickup\",\u003Cbr\u003E  VAN: \"van\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype CarBrandTypeMap = typeof carBrandType; // a readonly object accesible by key\u003Cbr\u003Etype Sedan = CarBrandTypeMap['SEDAN']; // 'sedan'\u003C/pre\u003E\n\u003Ch4\u003EDTV.11: Passing a Union to an Indexed Access Type\u003C/h4\u003E\n\u003Cp\u003EYou can create union types by passing specific keys to an indexed access type.\u003C/p\u003E\n\u003Cpre\u003E// Following previous example, this type will be: \"sedan\" | \"suv\"\u003Cbr\u003Etype SedanOrSuv = CarBrandTypeMap['SEDAN' | 'SUV']\u003C/pre\u003E\n\u003Ch4\u003EDTV.12: Extract a Union of All Values from an Object\u003C/h4\u003E\n\u003Cp\u003EYou can guess that with the previous explanation you could get the union of all the values hardcoding each of them. But you can make your life easier by extracting all the values from an object as a union. This is usually used instead of enums.\u003C/p\u003E\n\u003Cpre\u003E\u003Cbr\u003E// Equals too 'sedan' | 'suv' | 'coupe' | 'pickup' | 'van'\u003Cbr\u003Etype CarTypes = CarBrandTypeMap[keyof typeof carBrandType];\u003C/pre\u003E\n\u003Ch4\u003EDTV.13: Create a Union from an as const Array\u003C/h4\u003E\n\u003Cp\u003EYou can derive a union type from an array by using as const.\u003C/p\u003E\n\u003Cpre\u003Eexport const carBrandType = [\u003Cbr\u003E  \"sedan\",\u003Cbr\u003E  \"suv\",\u003Cbr\u003E  \"coupe\",\u003Cbr\u003E  \"pickup\",\u003Cbr\u003E  \"van\",\u003Cbr\u003E] as const;\u003Cbr\u003E\u003Cbr\u003Etype BrandCars = (typeof carBrandType)[number];\u003C/pre\u003E\n\u003Ch3\u003EGenerics\u003C/h3\u003E\n\u003Ch4\u003EGEN.01: Basic Generic Function\u003C/h4\u003E\n\u003Cp\u003EA generic function allows you to define a placeholder type that can be replaced later.\u003C/p\u003E\n\u003Cpre\u003Efunction identity&lt;T&gt;(value: T): T {\u003Cbr\u003E  return value;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst num = identity(42); // T is 'number'\u003Cbr\u003Econst str = identity(\"hello\"); // T is 'string'\u003C/pre\u003E\n\u003Ch4\u003EGEN.02: Generic Types with Arrays\u003C/h4\u003E\n\u003Cp\u003EGeneric functions can handle arrays of any type.\u003C/p\u003E\n\u003Cpre\u003Efunction getFirstElement&lt;T&gt;(arr: T[]): T {\u003Cbr\u003E  return arr[0];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst firstNumber = getFirstElement([1, 2, 3]); // T is 'number'\u003Cbr\u003Econst firstString = getFirstElement([\"a\", \"b\", \"c\"]); // T is 'string'\u003C/pre\u003E\n\u003Ch4\u003EGEN.03: Generic Interfaces\u003C/h4\u003E\n\u003Cp\u003EUse generics with interfaces to define reusable types.\u003C/p\u003E\n\u003Cpre\u003Einterface Result&lt;T&gt; {\u003Cbr\u003E  data: T;\u003Cbr\u003E  error?: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst success: Result&lt;number&gt; = { data: 42 };\u003Cbr\u003Econst failure: Result&lt;string&gt; = { data: \"error occurred\", error: \"404 not found\" };\u003C/pre\u003E\n\u003Ch4\u003EGEN.04: Generic Constraints\u003C/h4\u003E\n\u003Cp\u003ESometimes you need to restrict the types that can be passed to a generic. You can do this using \u003Cstrong\u003Econstraints\u003C/strong\u003E. For example, to ensure that a type has a length property (like arrays or strings), you can add the following:\u003C/p\u003E\n\u003Cpre\u003Einterface HasLength {\u003Cbr\u003E  length: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction logLength&lt;T extends HasLength&gt;(input: T): void {\u003Cbr\u003E  console.log(input.length);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003ElogLength(\"hello\"); // OK, string has a length property\u003Cbr\u003ElogLength([1, 2, 3]); // OK, array has a length property\u003Cbr\u003E// logLength(42); // Error, number has no length property\u003C/pre\u003E\n\u003Cp\u003EThis can also be used when you want &lt;T&gt; to be limited to certain interfaces or types.\u003C/p\u003E\n\u003Ch4\u003EGEN.05: Using Multiple Generics\u003C/h4\u003E\n\u003Cp\u003EYou can use multiple generics in the same function or type.\u003C/p\u003E\n\u003Cpre\u003Efunction pair&lt;A, B&gt;(first: A, second: B): [A, B] {\u003Cbr\u003E  return [first, second];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst pair1 = pair(1, \"apple\"); // A is 'number', B is 'string'\u003Cbr\u003Econst pair2 = pair(true, { name: \"John\" }); // A is 'boolean', B is an object\u003C/pre\u003E\n\u003Ch4\u003EGEN.06: Default Generic Types\u003C/h4\u003E\n\u003Cp\u003ESet default generic types to simplify function calls.\u003C/p\u003E\n\u003Cpre\u003Efunction createArray&lt;T = string&gt;(length: number, value: T): T[] {\u003Cbr\u003E  return Array(length).fill(value);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst stringArray = createArray(3, \"hello\"); // T is 'string'\u003Cbr\u003Econst numberArray = createArray&lt;number&gt;(3, 42); // Explicitly set T as 'number'\u003Cbr\u003Econst error = createArray&lt;number&gt;('3', 42); // This will error\u003C/pre\u003E\n\u003Ch4\u003EGEN.07: Conditional Types with Generics\u003C/h4\u003E\n\u003Cp\u003ETypeScript allows you to create \u003Cstrong\u003Econditional types\u003C/strong\u003E using generics:\u003C/p\u003E\n\u003Cpre\u003Etype IsArray&lt;T&gt; = T extends any[] ? \"Array\" : \"NotArray\";\u003Cbr\u003E\u003Cbr\u003Econst check1: IsArray&lt;string[]&gt; = \"Array\"; // OK\u003Cbr\u003Econst check2: IsArray&lt;number&gt; = \"NotArray\"; // OK\u003C/pre\u003E\n\u003Ch4\u003EGEN.08: Generic Functions with Overloads\u003C/h4\u003E\n\u003Cp\u003EOverloading functions happen when you declare them more than once with different implementations. No, it is not a bug, but an overload. Overloading helps you map specific definitions to specific signatures.\u003C/p\u003E\n\u003Cpre\u003Efunction formatValue&lt;T extends string | number&gt;(value: T): T extends string ? string : number;\u003Cbr\u003Efunction formatValue&lt;T extends string | number&gt;(value: T): string | number {\u003Cbr\u003E  if (typeof value === \"string\") {\u003Cbr\u003E    return value.toUpperCase();\u003Cbr\u003E  } else {\u003Cbr\u003E    return value.toFixed(2);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EGEN.09: Keyof with Generics\u003C/h4\u003E\n\u003Cp\u003EAccess dynamic properties using keyof and generics.\u003C/p\u003E\n\u003Cpre\u003Efunction getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {\u003Cbr\u003E  return obj[key];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst user = { id: 1, name: \"Alice\" };\u003Cbr\u003Econst id = getProperty(user, \"id\"); // OK\u003Cbr\u003Econst name = getProperty(user, \"name\"); // OK\u003Cbr\u003E// getProperty(user, \"age\"); // Error: 'age' is not a key of 'user'\u003C/pre\u003E\n\u003Ch4\u003EGEN.10: Deeply Immutable Structures with Generics\u003C/h4\u003E\n\u003Cp\u003EWhile TypeScript has a built-in Readonly utility type, it only applies immutability to the top level of an object. To create a deeply immutable object where all nested properties are also immutable, we need a custom recursive generic type.\u003C/p\u003E\n\u003Cpre\u003Etype DeepReadonly&lt;T&gt; = {\u003Cbr\u003E  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface User {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  address: {\u003Cbr\u003E    street: string;\u003Cbr\u003E    city: string;\u003Cbr\u003E  };\u003Cbr\u003E}\u003Cbr\u003Econst user: DeepReadonly&lt;User&gt; = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  name: \"Alice\",\u003Cbr\u003E  address: {\u003Cbr\u003E    street: \"Main St\",\u003Cbr\u003E    city: \"Wonderland\"\u003Cbr\u003E  }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Now, all properties and nested properties are readonly:\u003Cbr\u003Euser.id = 2; // Error: Cannot assign to 'id' because it is a read-only property\u003Cbr\u003Euser.address.city = \"New City\"; // Error: Cannot assign to 'city' because it is a read-only property\u003C/pre\u003E\n\u003Ch4\u003EGEN.11: Mapping Over a Union of Types\u003C/h4\u003E\n\u003Cp\u003EYou can create a type that maps a transformation over each type in a union. This is useful for mass-transforming several types at once.\u003C/p\u003E\n\u003Cpre\u003Etype Mapped&lt;T&gt; = T extends string ? string[] : T extends number ? number[] : T;\u003Cbr\u003Etype Result = Mapped&lt;string | number&gt;; // string[] | number[]\u003C/pre\u003E\n\u003Cp\u003EThe Mapped type checks if T is a string or number and returns an array of the respective type. If T is a union, TypeScript automatically distributes the transformation over each member.\u003C/p\u003E\n\u003Ch4\u003EGEN.12: Conditional Properties Exclusion\u003C/h4\u003E\n\u003Cp\u003EThis example excludes properties from a definition based on their types. Here, we remove all string properties from an interface:\u003C/p\u003E\n\u003Cpre\u003Etype OmitByType&lt;T, U&gt; = {\u003Cbr\u003E  [K in keyof T as T[K] extends U ? never : K]: T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface Person {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  age: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype WithoutStrings = OmitByType&lt;Person, string&gt;; // { id: number; age: number; }\u003C/pre\u003E\n\u003Ch4\u003EGEN.13: Keep Specific Properties Based on Type\u003C/h4\u003E\n\u003Cp\u003EFollowing the previous example, this one does the same thing but opposite. Instead of omiting the matching types, this one keeps them.\u003C/p\u003E\n\u003Cpre\u003Etype KeepByType&lt;T, U&gt; = {\u003Cbr\u003E  [K in keyof T as T[K] extends U ? K : never]: T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface Person {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  age: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype StringProps = KeepByType&lt;Person, string&gt;; // { name: string }\u003C/pre\u003E\n\u003Cp\u003EThis is the inverse of the previous example, pulling out only the keys where the value type matches a specific type (string in this case).\u003C/p\u003E\n\u003Ch4\u003EGEN.14: Type-Safe Builder Pattern with Generics\u003C/h4\u003E\n\u003Cp\u003EHere’s a generic Builder type that allows chaining method calls and ensures type safety as you build an object step-by-step.\u003C/p\u003E\n\u003Cpre\u003Etype Builder&lt;T&gt; = {\u003Cbr\u003E  [K in keyof T as `set${Capitalize&lt;string &amp; K&gt;}`]: (value: T[K]) =&gt; Builder&lt;Omit&lt;T, K&gt;&gt;;\u003Cbr\u003E} &amp; { build(): T };\u003Cbr\u003E\u003Cbr\u003Einterface Product {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  price: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst productBuilder: Builder&lt;Product&gt; = {\u003Cbr\u003E  setId: (id) =&gt; productBuilder,\u003Cbr\u003E  setName: (name) =&gt; productBuilder,\u003Cbr\u003E  setPrice: (price) =&gt; productBuilder,\u003Cbr\u003E  build: () =&gt; ({ id: 1, name: \"Laptop\", price: 1200 })\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EThis Builder type allows method chaining for setting properties on an object while ensuring each property can only be set once. Once all properties are set, you can call build() to return the final object.\u003C/p\u003E\n\u003Ch3\u003E05. TypeScript in React\u003C/h3\u003E\n\u003Ch4\u003EREA.01: Typing Props\u003C/h4\u003E\n\u003Cp\u003ETypeScript allows us to enforce types on props, which makes components safer and easier to debug.\u003C/p\u003E\n\u003Cpre\u003Etype GreetingProps = {\u003Cbr\u003E  name: string;\u003Cbr\u003E  age?: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst Greeting = ({ name, age }: GreetingProps): JSX.Element =&gt; (\u003Cbr\u003E  &lt;h1&gt;\u003Cbr\u003E    Hello, {name}! {age &amp;&amp; `You are ${age} years old.`}\u003Cbr\u003E  &lt;/h1&gt;\u003Cbr\u003E);\u003Cbr\u003E\u003Cbr\u003Eexport default Greeting;\u003C/pre\u003E\n\u003Ch4\u003EREA.02: Typing State with useState\u003C/h4\u003E\n\u003Cp\u003EWhen initializing state, TypeScript can infer the type, but explicit types are often better for clarity.\u003C/p\u003E\n\u003Cpre\u003E// &lt;number&gt; is not neccesary here -TS inference-, but added for the demonstration.\u003Cbr\u003Econst [count, setCount] = useState&lt;number&gt;(0);\u003Cbr\u003Econst increment = () =&gt; setCount(count + 1);\u003C/pre\u003E\n\u003Ch4\u003EREA.03: Typing Event Handlers\u003C/h4\u003E\n\u003Cp\u003ETyping event handlers helps ensure proper usage of event properties within components.\u003C/p\u003E\n\u003Cpre\u003Econst handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {\u003Cbr\u003E  console.log(event.currentTarget);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\u003C/pre\u003E\n\u003Cp\u003EFor a button click event, we use React.MouseEvent&lt;HTMLButtonElement&gt;. TypeScript provides specific types for various events, like ChangeEvent for inputs. \u003Ca href=\"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/\"\u003EHere\u003C/a\u003E is a good source for forms.\u003C/p\u003E\n\u003Ch4\u003EREA.04: Typing Refs with useRef\u003C/h4\u003E\n\u003Cp\u003EWhen working with refs, explicitly typing useRef can prevent accidental null access errors.\u003C/p\u003E\n\u003Cpre\u003Econst inputRef = useRef&lt;HTMLInputElement&gt;(null); \u003Cbr\u003E\u003Cbr\u003Econst focusInput = () =&gt; {\u003Cbr\u003E  if (inputRef.current) {\u003Cbr\u003E    inputRef.current.focus();\u003Cbr\u003E  }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Ereturn &lt;input ref={inputRef} type=\"text\" /&gt;;\u003C/pre\u003E\n\u003Ch4\u003EREA.05: Typing Context\u003C/h4\u003E\n\u003Cp\u003EUsing TypeScript with React Context can make it easy to provide and consume context values safely.\u003C/p\u003E\n\u003Cpre\u003E// Define the context value type\u003Cbr\u003Etype ThemeContextType = {\u003Cbr\u003E  theme: string;\u003Cbr\u003E  toggleTheme: () =&gt; void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(undefined);\u003Cbr\u003E\u003Cbr\u003Econst ThemeProvider = ({ children }) =&gt; {\u003Cbr\u003E  const [theme, setTheme] = useState(\"light\");\u003Cbr\u003E  const toggleTheme = () =&gt; setTheme(theme === \"light\" ? \"dark\" : \"light\");\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\u003Cbr\u003E      {children}\u003Cbr\u003E    &lt;/ThemeContext.Provider&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EIn this example, ThemeContextType is used to define the structure of the context’s value, guaranteeing all consumers handle it correctly.\u003C/p\u003E\n\u003Ch4\u003EREA.06: Basic Typing Redux Store (Reducers and Selectors)\u003C/h4\u003E\n\u003Cp\u003EWhen working with \u003Ca href=\"https://redux.js.org/\"\u003ERedux\u003C/a\u003E, TypeScript is particularly useful for defining types for the store, actions, and selectors. If you are going to dig deeper I recommend you go over their docs.\u003C/p\u003E\n\u003Cpre\u003Etype CounterState = {\u003Cbr\u003E  count: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst initialState: CounterState = { count: 0 };\u003Cbr\u003E\u003Cbr\u003Econst actionTypes = {\u003Cbr\u003E  INCREMENT: \"INCREMENT\",\u003Cbr\u003E  DECREMENT: \"DECREMENT\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype ActionType = typeof actionTypes[keyof typeof actionTypes];\u003Cbr\u003E\u003Cbr\u003Etype CounterActionTypes = {type: ActionType};\u003Cbr\u003E\u003Cbr\u003Econst counterReducer = (state = initialState, action: CounterActionTypes): CounterState =&gt; {\u003Cbr\u003E  switch (action.type) {\u003Cbr\u003E    case actionTypes.INCREMENT:\u003Cbr\u003E      return { count: state.count + 1 };\u003Cbr\u003E    case actionTypes.DECREMENT:\u003Cbr\u003E      return { count: state.count - 1 };\u003Cbr\u003E    default:\u003Cbr\u003E      return state;\u003Cbr\u003E  }\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.07: Typing HOCs (Higher-Order Components)\u003C/h4\u003E\n\u003Cp\u003ETyping higher-order components (HOCs) means you will need to type the function of the HOC itself and also the argument (another function!) so beware of the syntax.\u003C/p\u003E\n\u003Cpre\u003Etype WithLoadingProps = {\u003Cbr\u003E  isLoading: boolean;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst withLoading = &lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) =&gt; {\u003Cbr\u003E  const LoadingComponent: React.FC&lt;P &amp; WithLoadingProps&gt; = ({ isLoading, ...otherProps }) =&gt; \u003Cbr\u003E    isLoading ? &lt;p&gt;Loading...&lt;/p&gt; : &lt;Component {...(otherProps as P)} /&gt;;\u003Cbr\u003E  return LoadingComponent;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.08: Typing Custom Hooks\u003C/h4\u003E\n\u003Cp\u003ETypeScript can make custom hooks more reusable by defining flexible types. For example, data can be of type T or null\u003C/p\u003E\n\u003Cpre\u003Efunction useFetch&lt;T&gt;(url: string): { data: T | null; loading: boolean; error: Error | null } {\u003Cbr\u003E  const [data, setData] = useState&lt;T | null&gt;(null);\u003Cbr\u003E  const [loading, setLoading] = useState(true);\u003Cbr\u003E  const [error, setError] = useState&lt;Error | null&gt;(null);\u003Cbr\u003E\u003Cbr\u003E  useEffect(() =&gt; {\u003Cbr\u003E    fetch(url)\u003Cbr\u003E      .then((response) =&gt; response.json())\u003Cbr\u003E      .then((data: T) =&gt; {\u003Cbr\u003E        setData(data);\u003Cbr\u003E        setLoading(false);\u003Cbr\u003E      })\u003Cbr\u003E      .catch((error) =&gt; {\u003Cbr\u003E        setError(error);\u003Cbr\u003E        setLoading(false);\u003Cbr\u003E      });\u003Cbr\u003E  }, [url]);\u003Cbr\u003E\u003Cbr\u003E  return { data, loading, error };\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EREA.09: Typing Component as a Namespace\u003C/h4\u003E\n\u003Cp\u003EMany libaries use a root component as a namespace (for example, Radix) and that means that the root is also a React function but also works as an object for other references. Using React.FC could be problematic for those cases. Instead, I prefer this approach:\u003C/p\u003E\n\u003Cpre\u003Etype SelectProps = { options: string[]; onSelect: (value: string) =&gt; void };\u003Cbr\u003E\u003Cbr\u003Econst Select = ({ options, onSelect }: SelectProps): JSX.Element =&gt; (\u003Cbr\u003E  &lt;select onChange={(e) =&gt; onSelect(e.target.value)}&gt;\u003Cbr\u003E    {options.map((option) =&gt; (\u003Cbr\u003E      &lt;option key={option} value={option}&gt;\u003Cbr\u003E        {option}\u003Cbr\u003E      &lt;/option&gt;\u003Cbr\u003E    ))}\u003Cbr\u003E  &lt;/select&gt;\u003Cbr\u003E);\u003Cbr\u003E\u003Cbr\u003ESelect.Item = ({ value }: { value: string }): JSX.Element =&gt; &lt;option&gt;{value}&lt;/option&gt;;\u003Cbr\u003ESelect.Root = (props: SelectProps): JSX.Element =&gt; &lt;Select {...props} /&gt;;\u003Cbr\u003E\u003Cbr\u003Eexport default Select;\u003C/pre\u003E\n\u003Ch4\u003EREA.10: Typing RenderProps\u003C/h4\u003E\n\u003Cp\u003EWhen you use a component as a prop, you can type it this way. For example:\u003C/p\u003E\n\u003Cpre\u003Etype RenderProps = {\u003Cbr\u003E  children: (isLoading: boolean) =&gt; JSX.Element;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst Loader = ({ children }: RenderProps): JSX.Element =&gt; {\u003Cbr\u003E  const [isLoading, setIsLoading] = useState(true);\u003Cbr\u003E  useEffect(() =&gt; {\u003Cbr\u003E    const timer = setTimeout(() =&gt; setIsLoading(false), 2000);\u003Cbr\u003E    return () =&gt; clearTimeout(timer);\u003Cbr\u003E  }, []);\u003Cbr\u003E  return children(isLoading);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.11: Typing a Hook with Generics\u003C/h4\u003E\n\u003Cp\u003EWhen using generics you need to add a comma , after T so it doesn’t get confused with JSX syntax.\u003C/p\u003E\n\u003Cpre\u003Econst useArray = &lt;T,&gt;(initialValue: T[]): {array: T[], addItem: (item: T) =&gt; void} =&gt; {\u003Cbr\u003E  const [array, setArray] = useState&lt;T[]&gt;(initialValue);\u003Cbr\u003E  const addItem = (item: T) =&gt; setArray((arr) =&gt; [...arr, item]);\u003Cbr\u003E  return {array, addItem};\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.12: Component Composition with Generics\u003C/h4\u003E\n\u003Cp\u003ETaking advantage of using T for generic types, we can create really versatile componets that render any kind of list. For example:\u003C/p\u003E\n\u003Cpre\u003Etype ListProps&lt;T&gt; = {\u003Cbr\u003E  items: T[];\u003Cbr\u003E  renderItem: (item: T) =&gt; JSX.Element;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst List = &lt;T,&gt;({ items, renderItem }: ListProps&lt;T&gt;): JSX.Element =&gt; (\u003Cbr\u003E  &lt;div&gt;{items.map(renderItem)}&lt;/div&gt;\u003Cbr\u003E);\u003C/pre\u003E\n\u003Ch4\u003EREA.13: Typing Compound Components with Context and Generics\u003C/h4\u003E\n\u003Cp\u003ESince types can be defined using generics too, we can pass the generic down to any of our props.\u003C/p\u003E\n\u003Cpre\u003Etype TabContextType&lt;T&gt; = {\u003Cbr\u003E  activeTab: T;\u003Cbr\u003E  setActiveTab: React.Dispatch&lt;React.SetStateAction&lt;T&gt;&gt;;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst TabContext = React.createContext&lt;TabContextType&lt;string&gt; | undefined&gt;(undefined);\u003Cbr\u003Econst TabProvider = ({ children }: { children: React.ReactNode }) =&gt; {\u003Cbr\u003E  const [activeTab, setActiveTab] = useState(\"home\");\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;TabContext.Provider value={{ activeTab, setActiveTab }}&gt;\u003Cbr\u003E      {children}\u003Cbr\u003E    &lt;/TabContext.Provider&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch3\u003E06. The Weird Parts of TypeScript, Common Pitfalls\u003C/h3\u003E\n\u003Ch4\u003ETWPTS.01: Accept Anything Except Null or Undefined\u003C/h4\u003E\n\u003Cp\u003EIn TypeScript, you can create types that exclude null or undefined. For example:\u003C/p\u003E\n\u003Cpre\u003Etype NonNullish&lt;T&gt; = T extends null | undefined ? never : T;\u003Cbr\u003Econst acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EInterestingly, you can simplify this by using an empty object type instead:\u003C/p\u003E\n\u003Cpre\u003Etype NonNullish&lt;T&gt; = {}; // NonNulish represents the same type as before\u003Cbr\u003Econst acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EThis works because unknown in TypeScript is defined as:\u003C/p\u003E\n\u003Cpre\u003Etype unknown = {} | undefined | null;\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.02: Typing a Truly Empty Object\u003C/h4\u003E\n\u003Cp\u003EDefining an empty object is tricky. You can use Record&lt;PropertyKey, never&gt; to enforce no properties:\u003C/p\u003E\n\u003Cpre\u003Econst acceptOnlyEmptyObject = (input: Record&lt;PropertyKey, never&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EHowever, a more foolproof approach uses a unique symbol:\u003C/p\u003E\n\u003Cpre\u003Edeclare const tag: unique symbol;\u003Cbr\u003Etype EmptyObject = { [tag]?: never };\u003C/pre\u003E\n\u003Cp\u003EThis ensures no properties are allowed, effectively representing a truly empty object.\u003C/p\u003E\n\u003Ch4\u003ETWPTS.03: Techniques for Triggering Excess Property Warnings\u003C/h4\u003E\n\u003Cp\u003ETypeScript’s assignability model is based on satisfying contracts, not exact matches. Excess property checks are only triggered under specific conditions, like inline object literals.\u003C/p\u003E\n\u003Cp\u003EHere are a few techniques for forcing excess property checks:\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EAdd a Type Annotation\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Etype User = {\u003Cbr\u003E id: number;\u003Cbr\u003E name: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Error for 'age', since it is not part of the type\u003Cbr\u003Econst obj: User = { id: 1, name: \"John\", age: 30 };\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EUse the \u003C/strong\u003E\u003Cstrong\u003Esatisfies Keyword\u003C/strong\u003E:\u003C/p\u003E\n\u003Cp\u003EWithout it, just creating the object and then passing it down to a function that demands a user type would work just fine. But, if you want to strictly enforce the same signature, use satisfies.\u003C/p\u003E\n\u003Cpre\u003Econst obj = { id: 1, name: \"John\", age: 30 } satisfies User;\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EInline the Variable\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003E//printUser requires a User type\u003Cbr\u003EprintUser({ id: 1, name: \"John\", age: 30 }); // Error for 'age'\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.04: Accessing Object Properties Using Keys\u003C/h4\u003E\n\u003Cp\u003EIf you’re iterating through object keys and want to ensure type safety, you can cast the key to a keyof the object type.\u003C/p\u003E\n\u003Cpre\u003Einterface User {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction printUser(user: User) {\u003Cbr\u003E  for (const keyProperty in user) {\u003Cbr\u003E    console.log(user[keyProperty as keyof User]);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.05: Typing Callbacks with Varying Parameters\u003C/h4\u003E\n\u003Cp\u003EIf you need a function type that can accept various argument lengths, you can define a flexible callback type:\u003C/p\u003E\n\u003Cpre\u003Etype CallbackType = (\u003Cbr\u003E  event: Event,\u003Cbr\u003E  x?: number,\u003Cbr\u003E  y?: number,\u003Cbr\u003E  screenId?: number\u003Cbr\u003E) =&gt; void;\u003Cbr\u003E\u003Cbr\u003Efunction listenToEvent(callback: CallbackType) {\u003Cbr\u003E  // callback logic\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThis allows the following calls:\u003C/p\u003E\n\u003Cpre\u003ElistenToEvent(() =&gt; {});\u003Cbr\u003ElistenToEvent((event) =&gt; {});\u003Cbr\u003ElistenToEvent((event, x, y) =&gt; {});\u003Cbr\u003ElistenToEvent((event, x, y, screenId) =&gt; {});\u003C/pre\u003E\n\u003Cp\u003EJust remember to narrow down the types inside the function to make it work properly.\u003C/p\u003E\n\u003Ch4\u003ETWPTS.06: Correctly Typing Functions that Handle Multiple Types\u003C/h4\u003E\n\u003Cp\u003EConsider a scenario where you have an object containing functions that handle different types. You want to dynamically call the correct function based on the input type:\u003C/p\u003E\n\u003Cpre\u003Econst objOfFunctions = {\u003Cbr\u003E  string: (input: string) =&gt; input.toUpperCase(),\u003Cbr\u003E  number: (input: number) =&gt; input.toFixed(2),\u003Cbr\u003E  boolean: (input: boolean) =&gt; (input ? \"true\" : \"false\"),\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ObjKeys = string | number | boolean;\u003Cbr\u003Econst format = (input: ObjKeys) =&gt; {\u003Cbr\u003E  const inputType = input as keyof typeof objOfFunctions;\u003Cbr\u003E  const formatter = objOfFunctions[inputType];\u003Cbr\u003E\u003Cbr\u003E  return formatter(input as never); // 'as never' to force correct typing\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ECPTF.01: Forgetting Non-null Assertion in Nested Structures\u003C/h4\u003E\n\u003Cp\u003EAccessing properties on nested objects without ensuring their existence can cause runtime errors.\u003C/p\u003E\n\u003Cpre\u003Etype Engine = { type: string };\u003Cbr\u003Etype Car = { engine?: Engine };\u003Cbr\u003E\u003Cbr\u003Efunction getEngineType(car: Car): string {\u003Cbr\u003E  return car.engine.type || \"\"; // Error: Object is possibly 'undefined'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe property engine is optional in Car, and TypeScript warns that type might not exist. Use optional chaining (car.engine?.type) to prevent this error.\u003C/p\u003E\n\u003Ch4\u003ECPTF.02: Not Handling Readonly Array Types Correctly\u003C/h4\u003E\n\u003Cp\u003EUsing readonly with arrays incorrectly can lead to unexpected mutations.\u003C/p\u003E\n\u003Cpre\u003Econst numbers: readonly number[] = [1, 2, 3];\u003Cbr\u003Enumbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'\u003C/pre\u003E\n\u003Cp\u003EBy default readonly arrays prevent mutation. Trying to mutate (e.g., push) will cause an error. To fix it, copy the array first if modifications are needed (const newNumbers = [...numbers, 4]).\u003C/p\u003E\n\u003Ch4\u003ECPTF.03: Promise&lt;void&gt; Usage\u003C/h4\u003E\n\u003Cp\u003EReturning Promise&lt;void&gt; can lead to issues if callers assume the promise is resolved with data.\u003C/p\u003E\n\u003Cpre\u003Easync function fetchData(): Promise&lt;void&gt; {\u003Cbr\u003E  const data = await fetch(\"https://api.example.com/data\");\u003Cbr\u003E  return data; // Error: Type 'Response' is not assignable to type 'void'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECPTF.04: Overlapping Types with Union and Intersection\u003C/h4\u003E\n\u003Cp\u003EUsing unions and intersections together can lead to unintentional overlap in types.\u003C/p\u003E\n\u003Cpre\u003Etype Bird = { wings: 2; fly: () =&gt; void };\u003Cbr\u003Etype Fish = { fins: 2; swim: () =&gt; void };\u003Cbr\u003Etype Animal = Bird | Fish;\u003Cbr\u003E\u003Cbr\u003Efunction move(animal: Animal) {\u003Cbr\u003E  if (\"swim\" in animal) {\u003Cbr\u003E    animal.swim(); // Works for Fish\u003Cbr\u003E  } else {\u003Cbr\u003E    animal.fly(); // Error: Property 'fl' does not exist on type 'Bird | Fish'\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESolution:\u003C/p\u003E\n\u003Cpre\u003Etype Bird = { wings: 2; fly: () =&gt; void };\u003Cbr\u003Etype Fish = { fins: 2; swim: () =&gt; void };\u003Cbr\u003E\u003Cbr\u003Etype Animal = Bird | Fish;\u003Cbr\u003E\u003Cbr\u003Efunction isFish(animal: Animal): animal is Fish {\u003Cbr\u003E  return \"swim\" in animal;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction move(animal: Animal) {\u003Cbr\u003E  if (isFish(animal)) {\u003Cbr\u003E    animal.swim(); // Now TypeScript knows this is a Fish\u003Cbr\u003E  } else {\u003Cbr\u003E    animal.fly(); // TypeScript knows this is a Bird\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ETypeScript can’t infer the common structure of Bird | Fish without further guards. Using custom type guards (e.g., function isFish(animal: Animal): animal is Fish) helps ensure correct property access.\u003C/p\u003E\n\u003Ch4\u003ECPTF.05: Forgetting readonly for Constants\u003C/h4\u003E\n\u003Cp\u003ENot using readonly on constants can lead to accidental mutation. In the following example adding readonly to speed would prevent unwanted modifications.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  public speed = 100; // speed should be readonly for this car\u003Cbr\u003E  accelerate() {\u003Cbr\u003E    this.speed += 10; // Modifies speed unexpectedly\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar = new Car();\u003Cbr\u003EmyCar.speed = 50; // Mistakenly changes speed\u003C/pre\u003E\n\u003Ch4\u003ECPTF.06: Overusing Type Assertions\u003C/h4\u003E\n\u003Cp\u003EOverusing as assertions can lead to ignored type errors. Type assertions (as) bypass type checks, leading to runtime errors if not used wisely. Sometimes they are necessary, but most of the time type guards (if checks) provide safer validation.\u003C/p\u003E\n\u003Cpre\u003Efunction getCarName(car: unknown): string {\u003Cbr\u003E  return (car as { name: string }).name; // Unsafe assumption that `car` has `name` property\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(getCarName({ brand: \"Toyota\" })); // Error: Cannot read property 'name'\u003C/pre\u003E\n\u003Cp\u003EA better alternative:\u003C/p\u003E\n\u003Cpre\u003Efunction getCarName(car: unknown): string {\u003Cbr\u003E  if (isCarWithName(car)) {\u003Cbr\u003E    return car.name; // Safe access, as the type is validated\u003Cbr\u003E  }\u003Cbr\u003E  throw new Error(\"Invalid car object: 'name' property is missing\");\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction isCarWithName(car: unknown): car is { name: string } {\u003Cbr\u003E  return typeof car === \"object\" &amp;&amp; car !== null &amp;&amp; \"name\" in car &amp;&amp; typeof (car as any).name === \"string\";\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(getCarName({ name: \"Toyota\" })); // Output: \"Toyota\"\u003Cbr\u003Econsole.log(getCarName({ brand: \"Toyota\" })); // Throws error: Invalid car object\u003C/pre\u003E\n\u003Ch4\u003ECPTF.07: Ignoring Optional Properties\u003C/h4\u003E\n\u003Cp\u003EOptional properties are often missed in destructuring or direct access.\u003C/p\u003E\n\u003Cpre\u003Etype Car = { make: string; model?: string };\u003Cbr\u003E\u003Cbr\u003Efunction getModel(car: Car) {\u003Cbr\u003E  return car.model.toUpperCase(); // Error: Object is possibly 'undefined'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe property model is optional, so accessing it directly without checking leads to errors. Using optional chaining (car.model?.toUpperCase()) would prevent this.\u003C/p\u003E\n\u003Ch4\u003ECPTF.08: Incorrect Use of Generic Constraints\u003C/h4\u003E\n\u003Cp\u003ESetting incorrect generic constraints can lead to unexpected type limitations.\u003C/p\u003E\n\u003Cpre\u003Efunction merge&lt;T extends string, U extends number&gt;(a: T, b: U): string {\u003Cbr\u003E  return a + b;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Emerge(\"Engine\", 1); // Works fine\u003Cbr\u003Emerge(123, 456); // Error: Argument of type 'number' is not assignable to parameter of type 'string'\u003C/pre\u003E\n\u003Cp\u003EBy limiting T to string and U to number, merge becomes too restrictive. Using a broader generic constraint (e.g., T, U) would allow more flexibility.\u003C/p\u003E\n\u003Cp\u003EA way to solve it would be too change its signature (or modify the function):\u003C/p\u003E\n\u003Cpre\u003Efunction merge&lt;T extends string, U extends number&gt;(a: T, b: U): string | number {\u003Cbr\u003E  return a + b;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003EClosing Thoughts\u003C/h3\u003E\n\u003Cp\u003EBy now, you’ve likely absorbed a lot of information, and I can’t blame you if your brain feels a little fried — mine certainly did halfway through writing this.\u003C/p\u003E\n\u003Cp\u003EWhile I believe this guide provides a solid foundation to get you started, it’s important to note that some topics — particularly when it comes to setting up TypeScript or getting into advanced generics — haven’t been fully covered here.\u003C/p\u003E\n\u003Cp\u003EThink of this guide as a springboard, but don’t stop here. There’s much more to explore as you continue to deepen your understanding.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce6844f008ad\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad\"\u003ELearn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cp\u003EWant to learn TypeScript in one post in the shortest time possible? You can. With examples. Lots of them. Save yourself lots of hours by just reading this comprehensive guide.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"Typescript logo with a crown\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJ73ynaAwbzLqZh-Nsf7Jw.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003ETS Snippets– A Quick Learning Approach\u003C/h3\u003E\n\u003Cp\u003EThis guide features minimal text and focuses on bite-sized code examples designed to quickly elevate your proficiency in TypeScript.\u003C/p\u003E\n\u003Cblockquote\u003E\u003Cem\u003EWhy snippets?\u003C/em\u003E\u003C/blockquote\u003E\n\u003Cblockquote\u003EBecause examples are easier to digest than extensive documentation, keeping the essentials front and center without the extra layers. This guide is selective and opinionated — it won’t replace full documentation, but it will get you writing TypeScript fast. Really fast.\u003C/blockquote\u003E\n\u003Cp\u003EThink of it as a jumpstart. In under an hour or two, this guide takes you from zero to coding, prioritizing simplicity and practicality.\u003C/p\u003E\n\u003Cp\u003ETopics are categorized so you can move seamlessly between sections.\u003C/p\u003E\n\u003Ch3\u003EWhat to Expect from This Mega Post\u003C/h3\u003E\n\u003Cp\u003EIn the upcoming sections, we will delve deeper into the following areas:\u003C/p\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EBasic Usage (BU)\u003C/strong\u003E: In this section, we’ll cover TypeScript’s essential building blocks, like setting up types, defining functions and more. It’s everything you need to confidently start writing TypeScript code.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ETypes (TPS), Interfaces (IN), Enums (EN)\u003C/strong\u003E: We’ll explore TypeScript’s tools for defining structured data, covering when to use types, interfaces, and enums to make your code more readable and robust.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EInference (INFR)\u003C/strong\u003E: Here, we’ll look at TypeScript’s type inference capabilities and learn how to guide the compiler when it makes assumptions that don’t align with your intentions.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EClasses (CLS), Deriving Types from Variables (DTV) and Generics (GEN)\u003C/strong\u003E: This section will dive into TypeScript’s object-oriented programming features, covering how to work with classes, derive new types from existing declarations, and use generics to write flexible and reusable code.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EUsing with React (REA)\u003C/strong\u003E: We’ll dive into typing Components. Yep, that’s it.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EThe Weird Parts (TWP) and Common Pitfalls (CPTF)\u003C/strong\u003E: We’ll dive into some quirky aspects of TypeScript that may trip you up, highlighting common pitfalls and how to avoid them for smoother coding.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Cp\u003EBy the end, you’ll have not only a deeper understanding of TypeScript but the practical know-how to apply it within your own projects and teams.\u003C/p\u003E\n\u003Cp\u003EYou won’t be the TS hero of your team, but no one will guess you started only 40 minutes ago.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003ELet’s dive in!\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003E01. Basic Usage (BU)\u003C/h3\u003E\n\u003Ch4\u003EBU.01: Basic Types in TS\u003C/h4\u003E\n\u003Cpre\u003Elet example1: string = \"Hello World!\";\u003Cbr\u003Elet example2: number = 42;\u003Cbr\u003Elet example3: boolean = true;\u003Cbr\u003Elet example4: symbol = Symbol();\u003Cbr\u003Elet example5: bigint = 123n;\u003C/pre\u003E\n\u003Ch4\u003EBU.02: Functions — Basic notation\u003C/h4\u003E\n\u003Cpre\u003Efunction calculateSpeed(distanceInKilometers: number, timeInHours: number): number {\u003Cbr\u003E  return distanceInKilometers / timeInHours;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst calculateFuelEfficiency = (kilometers: number, liters: number): number =&gt; kilometers / liters;\u003Cbr\u003Econst logCarInfo = (info: string): void =&gt; console.log(info);\u003C/pre\u003E\n\u003Ch4\u003EBU.03: Functions — Optional parameters\u003C/h4\u003E\n\u003Cpre\u003Econst formatCarDescription = (brand: string, model?: string): string =&gt; {\u003Cbr\u003E  if (!model) {\u003Cbr\u003E    return brand;\u003Cbr\u003E  }\u003Cbr\u003E  return `${brand} ${model}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.04: Functions — Default parameters\u003C/h4\u003E\n\u003Cpre\u003Econst createCar = (brand: string, year: number = 2024): string =&gt; {\u003Cbr\u003E  return `${brand}, Year: ${year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.05: Objects: Typing Object Literals (inline)\u003C/h4\u003E\n\u003Cpre\u003Econst displayCarInfo = (car: { brand: string; year: number }): string =&gt; {\u003Cbr\u003E  return `${car.brand}, Year: ${car.year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.06: Objects: Typing Objects in own type\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst displayCarInfo = (car: Car): string =&gt; {\u003Cbr\u003E  return `${car.brand}, Year: ${car.year}`;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.07: Objects: Making properties optional\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model?: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst describeCar = (car: Car): void =&gt; {\u003Cbr\u003E  const { brand, model } = car;\u003Cbr\u003E  if (model) {\u003Cbr\u003E    console.log(`${brand} ${model}`);\u003Cbr\u003E    return;\u003Cbr\u003E  }\u003Cbr\u003E  console.log(`${brand}`);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.08: Objects: Using Record for Dynamically Typing\u003C/h4\u003E\n\u003Cpre\u003Econst carFeatures: Record&lt;string, string&gt; = {};\u003Cbr\u003E\u003Cbr\u003EcarFeatures.color = \"Red\";\u003Cbr\u003EcarFeatures.transmission = \"Automatic\";\u003Cbr\u003EcarFeatures.condition = \"New\";\u003C/pre\u003E\n\u003Ch4\u003EBU.09: Arrays — Basic notation\u003C/h4\u003E\n\u003Cp\u003EPrefer the [] syntax instead of the Array&lt;&gt; one\u003C/p\u003E\n\u003Cpre\u003Etype CarInventory = {\u003Cbr\u003E  dealerId: string;\u003Cbr\u003E  carBrands: string[]; // alternatively, Array&lt;string&gt;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EBU.10: Arrays of objects\u003C/h4\u003E\n\u003Cp\u003EPrefer to define array of objects as types\u003C/p\u003E\n\u003Cpre\u003Etype Feature = {\u003Cbr\u003E  name: string;\u003Cbr\u003E  description: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype CarModel = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  features: Feature[];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst processCarModel = (carModel: CarModel) =&gt; {\u003Cbr\u003E  // Do something with the car model in here\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EprocessCarModel({\u003Cbr\u003E  brand: \"Toyota\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E  features: [\u003Cbr\u003E    { name: \"Safety Rating\", description: \"5 stars\" },\u003Cbr\u003E    { name: \"Fuel Efficiency\", description: \"30 km/L\" },\u003Cbr\u003E  ],\u003Cbr\u003E});\u003C/pre\u003E\n\u003Ch4\u003EBU.11: Rest params\u003C/h4\u003E\n\u003Cp\u003ETreat them as array\u003C/p\u003E\n\u003Cpre\u003Eexport function listCarModels(...models: string[]): string {\u003Cbr\u003E  return models.join(\", \");\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.12: Tuples\u003C/h4\u003E\n\u003Cp\u003ETuples are arrays of fixed length. Not necessarily 2 like in some coding languages. For example, useState returns a tuple.\u003C/p\u003E\n\u003Cpre\u003Econst setCarDetails = (car: [string, number]) =&gt; {\u003Cbr\u003E  const brand = car[0];\u003Cbr\u003E  const year = car[1];\u003Cbr\u003E  console.log(`Car: ${brand}, Year: ${year}`);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EsetCarDetails([\"Toyota\", 2024]);\u003C/pre\u003E\n\u003Ch4\u003EBU.13: Using Optional Tuple members in TS\u003C/h4\u003E\n\u003Cpre\u003Econst setCarSpecs = (specs: [string, number, number?]) =&gt; {\u003Cbr\u003E  const brand = specs[0];\u003Cbr\u003E  const year = specs[1];\u003Cbr\u003E  const kilometrage = specs[2];\u003Cbr\u003E\u003Cbr\u003E  console.log(`Car: ${brand}, Year: ${year}${kilometrage !== undefined ? `, Kilometrage: ${kilometrage} km` : ''}`);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EsetCarSpecs([\"Honda\", 2024]);\u003Cbr\u003EsetCarSpecs([\"Ford\", 2023, 15000]);\u003C/pre\u003E\n\u003Ch4\u003EBU.14: Using `any`\u003C/h4\u003E\n\u003Cp\u003EDon’t. The only placed allowed is when catching an error.\u003C/p\u003E\n\u003Cpre\u003Etry {\u003Cbr\u003E  someDangerousFunctionThatMightThrow();\u003Cbr\u003E} catch (error: any) { // Acceptable use of `any`\u003Cbr\u003E  console.error(\"Caught an error:\", error.message);\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.15: Typing an Event Listener\u003C/h4\u003E\n\u003Cp\u003EVoid just doesn’t care what you return. Better than any for functions.\u003C/p\u003E\n\u003Cpre\u003Econst addClickEventListener = (listener: (this: Document, ev: MouseEvent) =&gt; void) =&gt; {\u003Cbr\u003E  document.addEventListener(\"click\", listener);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EaddClickEventListener(() =&gt; {\u003Cbr\u003E  console.log(\"Clicked!\");\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003E// TypeScript will catch this as an error\u003Cbr\u003EaddClickEventListener(\u003Cbr\u003E  // @ts-expect-error\u003Cbr\u003E  \"abc\" // Incorrect type\u003Cbr\u003E);\u003C/pre\u003E\n\u003Ch4\u003EBU.16: Typing sets\u003C/h4\u003E\n\u003Cpre\u003Econst carBrands = new Set&lt;string&gt;();\u003C/pre\u003E\n\u003Ch4\u003EBU.17: Typing Maps\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carMap = new Map&lt;number, Car&gt;();\u003Cbr\u003E\u003Cbr\u003EcarMap.set(1, { brand: \"Toyota\", year: 2024 });\u003Cbr\u003EcarMap.set(2, { brand: \"Ford\", year: 2023 });\u003C/pre\u003E\n\u003Ch4\u003EBU.18: Typing Json.parse\u003C/h4\u003E\n\u003Cpre\u003Econst parsedCarData: { brand: string; year: number; } = JSON.parse('{\"brand\": \"Honda\", \"year\": 2024}');\u003C/pre\u003E\n\u003Cpre\u003Easync function fetchData(): Promise&lt;number&gt; {\u003Cbr\u003E  const response = await fetch('https://api.example.com/data');\u003Cbr\u003E  const data = await response.json(); //option b, type data\u003Cbr\u003E  return data;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EBU.20: Using Union types\u003C/h4\u003E\n\u003Cp\u003EUnion types are the “or” operator of TypeScript:\u003C/p\u003E\n\u003Cpre\u003Efunction getCarDetails(brand: string | null) {\u003Cbr\u003E  if (brand !== null) {\u003Cbr\u003E    return `Car: ${brand}`;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  return \"Unknown Car\";\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003E02. Types, Interfaces, Enums\u003C/h3\u003E\n\u003Ch4\u003EObjects introduction\u003C/h4\u003E\n\u003Cp\u003EObjects in TypeScript can be typed using either type or interface. There is a never ending war about “which one is best” the truth is, just pick one and be consistent.\u003C/p\u003E\n\u003Cp\u003EBoth are similar, but type is more flexible for unions and complex types, while interface is extendable and better for defining class structures.\u003C/p\u003E\n\u003Cp\u003EFor the sake of this opinionated guide, we will prefer types, but also will explain interfaces.\u003C/p\u003E\n\u003Ch4\u003ETypes vs. Interfaces\u003C/h4\u003E\n\u003Cul\u003E\n\u003Cli\u003EInterfaces uses extend, Types uses &amp; to add properties to a definition\u003C/li\u003E\n\u003Cli\u003ETypes match React’s declarative syntax a little bit better\u003C/li\u003E\n\u003Cli\u003EInterfaces can only type classes or objects. Types can represent other elements besides objects.\u003C/li\u003E\n\u003Cli\u003EInterfaces are slightly more performant\u003C/li\u003E\n\u003Cli\u003EInterfaces can extend several interfaces\u003C/li\u003E\n\u003Cli\u003EInterfaces can be declared several times in the same scope. The ultimate definition will be the merge of all the interfaces. Types will error with same declarations in the same scope. Forces you to use the &amp; to create mixed types.\u003C/li\u003E\n\u003Cli\u003E\u003Cstrong\u003EMostly it’s a matter of style.\u003C/strong\u003E\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch4\u003ETypes\u003C/h4\u003E\n\u003Ch4\u003ETPS.01: A basic example\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst myCar: Car = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ETPS.02: Extending a type — Using intersections\u003C/h4\u003E\n\u003Cp\u003EYou can use the &amp; to extend an existing type. That is call an \u003Cem\u003Eintersection\u003C/em\u003E. Prefer composability, using types that ‘extend’ from other types rather than adding optional props that might create ambiguity (see Unions and Narrowing)\u003C/p\u003E\n\u003Cpre\u003Etype Vehicle = {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ElectricVehicle = Vehicle &amp; {\u003Cbr\u003E  batteryCapacity: number; // in kWh\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst teslaModelS: ElectricVehicle = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ETPS.03: Typing objects dynamically\u003C/h4\u003E\n\u003Cp\u003ESometimes you want the object to have dynamic keys, but that they all match a format. For example, all the keys should be a number. For that, you can use Record&lt;&gt;\u003C/p\u003E\n\u003Cpre\u003Econst carRatings: Record&lt;string, number&gt; = {};\u003Cbr\u003E\u003Cbr\u003EcarRatings.performance = 95;\u003Cbr\u003EcarRatings.safety = 90;\u003Cbr\u003EcarRatings.comfort = 85;\u003C/pre\u003E\n\u003Ch4\u003ETPS.04: Supporting different types of Keys for Maps and Sets\u003C/h4\u003E\n\u003Cp\u003ETS has an own type that is the union of string | number | symbol. It is named PropertyKey.\u003C/p\u003E\n\u003Cpre\u003E// PropertyKey = string | number | symbol\u003Cbr\u003E\u003Cbr\u003Econst carMap = new Map&lt;PropertyKey, string&gt;();\u003Cbr\u003E\u003Cbr\u003Econst key1: string = \"brand\";\u003Cbr\u003Econst key2: number = 2024;\u003Cbr\u003Econst key3: symbol = Symbol(\"uniqueModel\");\u003Cbr\u003E\u003Cbr\u003EcarMap.set(key1, \"Toyota\");\u003Cbr\u003EcarMap.set(key2, \"Camry\");\u003Cbr\u003EcarMap.set(key3, \"SpecialEdition\");\u003C/pre\u003E\n\u003Ch4\u003ETPS.05: Restricting keys of an object to a list\u003C/h4\u003E\n\u003Cp\u003ELet’s say you want to generate an object where the keys are dynamic but restricted to a list. For example:\u003C/p\u003E\n\u003Cpre\u003Econst carConfigurations = {\u003Cbr\u003E  sedan: {\u003Cbr\u003E    fuelType: \"petrol\",\u003Cbr\u003E    doors: 4,\u003Cbr\u003E  },\u003Cbr\u003E  suv: {\u003Cbr\u003E    fuelType: \"diesel\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E  hatchback: {\u003Cbr\u003E    fuelType: \"electric\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAs you can see they all follow the same structure, yet you may want to add other environments. The way to type is to create a list of those possible keys:\u003C/p\u003E\n\u003Cpre\u003Etype CarType = 'sedan' | 'suv' | 'hatchback';\u003Cbr\u003E\u003Cbr\u003Etype CarConfigurations = {\u003Cbr\u003E  [Type in CarType]: {\u003Cbr\u003E    fuelType: string;\u003Cbr\u003E    doors: number;\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carConfigurations: CarConfigurations = {\u003Cbr\u003E  sedan: {\u003Cbr\u003E    fuelType: \"petrol\",\u003Cbr\u003E    doors: 4,\u003Cbr\u003E  },\u003Cbr\u003E  suv: {\u003Cbr\u003E    fuelType: \"diesel\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E  hatchback: {\u003Cbr\u003E    fuelType: \"electric\",\u003Cbr\u003E    doors: 5,\u003Cbr\u003E  },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAlternatively, this could be annotated too as:\u003C/p\u003E\n\u003Cpre\u003Etype CarType = 'sedan' | 'suv' | 'hatchback';\u003Cbr\u003E\u003Cbr\u003Etype Configurations = Record&lt;\u003Cbr\u003E  CarType,\u003Cbr\u003E  { apiBaseUrl: string; timeout: number; }\u003Cbr\u003E &gt;\u003Cbr\u003E\u003Cbr\u003Econst carConfigurations: CarConfigurations = {...} // the same object as before\u003C/pre\u003E\n\u003Ch4\u003ETPS.06: Creating a type that is a ‘slice’ from another one: Pick\u003C/h4\u003E\n\u003Cp\u003EPick allows to create a ‘slice’ of a type. Prefer using type composition (see second example). You can’t pick a key that doesn’t exist on the type.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  color: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype PickedCar = Pick&lt;Car, 'brand' | 'model'&gt;;\u003Cbr\u003E\u003Cbr\u003Econst TeslaCar: PickedCar = {brand: 'Tesla', model: 'CyberTruck'}\u003C/pre\u003E\n\u003Ch4\u003ETPS.07: Creating a type that is a ‘slice’ from another one: Omit\u003C/h4\u003E\n\u003Cp\u003ELike pick, but the opposite. Instead of keeping the marked keys, it removes them. Omit won’t complain if you pass a key that wasn’t declared 🤷\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  color: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst addCar = (carInfo: Omit&lt;Car, 'id'&gt;) =&gt; {\u003Cbr\u003E  // Do something with the carInfo\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EaddCar({\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  year: 2024,\u003Cbr\u003E  color: \"Metallic\",\u003Cbr\u003E});\u003C/pre\u003E\n\u003Ch4\u003ETPS.08: Creating a type that is a ‘slice’ from another one: Omit in unions\u003C/h4\u003E\n\u003Cp\u003EOmit isn’t distributive.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  capacity: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Motorcycle = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  cc: number;\u003Cbr\u003E  imageId: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Car | Truck | Motorcycle;\u003Cbr\u003E\u003Cbr\u003Etype VehicleWithoutId = Omit&lt;Vehicle, \"id\"&gt;;\u003C/pre\u003E\n\u003Cp\u003EThe reason this happens is due to a technicality of how Omit processes union types.\u003C/p\u003E\n\u003Cp\u003EOmit doesn’t iterate over every member of the union. Instead, it squashes the union into a structure it comprehends, and then operates on this new construct. As a result, the outcome is different than what you might expect. To remedy this, let’s take a look at DistributiveOmit\u003C/p\u003E\n\u003Ch4\u003ETPS.09: DistributiveOmit\u003C/h4\u003E\n\u003Cp\u003EFollowing the previous snippet, if you want to create an union where ‘id’ is ommited in each case, you can apply a distributive omit:\u003C/p\u003E\n\u003Cpre\u003Etype DistributiveOmit&lt;T, K extends PropertyKey&gt; = T extends any\u003Cbr\u003E  ? Omit&lt;T, K&gt;\u003Cbr\u003E  : never;\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Car | Truck | Motorcycle;\u003Cbr\u003Etype VehicleWithoutId = DistributiveOmit&lt;Vehicle, \"id\"&gt;;\u003C/pre\u003E\n\u003Ch4\u003ETPS.10: Using Partials\u003C/h4\u003E\n\u003Cp\u003ESometimes, for example updates, you only want to pass 1 property to update.\u003C/p\u003E\n\u003Cp\u003EIt is tempting to fix it by making all props optional with ? but that would change the definition of Product, and that isn’t what we want.\u003C/p\u003E\n\u003Cp\u003EThe solution is to use Partial . Partial makes all the definition optional, like if it where with ?.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E  description: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst updateCar = (id: number, carInfo: Partial&lt;Omit&lt;Car, \"id\"&gt;&gt;) =&gt; {\u003Cbr\u003E  // Do something with the carInfo\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E});\u003Cbr\u003E\u003Cbr\u003EupdateCar(1, {\u003Cbr\u003E  year: 2024,\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ENote: Partial doesn’t support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.\u003C/p\u003E\n\u003Ch4\u003ETPS.11: Using Required\u003C/h4\u003E\n\u003Cp\u003EThe Required utility type in TypeScript does the opposite of Partial—it makes all properties mandatory. This is useful when you want to ensure that every property of an object must be provided.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year?: number; \u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst createCar = (carInfo: Required&lt;Car&gt;) =&gt; {\u003Cbr\u003E  console.log(carInfo);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EcreateCar({\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  year: 2024\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ENote: Same as Partial, Required doesn’t support specific keys out of the box, so you need to mix it with Omit and Pick to achieve that.\u003C/p\u003E\n\u003Ch4\u003ETPS.12: Partial, Required, Pick, mixed together\u003C/h4\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year?: number; // Optional\u003Cbr\u003E  color?: string; // Optional\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Make only 'brand' and 'model' required, while 'id', 'year', and 'color' remain optional\u003Cbr\u003Etype PartialCarWithRequired = Partial&lt;Car&gt; &amp; Required&lt;Pick&lt;Car, 'brand' | 'model'&gt;&gt;;\u003Cbr\u003E\u003Cbr\u003Econst createCar: PartialCarWithRequired = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E  // id, year, and color can be omitted\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(createCar);\u003C/pre\u003E\n\u003Ch4\u003ETPS.13: Using Readonly\u003C/h4\u003E\n\u003Cp\u003EThe Readonly utility type allows you to create a type with all properties of an existing type set to \u003Cstrong\u003Ereadonly\u003C/strong\u003E. This means that the properties cannot be reassigned, providing a way to enforce immutability in your data structures. This is particularly useful when you want to ensure that certain data should not be changed after it has been created.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Create a readonly version of Car\u003Cbr\u003Etype ReadonlyCar = Readonly&lt;Car&gt;;\u003Cbr\u003E\u003Cbr\u003Econst car: ReadonlyCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"CyberTruck\",\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EUsing it in arrays:\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ReadonlyCarArray = readonly Car[];\u003Cbr\u003E//alternatively \u003Cbr\u003E//type ReadonlyCarArray = ReadonlyArray&lt;Car&gt;;\u003Cbr\u003E\u003Cbr\u003Econst cars: ReadonlyCarArray = [\u003Cbr\u003E  { id: 1, brand: \"Tesla\", model: \"CyberTruck\" },\u003Cbr\u003E  { id: 2, brand: \"Ford\", model: \"F-150\" },\u003Cbr\u003E];\u003C/pre\u003E\n\u003Ch4\u003ETPS.14: Using NonNullable\u003C/h4\u003E\n\u003Cp\u003EThe NonNullable utility type is used to exclude null and undefined from a type. This is helpful when you want to ensure that a value is defined and not null, which can prevent runtime errors related to dereferencing null or undefined values.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  model: string | null;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Create a version of Car with a non-nullable model\u003Cbr\u003Etype NonNullableCar = {\u003Cbr\u003E  id: number;\u003Cbr\u003E  model: NonNullable&lt;Car['model']&gt;;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst car: NonNullableCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  model: \"Tesla\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Assigning null will cause a compilation error\u003Cbr\u003E// car.model = null; // Error: Type 'null' is not assignable to type 'string'.\u003C/pre\u003E\n\u003Ch4\u003EInterfaces\u003C/h4\u003E\n\u003Cp\u003EInterfaces in TypeScript allow you to define the shape of objects and can be used in a similar way to types. They are particularly useful for defining class structures and can also be extended, providing a flexible way to create complex data structures. They suit better for classes.\u003C/p\u003E\n\u003Ch4\u003EINT.01: Basic Interface Definition\u003C/h4\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Which in this case could had been the same as:\u003Cbr\u003E// type Car = {\u003Cbr\u003E//   model: string;\u003Cbr\u003E//   year: number;\u003Cbr\u003E// }\u003Cbr\u003E\u003Cbr\u003Econst vehicle: Car = {\u003Cbr\u003E  model: \"Tesla Model 3\",\u003Cbr\u003E  year: 2020,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.02: Extending Interfaces\u003C/h4\u003E\n\u003Cp\u003EYou can create new interfaces by extending existing ones. This helps you build on top of existing structures without repeating code. This would be the way to compose other interfaces, the same way that types uses intersections, interfaces extend.\u003C/p\u003E\n\u003Cpre\u003Einterface Vehicle {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Einterface ElectricCar extends Vehicle {\u003Cbr\u003E  batteryCapacity: number; // in kWh\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst teslaModelS: ElectricCar = {\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.03: Squashing Interfaces in the Same Namespace\u003C/h4\u003E\n\u003Cp\u003EOne of the powerful features of interfaces is that they can be declared multiple times within the same scope. TypeScript automatically merges these declarations, allowing you to add properties to an interface as needed.\u003C/p\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Einterface Car {\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar: Car = {\u003Cbr\u003E  brand: \"Toyota\",\u003Cbr\u003E  model: \"Camry\",\u003Cbr\u003E  year: 2021,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.04: Extending Interfaces with Function Types\u003C/h4\u003E\n\u003Cp\u003EInterfaces can also define function types, enabling you to type functions more explicitly.\u003C/p\u003E\n\u003Cpre\u003Einterface CarProcessor {\u003Cbr\u003E  (car: Car): void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst processCar: CarProcessor = (car) =&gt; {\u003Cbr\u003E  console.log(`Processing car: ${car.brand} ${car.model}`);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.05: Namespaced Interfaces\u003C/h4\u003E\n\u003Cp\u003EYou can use namespaces to group related interfaces together, helping to organize your code better. Since ES Modules, this feature is less common, and prefered to be avoided.\u003C/p\u003E\n\u003Cpre\u003Enamespace CarModule {\u003Cbr\u003E  export interface Car {\u003Cbr\u003E    id: number;\u003Cbr\u003E    brand: string;\u003Cbr\u003E    model: string;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  export interface ElectricCar extends Car {\u003Cbr\u003E    batteryCapacity: number;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst tesla: CarModule.ElectricCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E  batteryCapacity: 100,\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.06: Optional Properties\u003C/h4\u003E\n\u003Cp\u003EInterfaces can have optional properties, allowing you to define flexible structures\u003C/p\u003E\n\u003Cpre\u003Einterface Car {\u003Cbr\u003E  id: number;\u003Cbr\u003E  brand: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  color?: string; // Optional property\u003Cbr\u003E}const tesla: Car = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model 3\",\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINT.07: Readonly Properties\u003C/h4\u003E\n\u003Cp\u003ETo create properties that cannot be modified after their initial assignment, you can use the readonly modifier.\u003C/p\u003E\n\u003Cpre\u003Einterface ImmutableUser {\u003Cbr\u003Einterface ImmutableCar {\u003Cbr\u003E  readonly id: number;\u003Cbr\u003E  readonly brand: string;\u003Cbr\u003E  readonly model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar: ImmutableCar = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  brand: \"Tesla\",\u003Cbr\u003E  model: \"Model S\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// myCar.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.\u003C/pre\u003E\n\u003Ch3\u003EEnums\u003C/h3\u003E\n\u003Ch4\u003EEN.01: Enums — Please Don’t use them\u003C/h4\u003E\n\u003Cp\u003EEnums are widely unused since there are more modern approaches. Visit \u003Ca href=\"https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh#:~:text=Excessive%20use%20of%20regular%20ENUMs,new%20values%20can%20be%20added.\"\u003Ehere\u003C/a\u003E for more details.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Eenum CarType {\u003Cbr\u003E  SEDAN = \"sedan\",\u003Cbr\u003E  SUV = \"suv\",\u003Cbr\u003E  TRUCK = \"truck\",\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction createCar(type: CarType) {\u003Cbr\u003E  // Implementation here\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003EcreateCar(CarType.SEDAN); // Valid\u003Cbr\u003EcreateCar('sedan'); // Invalid\u003C/pre\u003E\n\u003Cp\u003EInstead, use as const combined with exporting the union of values:\u003C/p\u003E\n\u003Cpre\u003Eexport const CarTypes = {\u003Cbr\u003E  SEDAN: \"sedan\",\u003Cbr\u003E  SUV: \"suv\",\u003Cbr\u003E  TRUCK: \"truck\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003E// Exporting the type derived from the CarTypes constant\u003Cbr\u003Eexport type CarType = typeof CarTypes[keyof typeof CarTypes];\u003Cbr\u003E\u003Cbr\u003Econst handlerFunction = (carType: CarType) =&gt; {\u003Cbr\u003E  if (carType === CarTypes.SEDAN) {\u003Cbr\u003E    return 'This is a sedan';\u003Cbr\u003E  }\u003Cbr\u003E  return 'This is not a sedan';\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003EhandlerFunction('sedan'); // This will work\u003Cbr\u003EhandlerFunction(CarTypes.SEDAN); // This will work too.\u003C/pre\u003E\n\u003Ch4\u003EEN.02: Exporting nested enums as a flatten entity\u003C/h4\u003E\n\u003Cpre\u003Etype ApiEndpoint =\u003Cbr\u003E  | `/${string}`\u003Cbr\u003E  | Record&lt;string, ApiEndpoint&gt;;\u003Cbr\u003E\u003Cbr\u003Econst apiEndpoints = {\u003Cbr\u003E  cards: {\u003Cbr\u003E    GET_ALL: '/cards',\u003Cbr\u003E    GET_BY_ID: '/cards/:id',\u003Cbr\u003E    CREATE: '/cards/create',\u003Cbr\u003E    UPDATE: '/cards/update/:id',\u003Cbr\u003E    DELETE: '/cards/delete/:id',\u003Cbr\u003E    CATEGORIES: {\u003Cbr\u003E      GET_ALL: '/cards/categories',\u003Cbr\u003E      GET_BY_ID: '/cards/categories/:id',\u003Cbr\u003E      CREATE: '/cards/categories/create',\u003Cbr\u003E      UPDATE: '/cards/categories/update/:id',\u003Cbr\u003E      DELETE: '/cards/categories/delete/:id',\u003Cbr\u003E    },\u003Cbr\u003E    TAGS: {\u003Cbr\u003E      GET_ALL: '/cards/tags',\u003Cbr\u003E      GET_BY_ID: '/cards/tags/:id',\u003Cbr\u003E      CREATE: '/cards/tags/create',\u003Cbr\u003E      UPDATE: '/cards/tags/update/:id',\u003Cbr\u003E      DELETE: '/cards/tags/delete/:id',\u003Cbr\u003E    },\u003Cbr\u003E  },\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype Flatten&lt;T&gt; = T extends Record&lt;string, infer U&gt; ? Flatten&lt;U&gt; : T;\u003Cbr\u003E\u003Cbr\u003Eexport type ApiEndpoints = Flatten&lt;typeof apiEndpoints&gt;;\u003Cbr\u003E\u003Cbr\u003Econst someEndpoint: ApiEndpoints = apiEndpoints.cards.GET_ALL;\u003Cbr\u003Econst someOtherEndpoint: ApiEndpoints = '/cards/categories';\u003C/pre\u003E\n\u003Ch3\u003E03. Inference\u003C/h3\u003E\n\u003Cp\u003EInference is the way that TS ‘guesses’ what type some variable is. Sometimes, you need to help it a bit.\u003C/p\u003E\n\u003Ch4\u003EINFR.01: Inference: let and const change the way TS assigns types\u003C/h4\u003E\n\u003Cp\u003EUsing let allows reassignment, resulting in the type being inferred as string. In contrast, const can’t be reassigned, leading TypeScript to infer its type as a literal.\u003C/p\u003E\n\u003Cp\u003EFor example:\u003C/p\u003E\n\u003Cpre\u003Elet type = \"sedan\"; // inferred as string, because it can be reassigned\u003C/pre\u003E\n\u003Cp\u003EWhile:\u003C/p\u003E\n\u003Cpre\u003Econst type = \"sedan\"; // inferred as 'sedan' because it can't be reassigned\u003C/pre\u003E\n\u003Ch4\u003EINFR.02: Object property inference\u003C/h4\u003E\n\u003Cp\u003ETypeScript’s type inference can sometimes lead to unintended results when inferring object properties. Since objects are dynamically typed, a string in a key will default to string instead of maybe a literal.\u003C/p\u003E\n\u003Cp\u003EMost of the time, if you are using an approach like the following one, TS will infer ‘strings’ instead of your assigned type ButtonAttributes. To avoid that, just add the type.\u003C/p\u003E\n\u003Cp\u003EThis will error:\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: \"sedan\", // inferred as string\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes); // will error\u003C/pre\u003E\n\u003Cp\u003EBut this won’t\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  type: \"sedan\",\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.03: Using ‘as const’ to force inference\u003C/h4\u003E\n\u003Cp\u003EThe same example as before can be solved by instructing TS that it should be considered as const.\u003C/p\u003E\n\u003Cp\u003Eas const not only locks the type to a specific literal but also makes the properties of the object readonly. Better to use a type if you can, but sometimes this trick will also do. It all depends on if you want that readonly attribute as well or not.\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: 'sedan' | 'suv' | 'truck';\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: 'sedan' as const,\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.04: Using ‘satisfies’\u003C/h4\u003E\n\u003Cp\u003EAnother way to solve the previous issue is using satisfies. satisfies helps in the case the object doesn’t have the same structure as the type.\u003C/p\u003E\n\u003Cp\u003EUsing satisfies checks the object against the type at compile-time without requiring the object to match the type structure perfectly, thus enhancing flexibility.\u003C/p\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: 'sedan' | 'suv' | 'truck';\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst modifyCar = (attributes: CarAttributes) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes = {\u003Cbr\u003E  type: 'sedan',\u003Cbr\u003E} satisfies CarAttributes;\u003Cbr\u003E\u003Cbr\u003EmodifyCar(carAttributes);\u003C/pre\u003E\n\u003Ch4\u003EINFR.05: ‘Readonly’ and ‘as const’\u003C/h4\u003E\n\u003Cp\u003EUsing as const on an object makes it readonly, eliminating the need to define the type explicitly. This is important because immutability ensures that the values of properties can’t be changed after the object is created, reducing the risk of unintended side effects in your code.\u003C/p\u003E\n\u003Cp\u003EThe 2 following snippets are exactly the same:\u003C/p\u003E\n\u003Cpre\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  sport: {\u003Cbr\u003E    type: \"sedan\",\u003Cbr\u003E  },\u003Cbr\u003E  utility: {\u003Cbr\u003E    type: \"suv\",\u003Cbr\u003E  },\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype CarType = \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E\u003Cbr\u003Etype CarAttributes = {\u003Cbr\u003E  readonly sport: {\u003Cbr\u003E    readonly type: CarType;\u003Cbr\u003E  };\u003Cbr\u003E  readonly utility: {\u003Cbr\u003E    readonly type: CarType;\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  sport: {\u003Cbr\u003E    type: \"sedan\",\u003Cbr\u003E  },\u003Cbr\u003E  utility: {\u003Cbr\u003E    type: \"suv\",\u003Cbr\u003E  },\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EAs you can see, using as const is a nice shortcut for those readonly properties.\u003C/p\u003E\n\u003Ch4\u003EINFR.06: Function Overloading\u003C/h4\u003E\n\u003Cp\u003EFunction overloading allows you to define multiple signatures for a function, enabling it to accept different parameter types and return different types based on the parameters provided.\u003C/p\u003E\n\u003Cp\u003EIn an ideal world, this kind of thing shouldn’t happen often, but if you have some kind of “master” function that handles many cases with many types, it can be useful.\u003C/p\u003E\n\u003Cp\u003EThis can improve code readability and maintainability by allowing a single function name to handle multiple use cases.\u003C/p\u003E\n\u003Cp\u003ENeedless to say, try to avoid this kind of thing.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Efunction processCar(input: string): boolean; // Returns a boolean\u003Cbr\u003Efunction processCar(input: number): string; // Returns a string\u003Cbr\u003Efunction processCar(input: boolean): number; // Returns a number\u003Cbr\u003Efunction processCar(input: string | number | boolean): boolean | string | number {\u003Cbr\u003E  if (typeof input === \"string\") {\u003Cbr\u003E    return input.length &gt; 0; // Returns true if the string is non-empty\u003Cbr\u003E  } else if (typeof input === \"number\") {\u003Cbr\u003E    return `The car count is ${input}.`; // Returns a string representation\u003Cbr\u003E  } else if (typeof input === \"boolean\") {\u003Cbr\u003E    return input ? 1 : 0; // Returns 1 for true and 0 for false\u003Cbr\u003E  }\u003Cbr\u003E  throw new Error(\"Invalid input type.\");\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.07: Type Guards\u003C/h4\u003E\n\u003Cp\u003EType guards are a feature that allow you to narrow down the type of a variable within a conditional block. This can enhance type safety and prevent runtime errors by ensuring that the operations performed on variables are valid for their types.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EExample\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Efunction logCar(value: string | number) {\u003Cbr\u003E  if (typeof value === \"string\") {\u003Cbr\u003E    console.log(`Car model: ${value}`);\u003Cbr\u003E  } else { // TS would know that value is a number\u003Cbr\u003E    console.log(`Car ID: ${value}`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.08: Scope Narrowing\u003C/h4\u003E\n\u003Cp\u003ESometimes TS won’t be able to detect the type of a variable. Lowering the declaration of the variable to the same scope sometimes fixes it:\u003C/p\u003E\n\u003Cpre\u003Econst findCarsByModel = (\u003Cbr\u003E  searchParams: { model?: string },\u003Cbr\u003E  cars: {\u003Cbr\u003E    id: string;\u003Cbr\u003E    model: string;\u003Cbr\u003E  }[],\u003Cbr\u003E) =&gt; {\u003Cbr\u003E  if (searchParams.model) {\u003Cbr\u003E    const { model } = searchParams; // Scope narrowing to avoid errors\u003Cbr\u003E    return cars.filter((car) =&gt; car.model.includes(model));\u003Cbr\u003E  }\u003Cbr\u003E  return cars;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINFR.09: Discriminated Unions and Types: don’t use one type to try to cover several entities (avoid ambiguity, segregate the entities)\u003C/h4\u003E\n\u003Cp\u003EIn this example Vehicle can represent both a circle and a rectangle. But it is not clear:\u003C/p\u003E\n\u003Cpre\u003Etype Vehicle = {\u003Cbr\u003E  kind: string;\u003Cbr\u003E  horsepower?: number;\u003Cbr\u003E  seatingCapacity?: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Efunction getSpecifications(vehicle: Vehicle) {\u003Cbr\u003E  if (vehicle.kind === \"sedan\") {\u003Cbr\u003E    return `Seating Capacity: ${vehicle.seatingCapacity}`;\u003Cbr\u003E  } else {\u003Cbr\u003E    return `Horsepower: ${vehicle.horsepower}`;\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EInstead:\u003C/p\u003E\n\u003Cpre\u003Etype Sedan = {\u003Cbr\u003E  kind: 'sedan';\u003Cbr\u003E  seatingCapacity: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  kind: \"truck\";\u003Cbr\u003E  horsepower: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Vehicle = Sedan | Truck;\u003Cbr\u003E\u003Cbr\u003Efunction getSpecifications(vehicle: Vehicle) {\u003Cbr\u003E  if (vehicle.kind === \"sedan\") {\u003Cbr\u003E    return `Seating Capacity: ${vehicle.seatingCapacity}`;\u003Cbr\u003E  }\u003Cbr\u003E  return `Horsepower: ${vehicle.horsepower}`;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EINFR.10: Avoid using ‘let’ without types:\u003C/h4\u003E\n\u003Cpre\u003Etype CarAttributes = {\u003Cbr\u003E  type: \"sedan\" | \"suv\" | \"truck\";\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Elet type = \"sedan\"; // inferred as string, using a const would prevent this\u003Cbr\u003E\u003Cbr\u003Econst carAttributes: CarAttributes = {\u003Cbr\u003E  type, // error due to inferred string type\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EINFR.11: The ‘Never’ Type\u003C/h4\u003E\n\u003Cp\u003EThe never type in TypeScript represents a value that never occurs. It's used in functions that throw errors or have infinite loops, as they never return a value.\u003C/p\u003E\n\u003Cpre\u003Efunction throwError(message: string): never {\u003Cbr\u003E  throw new Error(message);\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EIt also represents incompatible types. For example: string &amp; number is going to be never.\u003C/p\u003E\n\u003Cpre\u003Etype Car = {\u003Cbr\u003E  id: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Truck = {\u003Cbr\u003E  id: number; // incompatible with Car's id\u003Cbr\u003E  model: string;\u003Cbr\u003E  payloadCapacity: number;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst impossible: Car &amp; Truck = {\u003Cbr\u003E  id: 'C123', // error because id must be both string and number, which is impossible\u003Cbr\u003E  model: 'X1',\u003Cbr\u003E  payloadCapacity: 3000\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch3\u003E04. Classes, deriving types, Generics\u003C/h3\u003E\n\u003Ch4\u003EClasses\u003C/h4\u003E\n\u003Ch4\u003ECLS.01: Default properties\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  readonly make: string;\u003Cbr\u003E  readonly model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(make = \"Generic\", model = \"Model\") {\u003Cbr\u003E    this.make = make;\u003Cbr\u003E    this.model = model;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E// Equivalent to:\u003Cbr\u003Eclass Car {\u003Cbr\u003E  readonly make: string = \"Generic\";\u003Cbr\u003E  readonly model: string = \"Model\";\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.02: Creating Constructors\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make = \"Generic\";\u003Cbr\u003E  model = \"Model\";\u003Cbr\u003E\u003Cbr\u003E  constructor(opts?: { make: string; model: string } = { make: \"Generic\", model: \"Model\" }) {\u003Cbr\u003E    this.make = opts.make;\u003Cbr\u003E    this.model = opts.model;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.03: Declaring Methods\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make = \"Generic\";\u003Cbr\u003E  model = \"Model\";\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.04: Getters\u003C/h4\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.make, model: this.model };\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.05: Private properties\u003C/h4\u003E\n\u003Cp\u003EYou can use the private or # prefix in the member declaration to make it private. Both ways will work, it is a matter of style.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  private make: string;\u003Cbr\u003E  private model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.make, model: this.model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Or with `#` prefix:\u003Cbr\u003Eclass Car {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.#make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.06: Setters\u003C/h4\u003E\n\u003Cp\u003ETS understands the type of the setter by checking the getter. No need to define the type.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(details?: { make: string; model: string }) {\u003Cbr\u003E    this.#make = details?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = details?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  // since the get details returns an object with make and model, the set expects the same signature\u003Cbr\u003E  set details(details) {\u003Cbr\u003E    this.#make = details.make;\u003Cbr\u003E    this.#model = details.model;\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.07: Overriding\u003C/h4\u003E\n\u003Cp\u003EIf in the tsConfig the option noImplicitOverride is turned on, you will need to add the override keyword when extending a method from an inherited class.\u003C/p\u003E\n\u003Cpre\u003E// inside tsconfig.json\u003Cbr\u003E{\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    ...\u003Cbr\u003E    \"noImplicitOverride\": true\u003C/pre\u003E\n\u003Cpre\u003Eclass Vehicle {\u003Cbr\u003E  logType() {\u003Cbr\u003E    console.log(\"Vehicle type\");\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eclass Car extends Vehicle {\u003Cbr\u003E  override logType() {\u003Cbr\u003E    console.log(\"Car type\");\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.08: Implementing a ‘type’ or ‘interface’\u003C/h4\u003E\n\u003Cp\u003EClasses can implement interfaces or types. Stick to using interfaces. As you can see, it can handle both, but the industry prefers the first one.\u003C/p\u003E\n\u003Cpre\u003Einterface VehicleOptions {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype VehicleType = {\u003Cbr\u003E  details: { make: string; model: string };\u003Cbr\u003E  drive: (speed: number) =&gt; void;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eclass Car implements VehicleType {\u003Cbr\u003E  #make: string;\u003Cbr\u003E  #model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(initial?: VehicleOptions) {\u003Cbr\u003E    this.#make = initial?.make ?? \"Generic\";\u003Cbr\u003E    this.#model = initial?.model ?? \"Model\";\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  get details() {\u003Cbr\u003E    return { make: this.#make, model: this.#model };\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  drive(speed: number) {\u003Cbr\u003E    console.log(`Driving at ${speed} mph.`);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.09: Abstract Classes\u003C/h4\u003E\n\u003Cp\u003Eabstract classes allow you to define methods that subclasses must implement, as well as methods with default behavior. This is useful when designing base classes for other classes to extend.\u003C/p\u003E\n\u003Cpre\u003Eabstract class Vehicle {\u003Cbr\u003E  abstract speed(): number;\u003Cbr\u003E\u003Cbr\u003E  describe(): string {\u003Cbr\u003E    return \"This is a vehicle.\";\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eclass Car extends Vehicle {\u003Cbr\u003E  constructor(public maxSpeed: number) {\u003Cbr\u003E    super();\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  speed(): number {\u003Cbr\u003E    return this.maxSpeed;\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECLS.10: Static Properties and Methods\u003C/h4\u003E\n\u003Cp\u003Estatic members belong to the class itself rather than to any specific instance. This is useful for utility functions or properties that should be shared across all instances. So far, the static is nothing new to TS.\u003C/p\u003E\n\u003Cpre\u003Eclass VehicleUtils {\u003Cbr\u003E  static MAX_SPEED = 120;\u003Cbr\u003E\u003Cbr\u003E  static calculateDistance(time: number) {\u003Cbr\u003E    return this.MAX_SPEED * time;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(VehicleUtils.calculateDistance(2)); // 240\u003C/pre\u003E\n\u003Ch4\u003ECLS.11: Parameter Properties\u003C/h4\u003E\n\u003Cp\u003EThis shorthand allows you to define and initialize class members directly in the constructor’s parameter list, reducing boilerplate code.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  constructor(public make: string = \"Generic\", public model: string = \"Model\") {}\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst car = new Car(\"Toyota\", \"Corolla\");\u003Cbr\u003Econsole.log(car.make); // Toyota\u003C/pre\u003E\n\u003Cp\u003EThis equals to:\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  public make: string;\u003Cbr\u003E  public model: string;\u003Cbr\u003E\u003Cbr\u003E  constructor(make: string = \"Generic\", model: string = \"Model\") {\u003Cbr\u003E    this.make = make;\u003Cbr\u003E    this.model = model;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst car = new Car(\"Toyota\", \"Corolla\");\u003Cbr\u003Econsole.log(car.make); // Toyota\u003C/pre\u003E\n\u003Cp\u003EInstead of declaring properties and assigning them in the constructor, parameter properties allow you to do both in a single step, making your class definitions more concise.\u003C/p\u003E\n\u003Ch4\u003EDTV.01: Deriving Types from Variables\u003C/h4\u003E\n\u003Cp\u003EDeriving types from existing values or variables is a powerful feature in TypeScript, allowing you to dynamically infer types based on data structures, function signatures, and constants. Here’s a comprehensive guide on different techniques for deriving types in TypeScript.\u003C/p\u003E\n\u003Cp\u003EThis allows for a more dynamic and type-safe approach to working with complex data structures. Let’s explore key techniques like keyof, typeof, and more.\u003C/p\u003E\n\u003Ch4\u003EDTV.02: The ‘keyof’ Operator\u003C/h4\u003E\n\u003Cp\u003EThe keyof operator creates a union of string literal types from the keys of an interface or object. This is particularly useful for creating flexible types.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Einterface CarSpecs {\u003Cbr\u003E  make: string;\u003Cbr\u003E  model: string;\u003Cbr\u003E  year: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// carDetails will need to have the same keys as the interface\u003Cbr\u003Econst carDetails: Record&lt;keyof CarSpecs, { description: string; value: string | number }&gt; = {\u003Cbr\u003E  make: { description: \"Car Make\", value: \"Toyota\" },\u003Cbr\u003E  model: { description: \"Car Model\", value: \"Corolla\" },\u003Cbr\u003E  year: { description: \"Manufacturing Year\", value: 2021 },\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EHere, keyof CarSpecs creates a union of \"make\" | \"model\" | \"year\", allowing carDetails to have the same keys as CarSpecs.\u003C/p\u003E\n\u003Ch4\u003EDTV.03: The 'typeof' Operator\u003C/h4\u003E\n\u003Cp\u003EThe typeof operator can be used to derive types directly from variables or objects.\u003C/p\u003E\n\u003Cp\u003EFor example:\u003C/p\u003E\n\u003Cpre\u003Econst configurations = {\u003Cbr\u003E  development: {\u003Cbr\u003E    apiBaseUrl: 'http://localhost:8080',\u003Cbr\u003E    timeout: 5000,\u003Cbr\u003E  },\u003Cbr\u003E  production: {\u003Cbr\u003E    apiBaseUrl: 'https://api.example.com',\u003Cbr\u003E    timeout: 10000,\u003Cbr\u003E  },\u003Cbr\u003E  staging: {\u003Cbr\u003E    apiBaseUrl: 'https://staging.example.com',\u003Cbr\u003E    timeout: 8000,\u003Cbr\u003E  },\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype Environment = keyof typeof configurations; // 'development' | 'production' | 'staging'\u003C/pre\u003E\n\u003Cp\u003EIn this case, keyof typeof configurations extracts the keys ('development', 'production', 'staging') as a union type.\u003C/p\u003E\n\u003Ch4\u003EDTV.04: You Can Create Types from Values, but Not Values from Types\u003C/h4\u003E\n\u003Cp\u003Etypes and interfaces in TypeScript are erased at runtime, which means you can only derive types from existing values, but not the other way around. Type information doesn’t exist at runtime and only helps in static checking during development.\u003C/p\u003E\n\u003Ch4\u003EDTV.05: Deriving Types with Classes\u003C/h4\u003E\n\u003Cp\u003EClasses can be used as types directly in TypeScript. Any instance of a class can be typed as the class itself.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Eclass CarPosition {\u003Cbr\u003E  x = 0;\u003Cbr\u003E  y = 0;\u003Cbr\u003E\u003Cbr\u003E  move(x: number, y: number) {\u003Cbr\u003E    this.x = x;\u003Cbr\u003E    this.y = y;\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst positionFromCar = (position: CarPosition) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    x: position.x,\u003Cbr\u003E    y: position.y,\u003Cbr\u003E  };\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EHere, CarPosition serves both as a class and a type.\u003C/p\u003E\n\u003Ch4\u003EDTV.06: Using the Same Name for Values and Types\u003C/h4\u003E\n\u003Cp\u003EYou can have the same name for a type and a constant.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Eexport const Logger = {\u003Cbr\u003E  log: (message: string) =&gt; console.log(message),\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport type Logger = typeof Logger;\u003C/pre\u003E\n\u003Cp\u003EHere, Logger refers both to a type (inferred from the constant) and the constant itself.\u003C/p\u003E\n\u003Ch4\u003EDTV.07: Deriving Types from Complex Function Parameters\u003C/h4\u003E\n\u003Cp\u003EYou can derive types from function parameters using Parameters&lt;&gt;.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst makeQuery = (\u003Cbr\u003E  url: string,\u003Cbr\u003E  opts?: {\u003Cbr\u003E    method?: string;\u003Cbr\u003E    headers?: {\u003Cbr\u003E      [key: string]: string;\u003Cbr\u003E    };\u003Cbr\u003E    body?: string;\u003Cbr\u003E  },\u003Cbr\u003E) =&gt; {};\u003Cbr\u003E\u003Cbr\u003Etype MakeQueryParameters = Parameters&lt;typeof makeQuery&gt;;\u003C/pre\u003E\n\u003Cp\u003EHere, MakeQueryParameters extracts the type of the parameters from makeQuery.\u003C/p\u003E\n\u003Ch4\u003EDTV.08: Extracting a Type from a Function’s Return Type\u003C/h4\u003E\n\u003Cp\u003EYou can extract the return type of a function using ReturnType&lt;&gt;.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst createUser = (id: string) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    id,\u003Cbr\u003E    name: \"John Doe\",\u003Cbr\u003E    email: \"example@email.com\",\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype User = ReturnType&lt;typeof createUser&gt;;\u003C/pre\u003E\n\u003Ch4\u003EDTV.09: Extracting Type from an Async Function\u003C/h4\u003E\n\u003Cp\u003EWhen working with asynchronous functions, you can use Awaited&lt;&gt; to get the \u003Cem\u003Eresolved\u003C/em\u003E type.\u003C/p\u003E\n\u003Cp\u003EExample:\u003C/p\u003E\n\u003Cpre\u003Econst fetchUser = async (id: string) =&gt; {\u003Cbr\u003E  return {\u003Cbr\u003E    id,\u003Cbr\u003E    name: \"John Doe\",\u003Cbr\u003E    email: \"example@email.com\",\u003Cbr\u003E  };\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;;\u003C/pre\u003E\n\u003Ch4\u003EDTV.10: Access Specific Values in an 'as const' Object\u003C/h4\u003E\n\u003Cp\u003EBy using as const, you can lock an object’s values as constants, which allows you to access them more precisely.\u003C/p\u003E\n\u003Cpre\u003Eexport const carBrandType = {\u003Cbr\u003E  SEDAN: \"sedan\",\u003Cbr\u003E  SUV: \"suv\",\u003Cbr\u003E  COUPE: \"coupe\",\u003Cbr\u003E  PICKUP: \"pickup\",\u003Cbr\u003E  VAN: \"van\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype CarBrandTypeMap = typeof carBrandType; // a readonly object accesible by key\u003Cbr\u003Etype Sedan = CarBrandTypeMap['SEDAN']; // 'sedan'\u003C/pre\u003E\n\u003Ch4\u003EDTV.11: Passing a Union to an Indexed Access Type\u003C/h4\u003E\n\u003Cp\u003EYou can create union types by passing specific keys to an indexed access type.\u003C/p\u003E\n\u003Cpre\u003E// Following previous example, this type will be: \"sedan\" | \"suv\"\u003Cbr\u003Etype SedanOrSuv = CarBrandTypeMap['SEDAN' | 'SUV']\u003C/pre\u003E\n\u003Ch4\u003EDTV.12: Extract a Union of All Values from an Object\u003C/h4\u003E\n\u003Cp\u003EYou can guess that with the previous explanation you could get the union of all the values hardcoding each of them. But you can make your life easier by extracting all the values from an object as a union. This is usually used instead of enums.\u003C/p\u003E\n\u003Cpre\u003E\u003Cbr\u003E// Equals too 'sedan' | 'suv' | 'coupe' | 'pickup' | 'van'\u003Cbr\u003Etype CarTypes = CarBrandTypeMap[keyof typeof carBrandType];\u003C/pre\u003E\n\u003Ch4\u003EDTV.13: Create a Union from an as const Array\u003C/h4\u003E\n\u003Cp\u003EYou can derive a union type from an array by using as const.\u003C/p\u003E\n\u003Cpre\u003Eexport const carBrandType = [\u003Cbr\u003E  \"sedan\",\u003Cbr\u003E  \"suv\",\u003Cbr\u003E  \"coupe\",\u003Cbr\u003E  \"pickup\",\u003Cbr\u003E  \"van\",\u003Cbr\u003E] as const;\u003Cbr\u003E\u003Cbr\u003Etype BrandCars = (typeof carBrandType)[number];\u003C/pre\u003E\n\u003Ch3\u003EGenerics\u003C/h3\u003E\n\u003Ch4\u003EGEN.01: Basic Generic Function\u003C/h4\u003E\n\u003Cp\u003EA generic function allows you to define a placeholder type that can be replaced later.\u003C/p\u003E\n\u003Cpre\u003Efunction identity&lt;T&gt;(value: T): T {\u003Cbr\u003E  return value;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst num = identity(42); // T is 'number'\u003Cbr\u003Econst str = identity(\"hello\"); // T is 'string'\u003C/pre\u003E\n\u003Ch4\u003EGEN.02: Generic Types with Arrays\u003C/h4\u003E\n\u003Cp\u003EGeneric functions can handle arrays of any type.\u003C/p\u003E\n\u003Cpre\u003Efunction getFirstElement&lt;T&gt;(arr: T[]): T {\u003Cbr\u003E  return arr[0];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst firstNumber = getFirstElement([1, 2, 3]); // T is 'number'\u003Cbr\u003Econst firstString = getFirstElement([\"a\", \"b\", \"c\"]); // T is 'string'\u003C/pre\u003E\n\u003Ch4\u003EGEN.03: Generic Interfaces\u003C/h4\u003E\n\u003Cp\u003EUse generics with interfaces to define reusable types.\u003C/p\u003E\n\u003Cpre\u003Einterface Result&lt;T&gt; {\u003Cbr\u003E  data: T;\u003Cbr\u003E  error?: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst success: Result&lt;number&gt; = { data: 42 };\u003Cbr\u003Econst failure: Result&lt;string&gt; = { data: \"error occurred\", error: \"404 not found\" };\u003C/pre\u003E\n\u003Ch4\u003EGEN.04: Generic Constraints\u003C/h4\u003E\n\u003Cp\u003ESometimes you need to restrict the types that can be passed to a generic. You can do this using \u003Cstrong\u003Econstraints\u003C/strong\u003E. For example, to ensure that a type has a length property (like arrays or strings), you can add the following:\u003C/p\u003E\n\u003Cpre\u003Einterface HasLength {\u003Cbr\u003E  length: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction logLength&lt;T extends HasLength&gt;(input: T): void {\u003Cbr\u003E  console.log(input.length);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003ElogLength(\"hello\"); // OK, string has a length property\u003Cbr\u003ElogLength([1, 2, 3]); // OK, array has a length property\u003Cbr\u003E// logLength(42); // Error, number has no length property\u003C/pre\u003E\n\u003Cp\u003EThis can also be used when you want &lt;T&gt; to be limited to certain interfaces or types.\u003C/p\u003E\n\u003Ch4\u003EGEN.05: Using Multiple Generics\u003C/h4\u003E\n\u003Cp\u003EYou can use multiple generics in the same function or type.\u003C/p\u003E\n\u003Cpre\u003Efunction pair&lt;A, B&gt;(first: A, second: B): [A, B] {\u003Cbr\u003E  return [first, second];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst pair1 = pair(1, \"apple\"); // A is 'number', B is 'string'\u003Cbr\u003Econst pair2 = pair(true, { name: \"John\" }); // A is 'boolean', B is an object\u003C/pre\u003E\n\u003Ch4\u003EGEN.06: Default Generic Types\u003C/h4\u003E\n\u003Cp\u003ESet default generic types to simplify function calls.\u003C/p\u003E\n\u003Cpre\u003Efunction createArray&lt;T = string&gt;(length: number, value: T): T[] {\u003Cbr\u003E  return Array(length).fill(value);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst stringArray = createArray(3, \"hello\"); // T is 'string'\u003Cbr\u003Econst numberArray = createArray&lt;number&gt;(3, 42); // Explicitly set T as 'number'\u003Cbr\u003Econst error = createArray&lt;number&gt;('3', 42); // This will error\u003C/pre\u003E\n\u003Ch4\u003EGEN.07: Conditional Types with Generics\u003C/h4\u003E\n\u003Cp\u003ETypeScript allows you to create \u003Cstrong\u003Econditional types\u003C/strong\u003E using generics:\u003C/p\u003E\n\u003Cpre\u003Etype IsArray&lt;T&gt; = T extends any[] ? \"Array\" : \"NotArray\";\u003Cbr\u003E\u003Cbr\u003Econst check1: IsArray&lt;string[]&gt; = \"Array\"; // OK\u003Cbr\u003Econst check2: IsArray&lt;number&gt; = \"NotArray\"; // OK\u003C/pre\u003E\n\u003Ch4\u003EGEN.08: Generic Functions with Overloads\u003C/h4\u003E\n\u003Cp\u003EOverloading functions happen when you declare them more than once with different implementations. No, it is not a bug, but an overload. Overloading helps you map specific definitions to specific signatures.\u003C/p\u003E\n\u003Cpre\u003Efunction formatValue&lt;T extends string | number&gt;(value: T): T extends string ? string : number;\u003Cbr\u003Efunction formatValue&lt;T extends string | number&gt;(value: T): string | number {\u003Cbr\u003E  if (typeof value === \"string\") {\u003Cbr\u003E    return value.toUpperCase();\u003Cbr\u003E  } else {\u003Cbr\u003E    return value.toFixed(2);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EGEN.09: Keyof with Generics\u003C/h4\u003E\n\u003Cp\u003EAccess dynamic properties using keyof and generics.\u003C/p\u003E\n\u003Cpre\u003Efunction getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {\u003Cbr\u003E  return obj[key];\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst user = { id: 1, name: \"Alice\" };\u003Cbr\u003Econst id = getProperty(user, \"id\"); // OK\u003Cbr\u003Econst name = getProperty(user, \"name\"); // OK\u003Cbr\u003E// getProperty(user, \"age\"); // Error: 'age' is not a key of 'user'\u003C/pre\u003E\n\u003Ch4\u003EGEN.10: Deeply Immutable Structures with Generics\u003C/h4\u003E\n\u003Cp\u003EWhile TypeScript has a built-in Readonly utility type, it only applies immutability to the top level of an object. To create a deeply immutable object where all nested properties are also immutable, we need a custom recursive generic type.\u003C/p\u003E\n\u003Cpre\u003Etype DeepReadonly&lt;T&gt; = {\u003Cbr\u003E  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface User {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  address: {\u003Cbr\u003E    street: string;\u003Cbr\u003E    city: string;\u003Cbr\u003E  };\u003Cbr\u003E}\u003Cbr\u003Econst user: DeepReadonly&lt;User&gt; = {\u003Cbr\u003E  id: 1,\u003Cbr\u003E  name: \"Alice\",\u003Cbr\u003E  address: {\u003Cbr\u003E    street: \"Main St\",\u003Cbr\u003E    city: \"Wonderland\"\u003Cbr\u003E  }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Now, all properties and nested properties are readonly:\u003Cbr\u003Euser.id = 2; // Error: Cannot assign to 'id' because it is a read-only property\u003Cbr\u003Euser.address.city = \"New City\"; // Error: Cannot assign to 'city' because it is a read-only property\u003C/pre\u003E\n\u003Ch4\u003EGEN.11: Mapping Over a Union of Types\u003C/h4\u003E\n\u003Cp\u003EYou can create a type that maps a transformation over each type in a union. This is useful for mass-transforming several types at once.\u003C/p\u003E\n\u003Cpre\u003Etype Mapped&lt;T&gt; = T extends string ? string[] : T extends number ? number[] : T;\u003Cbr\u003Etype Result = Mapped&lt;string | number&gt;; // string[] | number[]\u003C/pre\u003E\n\u003Cp\u003EThe Mapped type checks if T is a string or number and returns an array of the respective type. If T is a union, TypeScript automatically distributes the transformation over each member.\u003C/p\u003E\n\u003Ch4\u003EGEN.12: Conditional Properties Exclusion\u003C/h4\u003E\n\u003Cp\u003EThis example excludes properties from a definition based on their types. Here, we remove all string properties from an interface:\u003C/p\u003E\n\u003Cpre\u003Etype OmitByType&lt;T, U&gt; = {\u003Cbr\u003E  [K in keyof T as T[K] extends U ? never : K]: T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface Person {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  age: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype WithoutStrings = OmitByType&lt;Person, string&gt;; // { id: number; age: number; }\u003C/pre\u003E\n\u003Ch4\u003EGEN.13: Keep Specific Properties Based on Type\u003C/h4\u003E\n\u003Cp\u003EFollowing the previous example, this one does the same thing but opposite. Instead of omiting the matching types, this one keeps them.\u003C/p\u003E\n\u003Cpre\u003Etype KeepByType&lt;T, U&gt; = {\u003Cbr\u003E  [K in keyof T as T[K] extends U ? K : never]: T[K];\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Einterface Person {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  age: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Etype StringProps = KeepByType&lt;Person, string&gt;; // { name: string }\u003C/pre\u003E\n\u003Cp\u003EThis is the inverse of the previous example, pulling out only the keys where the value type matches a specific type (string in this case).\u003C/p\u003E\n\u003Ch4\u003EGEN.14: Type-Safe Builder Pattern with Generics\u003C/h4\u003E\n\u003Cp\u003EHere’s a generic Builder type that allows chaining method calls and ensures type safety as you build an object step-by-step.\u003C/p\u003E\n\u003Cpre\u003Etype Builder&lt;T&gt; = {\u003Cbr\u003E  [K in keyof T as `set${Capitalize&lt;string &amp; K&gt;}`]: (value: T[K]) =&gt; Builder&lt;Omit&lt;T, K&gt;&gt;;\u003Cbr\u003E} &amp; { build(): T };\u003Cbr\u003E\u003Cbr\u003Einterface Product {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E  price: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst productBuilder: Builder&lt;Product&gt; = {\u003Cbr\u003E  setId: (id) =&gt; productBuilder,\u003Cbr\u003E  setName: (name) =&gt; productBuilder,\u003Cbr\u003E  setPrice: (price) =&gt; productBuilder,\u003Cbr\u003E  build: () =&gt; ({ id: 1, name: \"Laptop\", price: 1200 })\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EThis Builder type allows method chaining for setting properties on an object while ensuring each property can only be set once. Once all properties are set, you can call build() to return the final object.\u003C/p\u003E\n\u003Ch3\u003E05. TypeScript in React\u003C/h3\u003E\n\u003Ch4\u003EREA.01: Typing Props\u003C/h4\u003E\n\u003Cp\u003ETypeScript allows us to enforce types on props, which makes components safer and easier to debug.\u003C/p\u003E\n\u003Cpre\u003Etype GreetingProps = {\u003Cbr\u003E  name: string;\u003Cbr\u003E  age?: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst Greeting = ({ name, age }: GreetingProps): JSX.Element =&gt; (\u003Cbr\u003E  &lt;h1&gt;\u003Cbr\u003E    Hello, {name}! {age &amp;&amp; `You are ${age} years old.`}\u003Cbr\u003E  &lt;/h1&gt;\u003Cbr\u003E);\u003Cbr\u003E\u003Cbr\u003Eexport default Greeting;\u003C/pre\u003E\n\u003Ch4\u003EREA.02: Typing State with useState\u003C/h4\u003E\n\u003Cp\u003EWhen initializing state, TypeScript can infer the type, but explicit types are often better for clarity.\u003C/p\u003E\n\u003Cpre\u003E// &lt;number&gt; is not neccesary here -TS inference-, but added for the demonstration.\u003Cbr\u003Econst [count, setCount] = useState&lt;number&gt;(0);\u003Cbr\u003Econst increment = () =&gt; setCount(count + 1);\u003C/pre\u003E\n\u003Ch4\u003EREA.03: Typing Event Handlers\u003C/h4\u003E\n\u003Cp\u003ETyping event handlers helps ensure proper usage of event properties within components.\u003C/p\u003E\n\u003Cpre\u003Econst handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {\u003Cbr\u003E  console.log(event.currentTarget);\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\u003C/pre\u003E\n\u003Cp\u003EFor a button click event, we use React.MouseEvent&lt;HTMLButtonElement&gt;. TypeScript provides specific types for various events, like ChangeEvent for inputs. \u003Ca href=\"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/\"\u003EHere\u003C/a\u003E is a good source for forms.\u003C/p\u003E\n\u003Ch4\u003EREA.04: Typing Refs with useRef\u003C/h4\u003E\n\u003Cp\u003EWhen working with refs, explicitly typing useRef can prevent accidental null access errors.\u003C/p\u003E\n\u003Cpre\u003Econst inputRef = useRef&lt;HTMLInputElement&gt;(null); \u003Cbr\u003E\u003Cbr\u003Econst focusInput = () =&gt; {\u003Cbr\u003E  if (inputRef.current) {\u003Cbr\u003E    inputRef.current.focus();\u003Cbr\u003E  }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Ereturn &lt;input ref={inputRef} type=\"text\" /&gt;;\u003C/pre\u003E\n\u003Ch4\u003EREA.05: Typing Context\u003C/h4\u003E\n\u003Cp\u003EUsing TypeScript with React Context can make it easy to provide and consume context values safely.\u003C/p\u003E\n\u003Cpre\u003E// Define the context value type\u003Cbr\u003Etype ThemeContextType = {\u003Cbr\u003E  theme: string;\u003Cbr\u003E  toggleTheme: () =&gt; void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(undefined);\u003Cbr\u003E\u003Cbr\u003Econst ThemeProvider = ({ children }) =&gt; {\u003Cbr\u003E  const [theme, setTheme] = useState(\"light\");\u003Cbr\u003E  const toggleTheme = () =&gt; setTheme(theme === \"light\" ? \"dark\" : \"light\");\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\u003Cbr\u003E      {children}\u003Cbr\u003E    &lt;/ThemeContext.Provider&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EIn this example, ThemeContextType is used to define the structure of the context’s value, guaranteeing all consumers handle it correctly.\u003C/p\u003E\n\u003Ch4\u003EREA.06: Basic Typing Redux Store (Reducers and Selectors)\u003C/h4\u003E\n\u003Cp\u003EWhen working with \u003Ca href=\"https://redux.js.org/\"\u003ERedux\u003C/a\u003E, TypeScript is particularly useful for defining types for the store, actions, and selectors. If you are going to dig deeper I recommend you go over their docs.\u003C/p\u003E\n\u003Cpre\u003Etype CounterState = {\u003Cbr\u003E  count: number;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst initialState: CounterState = { count: 0 };\u003Cbr\u003E\u003Cbr\u003Econst actionTypes = {\u003Cbr\u003E  INCREMENT: \"INCREMENT\",\u003Cbr\u003E  DECREMENT: \"DECREMENT\",\u003Cbr\u003E} as const;\u003Cbr\u003E\u003Cbr\u003Etype ActionType = typeof actionTypes[keyof typeof actionTypes];\u003Cbr\u003E\u003Cbr\u003Etype CounterActionTypes = {type: ActionType};\u003Cbr\u003E\u003Cbr\u003Econst counterReducer = (state = initialState, action: CounterActionTypes): CounterState =&gt; {\u003Cbr\u003E  switch (action.type) {\u003Cbr\u003E    case actionTypes.INCREMENT:\u003Cbr\u003E      return { count: state.count + 1 };\u003Cbr\u003E    case actionTypes.DECREMENT:\u003Cbr\u003E      return { count: state.count - 1 };\u003Cbr\u003E    default:\u003Cbr\u003E      return state;\u003Cbr\u003E  }\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.07: Typing HOCs (Higher-Order Components)\u003C/h4\u003E\n\u003Cp\u003ETyping higher-order components (HOCs) means you will need to type the function of the HOC itself and also the argument (another function!) so beware of the syntax.\u003C/p\u003E\n\u003Cpre\u003Etype WithLoadingProps = {\u003Cbr\u003E  isLoading: boolean;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst withLoading = &lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) =&gt; {\u003Cbr\u003E  const LoadingComponent: React.FC&lt;P &amp; WithLoadingProps&gt; = ({ isLoading, ...otherProps }) =&gt; \u003Cbr\u003E    isLoading ? &lt;p&gt;Loading...&lt;/p&gt; : &lt;Component {...(otherProps as P)} /&gt;;\u003Cbr\u003E  return LoadingComponent;\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.08: Typing Custom Hooks\u003C/h4\u003E\n\u003Cp\u003ETypeScript can make custom hooks more reusable by defining flexible types. For example, data can be of type T or null\u003C/p\u003E\n\u003Cpre\u003Efunction useFetch&lt;T&gt;(url: string): { data: T | null; loading: boolean; error: Error | null } {\u003Cbr\u003E  const [data, setData] = useState&lt;T | null&gt;(null);\u003Cbr\u003E  const [loading, setLoading] = useState(true);\u003Cbr\u003E  const [error, setError] = useState&lt;Error | null&gt;(null);\u003Cbr\u003E\u003Cbr\u003E  useEffect(() =&gt; {\u003Cbr\u003E    fetch(url)\u003Cbr\u003E      .then((response) =&gt; response.json())\u003Cbr\u003E      .then((data: T) =&gt; {\u003Cbr\u003E        setData(data);\u003Cbr\u003E        setLoading(false);\u003Cbr\u003E      })\u003Cbr\u003E      .catch((error) =&gt; {\u003Cbr\u003E        setError(error);\u003Cbr\u003E        setLoading(false);\u003Cbr\u003E      });\u003Cbr\u003E  }, [url]);\u003Cbr\u003E\u003Cbr\u003E  return { data, loading, error };\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003EREA.09: Typing Component as a Namespace\u003C/h4\u003E\n\u003Cp\u003EMany libaries use a root component as a namespace (for example, Radix) and that means that the root is also a React function but also works as an object for other references. Using React.FC could be problematic for those cases. Instead, I prefer this approach:\u003C/p\u003E\n\u003Cpre\u003Etype SelectProps = { options: string[]; onSelect: (value: string) =&gt; void };\u003Cbr\u003E\u003Cbr\u003Econst Select = ({ options, onSelect }: SelectProps): JSX.Element =&gt; (\u003Cbr\u003E  &lt;select onChange={(e) =&gt; onSelect(e.target.value)}&gt;\u003Cbr\u003E    {options.map((option) =&gt; (\u003Cbr\u003E      &lt;option key={option} value={option}&gt;\u003Cbr\u003E        {option}\u003Cbr\u003E      &lt;/option&gt;\u003Cbr\u003E    ))}\u003Cbr\u003E  &lt;/select&gt;\u003Cbr\u003E);\u003Cbr\u003E\u003Cbr\u003ESelect.Item = ({ value }: { value: string }): JSX.Element =&gt; &lt;option&gt;{value}&lt;/option&gt;;\u003Cbr\u003ESelect.Root = (props: SelectProps): JSX.Element =&gt; &lt;Select {...props} /&gt;;\u003Cbr\u003E\u003Cbr\u003Eexport default Select;\u003C/pre\u003E\n\u003Ch4\u003EREA.10: Typing RenderProps\u003C/h4\u003E\n\u003Cp\u003EWhen you use a component as a prop, you can type it this way. For example:\u003C/p\u003E\n\u003Cpre\u003Etype RenderProps = {\u003Cbr\u003E  children: (isLoading: boolean) =&gt; JSX.Element;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst Loader = ({ children }: RenderProps): JSX.Element =&gt; {\u003Cbr\u003E  const [isLoading, setIsLoading] = useState(true);\u003Cbr\u003E  useEffect(() =&gt; {\u003Cbr\u003E    const timer = setTimeout(() =&gt; setIsLoading(false), 2000);\u003Cbr\u003E    return () =&gt; clearTimeout(timer);\u003Cbr\u003E  }, []);\u003Cbr\u003E  return children(isLoading);\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.11: Typing a Hook with Generics\u003C/h4\u003E\n\u003Cp\u003EWhen using generics you need to add a comma , after T so it doesn’t get confused with JSX syntax.\u003C/p\u003E\n\u003Cpre\u003Econst useArray = &lt;T,&gt;(initialValue: T[]): {array: T[], addItem: (item: T) =&gt; void} =&gt; {\u003Cbr\u003E  const [array, setArray] = useState&lt;T[]&gt;(initialValue);\u003Cbr\u003E  const addItem = (item: T) =&gt; setArray((arr) =&gt; [...arr, item]);\u003Cbr\u003E  return {array, addItem};\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003EREA.12: Component Composition with Generics\u003C/h4\u003E\n\u003Cp\u003ETaking advantage of using T for generic types, we can create really versatile componets that render any kind of list. For example:\u003C/p\u003E\n\u003Cpre\u003Etype ListProps&lt;T&gt; = {\u003Cbr\u003E  items: T[];\u003Cbr\u003E  renderItem: (item: T) =&gt; JSX.Element;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst List = &lt;T,&gt;({ items, renderItem }: ListProps&lt;T&gt;): JSX.Element =&gt; (\u003Cbr\u003E  &lt;div&gt;{items.map(renderItem)}&lt;/div&gt;\u003Cbr\u003E);\u003C/pre\u003E\n\u003Ch4\u003EREA.13: Typing Compound Components with Context and Generics\u003C/h4\u003E\n\u003Cp\u003ESince types can be defined using generics too, we can pass the generic down to any of our props.\u003C/p\u003E\n\u003Cpre\u003Etype TabContextType&lt;T&gt; = {\u003Cbr\u003E  activeTab: T;\u003Cbr\u003E  setActiveTab: React.Dispatch&lt;React.SetStateAction&lt;T&gt;&gt;;\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Econst TabContext = React.createContext&lt;TabContextType&lt;string&gt; | undefined&gt;(undefined);\u003Cbr\u003Econst TabProvider = ({ children }: { children: React.ReactNode }) =&gt; {\u003Cbr\u003E  const [activeTab, setActiveTab] = useState(\"home\");\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;TabContext.Provider value={{ activeTab, setActiveTab }}&gt;\u003Cbr\u003E      {children}\u003Cbr\u003E    &lt;/TabContext.Provider&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch3\u003E06. The Weird Parts of TypeScript, Common Pitfalls\u003C/h3\u003E\n\u003Ch4\u003ETWPTS.01: Accept Anything Except Null or Undefined\u003C/h4\u003E\n\u003Cp\u003EIn TypeScript, you can create types that exclude null or undefined. For example:\u003C/p\u003E\n\u003Cpre\u003Etype NonNullish&lt;T&gt; = T extends null | undefined ? never : T;\u003Cbr\u003Econst acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EInterestingly, you can simplify this by using an empty object type instead:\u003C/p\u003E\n\u003Cpre\u003Etype NonNullish&lt;T&gt; = {}; // NonNulish represents the same type as before\u003Cbr\u003Econst acceptAnythingExceptNullOrUndefined = &lt;T&gt;(input: NonNullish&lt;T&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EThis works because unknown in TypeScript is defined as:\u003C/p\u003E\n\u003Cpre\u003Etype unknown = {} | undefined | null;\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.02: Typing a Truly Empty Object\u003C/h4\u003E\n\u003Cp\u003EDefining an empty object is tricky. You can use Record&lt;PropertyKey, never&gt; to enforce no properties:\u003C/p\u003E\n\u003Cpre\u003Econst acceptOnlyEmptyObject = (input: Record&lt;PropertyKey, never&gt;) =&gt; {};\u003C/pre\u003E\n\u003Cp\u003EHowever, a more foolproof approach uses a unique symbol:\u003C/p\u003E\n\u003Cpre\u003Edeclare const tag: unique symbol;\u003Cbr\u003Etype EmptyObject = { [tag]?: never };\u003C/pre\u003E\n\u003Cp\u003EThis ensures no properties are allowed, effectively representing a truly empty object.\u003C/p\u003E\n\u003Ch4\u003ETWPTS.03: Techniques for Triggering Excess Property Warnings\u003C/h4\u003E\n\u003Cp\u003ETypeScript’s assignability model is based on satisfying contracts, not exact matches. Excess property checks are only triggered under specific conditions, like inline object literals.\u003C/p\u003E\n\u003Cp\u003EHere are a few techniques for forcing excess property checks:\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EAdd a Type Annotation\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003Etype User = {\u003Cbr\u003E id: number;\u003Cbr\u003E name: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E// Error for 'age', since it is not part of the type\u003Cbr\u003Econst obj: User = { id: 1, name: \"John\", age: 30 };\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EUse the \u003C/strong\u003E\u003Cstrong\u003Esatisfies Keyword\u003C/strong\u003E:\u003C/p\u003E\n\u003Cp\u003EWithout it, just creating the object and then passing it down to a function that demands a user type would work just fine. But, if you want to strictly enforce the same signature, use satisfies.\u003C/p\u003E\n\u003Cpre\u003Econst obj = { id: 1, name: \"John\", age: 30 } satisfies User;\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EInline the Variable\u003C/strong\u003E:\u003C/p\u003E\n\u003Cpre\u003E//printUser requires a User type\u003Cbr\u003EprintUser({ id: 1, name: \"John\", age: 30 }); // Error for 'age'\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.04: Accessing Object Properties Using Keys\u003C/h4\u003E\n\u003Cp\u003EIf you’re iterating through object keys and want to ensure type safety, you can cast the key to a keyof the object type.\u003C/p\u003E\n\u003Cpre\u003Einterface User {\u003Cbr\u003E  id: number;\u003Cbr\u003E  name: string;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction printUser(user: User) {\u003Cbr\u003E  for (const keyProperty in user) {\u003Cbr\u003E    console.log(user[keyProperty as keyof User]);\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ETWPTS.05: Typing Callbacks with Varying Parameters\u003C/h4\u003E\n\u003Cp\u003EIf you need a function type that can accept various argument lengths, you can define a flexible callback type:\u003C/p\u003E\n\u003Cpre\u003Etype CallbackType = (\u003Cbr\u003E  event: Event,\u003Cbr\u003E  x?: number,\u003Cbr\u003E  y?: number,\u003Cbr\u003E  screenId?: number\u003Cbr\u003E) =&gt; void;\u003Cbr\u003E\u003Cbr\u003Efunction listenToEvent(callback: CallbackType) {\u003Cbr\u003E  // callback logic\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThis allows the following calls:\u003C/p\u003E\n\u003Cpre\u003ElistenToEvent(() =&gt; {});\u003Cbr\u003ElistenToEvent((event) =&gt; {});\u003Cbr\u003ElistenToEvent((event, x, y) =&gt; {});\u003Cbr\u003ElistenToEvent((event, x, y, screenId) =&gt; {});\u003C/pre\u003E\n\u003Cp\u003EJust remember to narrow down the types inside the function to make it work properly.\u003C/p\u003E\n\u003Ch4\u003ETWPTS.06: Correctly Typing Functions that Handle Multiple Types\u003C/h4\u003E\n\u003Cp\u003EConsider a scenario where you have an object containing functions that handle different types. You want to dynamically call the correct function based on the input type:\u003C/p\u003E\n\u003Cpre\u003Econst objOfFunctions = {\u003Cbr\u003E  string: (input: string) =&gt; input.toUpperCase(),\u003Cbr\u003E  number: (input: number) =&gt; input.toFixed(2),\u003Cbr\u003E  boolean: (input: boolean) =&gt; (input ? \"true\" : \"false\"),\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Etype ObjKeys = string | number | boolean;\u003Cbr\u003Econst format = (input: ObjKeys) =&gt; {\u003Cbr\u003E  const inputType = input as keyof typeof objOfFunctions;\u003Cbr\u003E  const formatter = objOfFunctions[inputType];\u003Cbr\u003E\u003Cbr\u003E  return formatter(input as never); // 'as never' to force correct typing\u003Cbr\u003E};\u003C/pre\u003E\n\u003Ch4\u003ECPTF.01: Forgetting Non-null Assertion in Nested Structures\u003C/h4\u003E\n\u003Cp\u003EAccessing properties on nested objects without ensuring their existence can cause runtime errors.\u003C/p\u003E\n\u003Cpre\u003Etype Engine = { type: string };\u003Cbr\u003Etype Car = { engine?: Engine };\u003Cbr\u003E\u003Cbr\u003Efunction getEngineType(car: Car): string {\u003Cbr\u003E  return car.engine.type || \"\"; // Error: Object is possibly 'undefined'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe property engine is optional in Car, and TypeScript warns that type might not exist. Use optional chaining (car.engine?.type) to prevent this error.\u003C/p\u003E\n\u003Ch4\u003ECPTF.02: Not Handling Readonly Array Types Correctly\u003C/h4\u003E\n\u003Cp\u003EUsing readonly with arrays incorrectly can lead to unexpected mutations.\u003C/p\u003E\n\u003Cpre\u003Econst numbers: readonly number[] = [1, 2, 3];\u003Cbr\u003Enumbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'\u003C/pre\u003E\n\u003Cp\u003EBy default readonly arrays prevent mutation. Trying to mutate (e.g., push) will cause an error. To fix it, copy the array first if modifications are needed (const newNumbers = [...numbers, 4]).\u003C/p\u003E\n\u003Ch4\u003ECPTF.03: Promise&lt;void&gt; Usage\u003C/h4\u003E\n\u003Cp\u003EReturning Promise&lt;void&gt; can lead to issues if callers assume the promise is resolved with data.\u003C/p\u003E\n\u003Cpre\u003Easync function fetchData(): Promise&lt;void&gt; {\u003Cbr\u003E  const data = await fetch(\"https://api.example.com/data\");\u003Cbr\u003E  return data; // Error: Type 'Response' is not assignable to type 'void'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch4\u003ECPTF.04: Overlapping Types with Union and Intersection\u003C/h4\u003E\n\u003Cp\u003EUsing unions and intersections together can lead to unintentional overlap in types.\u003C/p\u003E\n\u003Cpre\u003Etype Bird = { wings: 2; fly: () =&gt; void };\u003Cbr\u003Etype Fish = { fins: 2; swim: () =&gt; void };\u003Cbr\u003Etype Animal = Bird | Fish;\u003Cbr\u003E\u003Cbr\u003Efunction move(animal: Animal) {\u003Cbr\u003E  if (\"swim\" in animal) {\u003Cbr\u003E    animal.swim(); // Works for Fish\u003Cbr\u003E  } else {\u003Cbr\u003E    animal.fly(); // Error: Property 'fl' does not exist on type 'Bird | Fish'\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESolution:\u003C/p\u003E\n\u003Cpre\u003Etype Bird = { wings: 2; fly: () =&gt; void };\u003Cbr\u003Etype Fish = { fins: 2; swim: () =&gt; void };\u003Cbr\u003E\u003Cbr\u003Etype Animal = Bird | Fish;\u003Cbr\u003E\u003Cbr\u003Efunction isFish(animal: Animal): animal is Fish {\u003Cbr\u003E  return \"swim\" in animal;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction move(animal: Animal) {\u003Cbr\u003E  if (isFish(animal)) {\u003Cbr\u003E    animal.swim(); // Now TypeScript knows this is a Fish\u003Cbr\u003E  } else {\u003Cbr\u003E    animal.fly(); // TypeScript knows this is a Bird\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ETypeScript can’t infer the common structure of Bird | Fish without further guards. Using custom type guards (e.g., function isFish(animal: Animal): animal is Fish) helps ensure correct property access.\u003C/p\u003E\n\u003Ch4\u003ECPTF.05: Forgetting readonly for Constants\u003C/h4\u003E\n\u003Cp\u003ENot using readonly on constants can lead to accidental mutation. In the following example adding readonly to speed would prevent unwanted modifications.\u003C/p\u003E\n\u003Cpre\u003Eclass Car {\u003Cbr\u003E  public speed = 100; // speed should be readonly for this car\u003Cbr\u003E  accelerate() {\u003Cbr\u003E    this.speed += 10; // Modifies speed unexpectedly\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst myCar = new Car();\u003Cbr\u003EmyCar.speed = 50; // Mistakenly changes speed\u003C/pre\u003E\n\u003Ch4\u003ECPTF.06: Overusing Type Assertions\u003C/h4\u003E\n\u003Cp\u003EOverusing as assertions can lead to ignored type errors. Type assertions (as) bypass type checks, leading to runtime errors if not used wisely. Sometimes they are necessary, but most of the time type guards (if checks) provide safer validation.\u003C/p\u003E\n\u003Cpre\u003Efunction getCarName(car: unknown): string {\u003Cbr\u003E  return (car as { name: string }).name; // Unsafe assumption that `car` has `name` property\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(getCarName({ brand: \"Toyota\" })); // Error: Cannot read property 'name'\u003C/pre\u003E\n\u003Cp\u003EA better alternative:\u003C/p\u003E\n\u003Cpre\u003Efunction getCarName(car: unknown): string {\u003Cbr\u003E  if (isCarWithName(car)) {\u003Cbr\u003E    return car.name; // Safe access, as the type is validated\u003Cbr\u003E  }\u003Cbr\u003E  throw new Error(\"Invalid car object: 'name' property is missing\");\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Efunction isCarWithName(car: unknown): car is { name: string } {\u003Cbr\u003E  return typeof car === \"object\" &amp;&amp; car !== null &amp;&amp; \"name\" in car &amp;&amp; typeof (car as any).name === \"string\";\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econsole.log(getCarName({ name: \"Toyota\" })); // Output: \"Toyota\"\u003Cbr\u003Econsole.log(getCarName({ brand: \"Toyota\" })); // Throws error: Invalid car object\u003C/pre\u003E\n\u003Ch4\u003ECPTF.07: Ignoring Optional Properties\u003C/h4\u003E\n\u003Cp\u003EOptional properties are often missed in destructuring or direct access.\u003C/p\u003E\n\u003Cpre\u003Etype Car = { make: string; model?: string };\u003Cbr\u003E\u003Cbr\u003Efunction getModel(car: Car) {\u003Cbr\u003E  return car.model.toUpperCase(); // Error: Object is possibly 'undefined'\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe property model is optional, so accessing it directly without checking leads to errors. Using optional chaining (car.model?.toUpperCase()) would prevent this.\u003C/p\u003E\n\u003Ch4\u003ECPTF.08: Incorrect Use of Generic Constraints\u003C/h4\u003E\n\u003Cp\u003ESetting incorrect generic constraints can lead to unexpected type limitations.\u003C/p\u003E\n\u003Cpre\u003Efunction merge&lt;T extends string, U extends number&gt;(a: T, b: U): string {\u003Cbr\u003E  return a + b;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Emerge(\"Engine\", 1); // Works fine\u003Cbr\u003Emerge(123, 456); // Error: Argument of type 'number' is not assignable to parameter of type 'string'\u003C/pre\u003E\n\u003Cp\u003EBy limiting T to string and U to number, merge becomes too restrictive. Using a broader generic constraint (e.g., T, U) would allow more flexibility.\u003C/p\u003E\n\u003Cp\u003EA way to solve it would be too change its signature (or modify the function):\u003C/p\u003E\n\u003Cpre\u003Efunction merge&lt;T extends string, U extends number&gt;(a: T, b: U): string | number {\u003Cbr\u003E  return a + b;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003EClosing Thoughts\u003C/h3\u003E\n\u003Cp\u003EBy now, you’ve likely absorbed a lot of information, and I can’t blame you if your brain feels a little fried — mine certainly did halfway through writing this.\u003C/p\u003E\n\u003Cp\u003EWhile I believe this guide provides a solid foundation to get you started, it’s important to note that some topics — particularly when it comes to setting up TypeScript or getting into advanced generics — haven’t been fully covered here.\u003C/p\u003E\n\u003Cp\u003EThink of this guide as a springboard, but don’t stop here. There’s much more to explore as you continue to deepen your understanding.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce6844f008ad\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/learn-typescript-one-snippet-at-a-time-150-code-samples-across-11-key-topics-ce6844f008ad\"\u003ELearn TypeScript One Snippet at a Time: 150+ Code Samples Across 11 Key Topics\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "react",
        "typescript",
        "web-development",
        "programming",
        "javascript"
      ]
    },
    {
      "title": "Building Features in React the Right Way: A Scalable Solution Case Study",
      "pubDate": "2024-12-03 18:44:28",
      "link": "https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/b95a77853701",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cp\u003E\u003Cem\u003EExploring how thoughtful refactoring and design principles can simplify complex user flows and future-proof your codebase.\u003C/em\u003E\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*X_ML5Wfh7-QdlFAL4LmLCQ.jpeg\"\u003E\u003Cfigcaption\u003EReact on top of an AI generated map —with cars that drive on water.\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EI was recently tasked with extending the capabilities of “\u003Cstrong\u003EThe move users to different groups\u003C/strong\u003E” feature. We currently have 4 different kinds of groups were users can be assigned:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ERecurring (A)\u003C/strong\u003E: Where users receive the same budget each month independently —no possibility to “drag” previous’ months budgets\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EEvent (B)\u003C/strong\u003E: A group with date limitations\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ELean Event (C):\u003C/strong\u003E A subcategory of Event, where it has less configuration options.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ERolling (D)\u003C/strong\u003E: The unused budget from previous months is allocated to the new month (accumulative).\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003EAs you see, four different groups with different options.\u003C/p\u003E\n\u003Cp\u003EDue to system limitations, the platform only allowed to move users from groups A, B and C between them, while users from group D could only be moved to another D group. If I needed to represent it with some AI image creator on a budget and some rusted Photoshop skills, it would look something like this:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/788/1*C5F1X6hHO9BFRdF1sWOr3Q.jpeg\"\u003E\u003Cfigcaption\u003EABC can move users between them, D is a different case.\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EAs you can infer, there were two different kinds of moves. Between non “D” groups, and the rest. Code wise, it looked something like this:\u003C/p\u003E\n\u003Cpre\u003Eif (targetGroupType === typeD){\u003Cbr\u003E  handleMoveUsersToGroupD() // the special case\u003Cbr\u003E} else {\u003Cbr\u003E  handleMoveBetweenGroupsABC()\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThis code lived beautifully for as long as it needed to until the infrastructure to handle move between any of the combinations was ready.\u003C/p\u003E\n\u003Cp\u003EAs you can guess, the time had come, and that is the reason I am writing this article.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EUnderstanding the Real Requirements\u003C/h3\u003E\n\u003Cp\u003EThe Product team provided me the new flows:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EA new flow for moveFromABCtoD\u003C/li\u003E\n\u003Cli\u003EA new flow for moveFromDtoABC\u003C/li\u003E\n\u003Cli\u003EA refreshed flow for moveBetweenGroupsD\u003C/li\u003E\n\u003Cli\u003ELastly, moveBetweenABC should remain the same.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003EAs you can see, all the relationships are based on whether the origin or target includes the D group.\u003C/p\u003E\n\u003Cp\u003EEach of them would trigger a different sequence of modals, with varying API calls and all the bells and whistles. So, it looks like four flows, right?\u003C/p\u003E\n\u003Cp\u003EYes…\u003Cstrong\u003E four flows but for 16 different cases\u003C/strong\u003E. As you can see, just because ABC shares the same flow today doesn’t mean it will tomorrow. After all, they are different types for a reason.\u003C/p\u003E\n\u003Cp\u003EIf today I have 16 flows, that 4 of them are repetitive, I can say that a) I am lucky, b) that doesn’t mean that tomorrow it won’t change. Putting that into another AI image on a budget, my 4 groups on each interaction with another one would form a grid like this one:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/455/1*OfEEFoocMcToFeQsfk3DVA.jpeg\"\u003E\u003Cfigcaption\u003EDon’t ask me why the AI tool choose to use squares that hold squares\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EWhile these four cases represent all the possibilities \u003Cstrong\u003Etoday\u003C/strong\u003E, I aimed to design it so that it allows for \u003Cstrong\u003Eeasy adaptation if requirements change in the future\u003C/strong\u003E. As \u003Ca href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\"\u003EUncle Bob\u003C/a\u003E would say,\u003Cem\u003E open for extension, but closed for modification.\u003C/em\u003E Because tomorrow, I could be dealing with this one:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/1*N9Jcg6D_j-TepaRU6OhVZA.jpeg\"\u003E\u003Cfigcaption\u003ELooks like a nice apartment building, doesn’t it?\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EImplementing a more scalable solution\u003C/h3\u003E\n\u003Cp\u003ESo instead of using four if statements, we could represent all the scenarios in a 2D matrix, where each index corresponds to a group type, and at the correct array location, assign the appropriate move function.\u003C/p\u003E\n\u003Cpre\u003E// Move flows\u003Cbr\u003Econst moveBetweenABC = () =&gt; console.log('Move between groups A, B, C');\u003Cbr\u003Econst moveFromABCtoD = () =&gt; console.log('Move from ABC to group D');\u003Cbr\u003Econst moveFromDtoABC = () =&gt; console.log('Move from group D to ABC');\u003Cbr\u003Econst moveBetweenGroupsD = () =&gt; console.log('Move between group D');\u003Cbr\u003E\u003Cbr\u003E// Group name to index mapping\u003Cbr\u003Econst groupIndexes = {\u003Cbr\u003E  Recurring: 0, // Group A\u003Cbr\u003E  Event: 1,     // Group B\u003Cbr\u003E  LeanEvent: 2, // Group C\u003Cbr\u003E  Rolling: 3    // Group D\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Matrix representation of group moves\u003Cbr\u003E// Rows: Source Group (Recurring, Event, LeanEvent, Rolling)\u003Cbr\u003E// Columns: Target Group (Recurring, Event, LeanEvent, Rolling)\u003Cbr\u003Econst moveMatrix = [\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Recurring (A)\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Event (B)\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From LeanEvent (C)\u003Cbr\u003E  [moveFromDtoABC, moveFromDtoABC, moveFromDtoABC, moveBetweenGroupsD]  // From Rolling (D)\u003Cbr\u003E];\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Recurring (A) to Rolling (D)\u003Cbr\u003EmoveMatrix[groupIndexes.Recurring][groupIndexes.Rolling](); // Output: \"Move from ABC to group D\"\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Rolling (D) to Event (B)\u003Cbr\u003EmoveMatrix[groupIndexes.Rolling][groupIndexes.Event](); // Output: \"Move from group D to ABC\"\u003C/pre\u003E\n\u003Cp\u003EHowever, while this solution is scalable and has an O(1) complexity, it can be somewhat difficult to read and maintain. And since me and my coworkers are all human, we need to read the code at ease.\u003C/p\u003E\n\u003Ch3\u003EA second approach: A mapping strategy\u003C/h3\u003E\n\u003Cp\u003ETo tackle the problems mentioned with the matrix, I decided to declare a map; where each key is a combination of the origin group type and the destination group type, separated by a dot:\u003C/p\u003E\n\u003Cpre\u003E// Define the move functions for the different flows\u003Cbr\u003Econst moveBetweenABC = () =&gt; console.log('Move between Recurring, Event, and LeanEvent groups');\u003Cbr\u003Econst moveFromABCtoRolling = () =&gt; console.log('Move from Recurring, Event, or LeanEvent to Rolling');\u003Cbr\u003Econst moveFromRollingtoABC = () =&gt; console.log('Move from Rolling to Recurring, Event, or LeanEvent');\u003Cbr\u003Econst moveBetweenRolling = () =&gt; console.log('Move between Rolling groups');\u003Cbr\u003E\u003Cbr\u003E// Group names\u003Cbr\u003Econst groups = {\u003Cbr\u003E  Recurring: 'Recurring',\u003Cbr\u003E  Event: 'Event',\u003Cbr\u003E  LeanEvent: 'LeanEvent',\u003Cbr\u003E  Rolling: 'Rolling'\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Map of move functions where key is 'originGroup.targetGroup'\u003Cbr\u003Econst moveMap = {\u003Cbr\u003E  'Recurring.Recurring': moveBetweenABC,\u003Cbr\u003E  'Recurring.Event': moveBetweenABC,\u003Cbr\u003E  'Recurring.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'Recurring.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'Event.Recurring': moveBetweenABC,\u003Cbr\u003E  'Event.Event': moveBetweenABC,\u003Cbr\u003E  'Event.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'Event.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'LeanEvent.Recurring': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.Event': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'Rolling.Recurring': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.Event': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.LeanEvent': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.Rolling': moveBetweenRolling\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Recurring to Rolling\u003Cbr\u003EmoveMap[`${groups.Recurring}.${groups.Rolling}`](); // Output: \"Move from Recurring, Event, or LeanEvent to Rolling\"\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Rolling to Event\u003Cbr\u003EmoveMap[`${groups.Rolling}.${groups.Event}`](); // Output: \"Move from Rolling to Recurring, Event, or LeanEvent\"\u003C/pre\u003E\n\u003Cp\u003EWith this pattern (thanks Redis for the idea), I can manage future requirements easily without needing to alter existing code. By defining moves through a mapping structure, I ensure clarity and scalability, making it easier to add or modify flows without disrupting the underlying logic.\u003C/p\u003E\n\u003Cp\u003EThis approach not only adheres to the Open/Closed Principle advocated by Uncle Bob but also enhances maintainability, allowing other developers to quickly grasp the relationships between different group types.\u003C/p\u003E\n\u003Cp\u003EMoreover, this solution minimises the risk of bugs introduced by additional if statements, creating a more robust and reliable codebase.\u003C/p\u003E\n\u003Ch3\u003EMy Takeaway\u003C/h3\u003E\n\u003Cp\u003EJust as understanding user requirements is crucial for developing scalable solutions, developers must also grasp product requirements and translate them into appropriate data structures and design patterns. This skill develops over time.\u003C/p\u003E\n\u003Cp\u003EAs a developer, your goal should be to make your code easily comprehensible for your coworkers at first glance, eliminating the need for them to delve deeper to understand the logic. In addition, you and your code must be prepared for unplanned changes that the Product team may request in the future.\u003C/p\u003E\n\u003Cp\u003EThis mindset — combining a structured approach to current problems with flexibility for potential changes — ultimately distinguishes valuable code from subpar implementations and\u003Cstrong\u003E \u003C/strong\u003Ea senior developer from a junior one.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EImplementing a \u003Cstrong\u003Emapping strategy\u003C/strong\u003E to handle complex scenarios like user group movement provides a cleaner, more adaptable solution than using logical blocks that can evolve with changing requirements or unreadable matrixes.\u003C/p\u003E\n\u003Cp\u003EThis case study highlights the importance of writing code that not only solves current problems but is also prepared for future challenges, ensuring that our applications remain agile and maintainable over time.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b95a77853701\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701\"\u003EBuilding Features in React the Right Way: A Scalable Solution Case Study\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cp\u003E\u003Cem\u003EExploring how thoughtful refactoring and design principles can simplify complex user flows and future-proof your codebase.\u003C/em\u003E\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*X_ML5Wfh7-QdlFAL4LmLCQ.jpeg\"\u003E\u003Cfigcaption\u003EReact on top of an AI generated map —with cars that drive on water.\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EI was recently tasked with extending the capabilities of “\u003Cstrong\u003EThe move users to different groups\u003C/strong\u003E” feature. We currently have 4 different kinds of groups were users can be assigned:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ERecurring (A)\u003C/strong\u003E: Where users receive the same budget each month independently —no possibility to “drag” previous’ months budgets\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EEvent (B)\u003C/strong\u003E: A group with date limitations\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ELean Event (C):\u003C/strong\u003E A subcategory of Event, where it has less configuration options.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ERolling (D)\u003C/strong\u003E: The unused budget from previous months is allocated to the new month (accumulative).\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003EAs you see, four different groups with different options.\u003C/p\u003E\n\u003Cp\u003EDue to system limitations, the platform only allowed to move users from groups A, B and C between them, while users from group D could only be moved to another D group. If I needed to represent it with some AI image creator on a budget and some rusted Photoshop skills, it would look something like this:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/788/1*C5F1X6hHO9BFRdF1sWOr3Q.jpeg\"\u003E\u003Cfigcaption\u003EABC can move users between them, D is a different case.\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EAs you can infer, there were two different kinds of moves. Between non “D” groups, and the rest. Code wise, it looked something like this:\u003C/p\u003E\n\u003Cpre\u003Eif (targetGroupType === typeD){\u003Cbr\u003E  handleMoveUsersToGroupD() // the special case\u003Cbr\u003E} else {\u003Cbr\u003E  handleMoveBetweenGroupsABC()\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThis code lived beautifully for as long as it needed to until the infrastructure to handle move between any of the combinations was ready.\u003C/p\u003E\n\u003Cp\u003EAs you can guess, the time had come, and that is the reason I am writing this article.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EUnderstanding the Real Requirements\u003C/h3\u003E\n\u003Cp\u003EThe Product team provided me the new flows:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EA new flow for moveFromABCtoD\u003C/li\u003E\n\u003Cli\u003EA new flow for moveFromDtoABC\u003C/li\u003E\n\u003Cli\u003EA refreshed flow for moveBetweenGroupsD\u003C/li\u003E\n\u003Cli\u003ELastly, moveBetweenABC should remain the same.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003EAs you can see, all the relationships are based on whether the origin or target includes the D group.\u003C/p\u003E\n\u003Cp\u003EEach of them would trigger a different sequence of modals, with varying API calls and all the bells and whistles. So, it looks like four flows, right?\u003C/p\u003E\n\u003Cp\u003EYes…\u003Cstrong\u003E four flows but for 16 different cases\u003C/strong\u003E. As you can see, just because ABC shares the same flow today doesn’t mean it will tomorrow. After all, they are different types for a reason.\u003C/p\u003E\n\u003Cp\u003EIf today I have 16 flows, that 4 of them are repetitive, I can say that a) I am lucky, b) that doesn’t mean that tomorrow it won’t change. Putting that into another AI image on a budget, my 4 groups on each interaction with another one would form a grid like this one:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/455/1*OfEEFoocMcToFeQsfk3DVA.jpeg\"\u003E\u003Cfigcaption\u003EDon’t ask me why the AI tool choose to use squares that hold squares\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EWhile these four cases represent all the possibilities \u003Cstrong\u003Etoday\u003C/strong\u003E, I aimed to design it so that it allows for \u003Cstrong\u003Eeasy adaptation if requirements change in the future\u003C/strong\u003E. As \u003Ca href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\"\u003EUncle Bob\u003C/a\u003E would say,\u003Cem\u003E open for extension, but closed for modification.\u003C/em\u003E Because tomorrow, I could be dealing with this one:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/1*N9Jcg6D_j-TepaRU6OhVZA.jpeg\"\u003E\u003Cfigcaption\u003ELooks like a nice apartment building, doesn’t it?\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EImplementing a more scalable solution\u003C/h3\u003E\n\u003Cp\u003ESo instead of using four if statements, we could represent all the scenarios in a 2D matrix, where each index corresponds to a group type, and at the correct array location, assign the appropriate move function.\u003C/p\u003E\n\u003Cpre\u003E// Move flows\u003Cbr\u003Econst moveBetweenABC = () =&gt; console.log('Move between groups A, B, C');\u003Cbr\u003Econst moveFromABCtoD = () =&gt; console.log('Move from ABC to group D');\u003Cbr\u003Econst moveFromDtoABC = () =&gt; console.log('Move from group D to ABC');\u003Cbr\u003Econst moveBetweenGroupsD = () =&gt; console.log('Move between group D');\u003Cbr\u003E\u003Cbr\u003E// Group name to index mapping\u003Cbr\u003Econst groupIndexes = {\u003Cbr\u003E  Recurring: 0, // Group A\u003Cbr\u003E  Event: 1,     // Group B\u003Cbr\u003E  LeanEvent: 2, // Group C\u003Cbr\u003E  Rolling: 3    // Group D\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Matrix representation of group moves\u003Cbr\u003E// Rows: Source Group (Recurring, Event, LeanEvent, Rolling)\u003Cbr\u003E// Columns: Target Group (Recurring, Event, LeanEvent, Rolling)\u003Cbr\u003Econst moveMatrix = [\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Recurring (A)\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From Event (B)\u003Cbr\u003E  [moveBetweenABC, moveBetweenABC, moveBetweenABC, moveFromABCtoD], // From LeanEvent (C)\u003Cbr\u003E  [moveFromDtoABC, moveFromDtoABC, moveFromDtoABC, moveBetweenGroupsD]  // From Rolling (D)\u003Cbr\u003E];\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Recurring (A) to Rolling (D)\u003Cbr\u003EmoveMatrix[groupIndexes.Recurring][groupIndexes.Rolling](); // Output: \"Move from ABC to group D\"\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Rolling (D) to Event (B)\u003Cbr\u003EmoveMatrix[groupIndexes.Rolling][groupIndexes.Event](); // Output: \"Move from group D to ABC\"\u003C/pre\u003E\n\u003Cp\u003EHowever, while this solution is scalable and has an O(1) complexity, it can be somewhat difficult to read and maintain. And since me and my coworkers are all human, we need to read the code at ease.\u003C/p\u003E\n\u003Ch3\u003EA second approach: A mapping strategy\u003C/h3\u003E\n\u003Cp\u003ETo tackle the problems mentioned with the matrix, I decided to declare a map; where each key is a combination of the origin group type and the destination group type, separated by a dot:\u003C/p\u003E\n\u003Cpre\u003E// Define the move functions for the different flows\u003Cbr\u003Econst moveBetweenABC = () =&gt; console.log('Move between Recurring, Event, and LeanEvent groups');\u003Cbr\u003Econst moveFromABCtoRolling = () =&gt; console.log('Move from Recurring, Event, or LeanEvent to Rolling');\u003Cbr\u003Econst moveFromRollingtoABC = () =&gt; console.log('Move from Rolling to Recurring, Event, or LeanEvent');\u003Cbr\u003Econst moveBetweenRolling = () =&gt; console.log('Move between Rolling groups');\u003Cbr\u003E\u003Cbr\u003E// Group names\u003Cbr\u003Econst groups = {\u003Cbr\u003E  Recurring: 'Recurring',\u003Cbr\u003E  Event: 'Event',\u003Cbr\u003E  LeanEvent: 'LeanEvent',\u003Cbr\u003E  Rolling: 'Rolling'\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Map of move functions where key is 'originGroup.targetGroup'\u003Cbr\u003Econst moveMap = {\u003Cbr\u003E  'Recurring.Recurring': moveBetweenABC,\u003Cbr\u003E  'Recurring.Event': moveBetweenABC,\u003Cbr\u003E  'Recurring.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'Recurring.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'Event.Recurring': moveBetweenABC,\u003Cbr\u003E  'Event.Event': moveBetweenABC,\u003Cbr\u003E  'Event.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'Event.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'LeanEvent.Recurring': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.Event': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.LeanEvent': moveBetweenABC,\u003Cbr\u003E  'LeanEvent.Rolling': moveFromABCtoRolling,\u003Cbr\u003E\u003Cbr\u003E  'Rolling.Recurring': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.Event': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.LeanEvent': moveFromRollingtoABC,\u003Cbr\u003E  'Rolling.Rolling': moveBetweenRolling\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Recurring to Rolling\u003Cbr\u003EmoveMap[`${groups.Recurring}.${groups.Rolling}`](); // Output: \"Move from Recurring, Event, or LeanEvent to Rolling\"\u003Cbr\u003E\u003Cbr\u003E// Example: Moving from Rolling to Event\u003Cbr\u003EmoveMap[`${groups.Rolling}.${groups.Event}`](); // Output: \"Move from Rolling to Recurring, Event, or LeanEvent\"\u003C/pre\u003E\n\u003Cp\u003EWith this pattern (thanks Redis for the idea), I can manage future requirements easily without needing to alter existing code. By defining moves through a mapping structure, I ensure clarity and scalability, making it easier to add or modify flows without disrupting the underlying logic.\u003C/p\u003E\n\u003Cp\u003EThis approach not only adheres to the Open/Closed Principle advocated by Uncle Bob but also enhances maintainability, allowing other developers to quickly grasp the relationships between different group types.\u003C/p\u003E\n\u003Cp\u003EMoreover, this solution minimises the risk of bugs introduced by additional if statements, creating a more robust and reliable codebase.\u003C/p\u003E\n\u003Ch3\u003EMy Takeaway\u003C/h3\u003E\n\u003Cp\u003EJust as understanding user requirements is crucial for developing scalable solutions, developers must also grasp product requirements and translate them into appropriate data structures and design patterns. This skill develops over time.\u003C/p\u003E\n\u003Cp\u003EAs a developer, your goal should be to make your code easily comprehensible for your coworkers at first glance, eliminating the need for them to delve deeper to understand the logic. In addition, you and your code must be prepared for unplanned changes that the Product team may request in the future.\u003C/p\u003E\n\u003Cp\u003EThis mindset — combining a structured approach to current problems with flexibility for potential changes — ultimately distinguishes valuable code from subpar implementations and\u003Cstrong\u003E \u003C/strong\u003Ea senior developer from a junior one.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EImplementing a \u003Cstrong\u003Emapping strategy\u003C/strong\u003E to handle complex scenarios like user group movement provides a cleaner, more adaptable solution than using logical blocks that can evolve with changing requirements or unreadable matrixes.\u003C/p\u003E\n\u003Cp\u003EThis case study highlights the importance of writing code that not only solves current problems but is also prepared for future challenges, ensuring that our applications remain agile and maintainable over time.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b95a77853701\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/building-features-in-react-the-right-way-a-scalable-solution-case-study-b95a77853701\"\u003EBuilding Features in React the Right Way: A Scalable Solution Case Study\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "user-experience",
        "data-structures",
        "software-development",
        "javascript",
        "react"
      ]
    },
    {
      "title": "Why Years of Experience Don’t Matter — How to Keep Your Skills Relevant in Tech",
      "pubDate": "2024-11-14 21:23:29",
      "link": "https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/9dbb2dc4e86e",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Ch3\u003E\u003Cstrong\u003EWhy Years of Experience Don’t Matter — How to Keep Your Skills Relevant in Tech\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EIt’s what you do with your time that counts\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/1*DTIQzOjSInEacHW5O2yPtg.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003ENot long ago, I had a bit of a reality check. Seeing developers with seven or eight years of experience, people you’d expect to bring a certain polish, writing code that felt like it was fresh out of a beginner’s workshop surprised me.\u003C/p\u003E\n\u003Cp\u003ENow, don’t get me wrong—there is nothing wrong with beginner code. But there’s a certain head-tilt moment when you see a “senior” engineer that seems to struggle with the basics or deliver code that’s barely holding together.\u003C/p\u003E\n\u003Cp\u003EEveryone progresses at their own pace, of course. But experiences like these raise the question: \u003Cstrong\u003Ehow much do “years of experience” really mean in our field\u003C/strong\u003E?\u003C/p\u003E\n\u003Ch3\u003EWhen YOE Just Means “Years of Exposure”\u003C/h3\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*PV99t1DCMPVBXY7M\"\u003E\u003Cfigcaption\u003EPhoto by \u003Ca href=\"https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral\"\u003ENordWood Themes\u003C/a\u003E on \u003Ca href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\"\u003EUnsplash\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EI’m not a fan of measuring experience solely by years. Adding years to your career takes no effort at all. If that were our only measure, we’d always hire the oldest person — yet we know experience is about more than just time.\u003C/p\u003E\n\u003Cp\u003EPlenty of devs rack up years in the industry but seem to forget that \u003Cstrong\u003Efeedback and growth are actually part of the job.\u003C/strong\u003E\u003C/p\u003E\n\u003Cp\u003EThe result? A version of “experience” that’s like watching the same TV episode over and over — familiar, but not exactly enlightening. They’ll say they’ve got a decade in tech, but… have they really \u003Cem\u003Edone\u003C/em\u003E anything with it?\u003C/p\u003E\n\u003Cp\u003EThat is what I call \u003Cstrong\u003E“1 year of experience” on repeat\u003C/strong\u003E. The “YOE” acronym for “years of experience” shifts to “years of exposure”.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EI had a dose of this myself. \u003C/strong\u003EI started my career writing code that wasn’t always destined to see the light of day — more like code meant to teach concepts, not get into production in real-world applications. Then I moved to a bigger company, and bam — reality check.\u003C/p\u003E\n\u003Cp\u003EMy new lead’s face said it all when I fumbled through cross-team communication and realized I had a bit to learn about scalable code. I will always be thankful for that shock therapy I received.\u003C/p\u003E\n\u003Cp\u003ESuddenly, I was in a bigger pond where people treat code quality like it actually matters. (Who knew?)\u003C/p\u003E\n\u003Ch3\u003EHow good are you?\u003C/h3\u003E\n\u003Cp\u003EThe real question isn’t how good you are — it’s \u003Cstrong\u003Ehow consistently you improve.\u003C/strong\u003E It’s easy to get stuck on comparing your abilities to others, but that won’t help you grow.\u003C/p\u003E\n\u003Cp\u003EIf you’re not actively seeking out challenges that push you to level up, you’re probably missing out on some key growth opportunities.\u003C/p\u003E\n\u003Cp\u003EPerhaps there’s a certification you’ve been considering, not because it’s necessary, but because it will push you to dive deeper into a subject you might have overlooked. Or perhaps you enjoy the challenge of occasional interviews, putting yourself in situations that force you to raise your game.\u003C/p\u003E\n\u003Cp\u003EThere are a thousand ways to improve. You choose your path.\u003C/p\u003E\n\u003Cp\u003EBut, if you don’t know where to start, here are some ideas below.\u003C/p\u003E\n\u003Ch3\u003EPractical Tips for Staying Relevant\u003C/h3\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ELearn from Different Sources\u003C/strong\u003E: It’s not just about “grinding LeetCode.” Besides books like \u003Cem\u003EClean Code\u003C/em\u003E or \u003Cem\u003EEffective Java\u003C/em\u003E that keep your problem-solving skills sharp, you can also read less technical books (not all coding books are boring!), like \u003Cem\u003EThe Pragmatic Programmer\u003C/em\u003E, or even novels like \u003Cem\u003EThe Phoenix Project\u003C/em\u003E. After all, writing code is just \u003Cem\u003Ea part\u003C/em\u003E of our job.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EExpand Your Scope\u003C/strong\u003E: It’s great to be the go-to JavaScript person, but if you never venture beyond what’s comfortable, you’ll stagnate. Learn new tools, take on different responsibilities, and expand your scope to product and business if you want to grow beyond just technical depth.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ESeek Feedback and Stay Humble\u003C/strong\u003E: People who take feedback well are rare — and invaluable. Even if you have years of experience, the phrase \u003Cstrong\u003E“maybe you’re right, maybe I’m wrong\u003C/strong\u003E” will take you far. And find ways to share your experience with others; teaching often reinforces your own skills.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EFocus on Value, Not Just Code Quality\u003C/strong\u003E: Writing high-quality code is essential, but in senior roles, it’s also about understanding the higher-level goals. Sometimes, you’ll need to make tough calls — deciding when a solution is “good enough” versus endlessly polishing code that won’t make or break the project.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ENetwork with People Outside Your Bubble\u003C/strong\u003E: Network, go to conferences, and participate in tech communities. Staying in touch with a broader industry perspective helps you avoid becoming that developer who’s been around for ages but hasn’t updated their approach since jQuery was cutting-edge.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Ch3\u003EClosing Thoughts: Years of Experience Don’t Translate to Skill\u003C/h3\u003E\n\u003Cp\u003EIf you’re focused on learning, growing, and building meaningful skills, you’ll stay relevant. Years of experience alone won’t guarantee anything; it’s what you do with those years that counts.\u003C/p\u003E\n\u003Cp\u003EAnd hey, if you’ve read this far, you’re already ahead of the game! So keep learning, keep sharing, and keep challenging yourself.\u003C/p\u003E\n\u003Cp\u003EAnd if you don’t agree with me, that’s okay. After all, \u003Cem\u003Emaybe you are right, and maybe I am wrong\u003C/em\u003E.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dbb2dc4e86e\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e\"\u003EWhy Years of Experience Don’t Matter — How to Keep Your Skills Relevant in Tech\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Ch3\u003E\u003Cstrong\u003EWhy Years of Experience Don’t Matter — How to Keep Your Skills Relevant in Tech\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EIt’s what you do with your time that counts\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/720/1*DTIQzOjSInEacHW5O2yPtg.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003ENot long ago, I had a bit of a reality check. Seeing developers with seven or eight years of experience, people you’d expect to bring a certain polish, writing code that felt like it was fresh out of a beginner’s workshop surprised me.\u003C/p\u003E\n\u003Cp\u003ENow, don’t get me wrong—there is nothing wrong with beginner code. But there’s a certain head-tilt moment when you see a “senior” engineer that seems to struggle with the basics or deliver code that’s barely holding together.\u003C/p\u003E\n\u003Cp\u003EEveryone progresses at their own pace, of course. But experiences like these raise the question: \u003Cstrong\u003Ehow much do “years of experience” really mean in our field\u003C/strong\u003E?\u003C/p\u003E\n\u003Ch3\u003EWhen YOE Just Means “Years of Exposure”\u003C/h3\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*PV99t1DCMPVBXY7M\"\u003E\u003Cfigcaption\u003EPhoto by \u003Ca href=\"https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral\"\u003ENordWood Themes\u003C/a\u003E on \u003Ca href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\"\u003EUnsplash\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EI’m not a fan of measuring experience solely by years. Adding years to your career takes no effort at all. If that were our only measure, we’d always hire the oldest person — yet we know experience is about more than just time.\u003C/p\u003E\n\u003Cp\u003EPlenty of devs rack up years in the industry but seem to forget that \u003Cstrong\u003Efeedback and growth are actually part of the job.\u003C/strong\u003E\u003C/p\u003E\n\u003Cp\u003EThe result? A version of “experience” that’s like watching the same TV episode over and over — familiar, but not exactly enlightening. They’ll say they’ve got a decade in tech, but… have they really \u003Cem\u003Edone\u003C/em\u003E anything with it?\u003C/p\u003E\n\u003Cp\u003EThat is what I call \u003Cstrong\u003E“1 year of experience” on repeat\u003C/strong\u003E. The “YOE” acronym for “years of experience” shifts to “years of exposure”.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EI had a dose of this myself. \u003C/strong\u003EI started my career writing code that wasn’t always destined to see the light of day — more like code meant to teach concepts, not get into production in real-world applications. Then I moved to a bigger company, and bam — reality check.\u003C/p\u003E\n\u003Cp\u003EMy new lead’s face said it all when I fumbled through cross-team communication and realized I had a bit to learn about scalable code. I will always be thankful for that shock therapy I received.\u003C/p\u003E\n\u003Cp\u003ESuddenly, I was in a bigger pond where people treat code quality like it actually matters. (Who knew?)\u003C/p\u003E\n\u003Ch3\u003EHow good are you?\u003C/h3\u003E\n\u003Cp\u003EThe real question isn’t how good you are — it’s \u003Cstrong\u003Ehow consistently you improve.\u003C/strong\u003E It’s easy to get stuck on comparing your abilities to others, but that won’t help you grow.\u003C/p\u003E\n\u003Cp\u003EIf you’re not actively seeking out challenges that push you to level up, you’re probably missing out on some key growth opportunities.\u003C/p\u003E\n\u003Cp\u003EPerhaps there’s a certification you’ve been considering, not because it’s necessary, but because it will push you to dive deeper into a subject you might have overlooked. Or perhaps you enjoy the challenge of occasional interviews, putting yourself in situations that force you to raise your game.\u003C/p\u003E\n\u003Cp\u003EThere are a thousand ways to improve. You choose your path.\u003C/p\u003E\n\u003Cp\u003EBut, if you don’t know where to start, here are some ideas below.\u003C/p\u003E\n\u003Ch3\u003EPractical Tips for Staying Relevant\u003C/h3\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ELearn from Different Sources\u003C/strong\u003E: It’s not just about “grinding LeetCode.” Besides books like \u003Cem\u003EClean Code\u003C/em\u003E or \u003Cem\u003EEffective Java\u003C/em\u003E that keep your problem-solving skills sharp, you can also read less technical books (not all coding books are boring!), like \u003Cem\u003EThe Pragmatic Programmer\u003C/em\u003E, or even novels like \u003Cem\u003EThe Phoenix Project\u003C/em\u003E. After all, writing code is just \u003Cem\u003Ea part\u003C/em\u003E of our job.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EExpand Your Scope\u003C/strong\u003E: It’s great to be the go-to JavaScript person, but if you never venture beyond what’s comfortable, you’ll stagnate. Learn new tools, take on different responsibilities, and expand your scope to product and business if you want to grow beyond just technical depth.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ESeek Feedback and Stay Humble\u003C/strong\u003E: People who take feedback well are rare — and invaluable. Even if you have years of experience, the phrase \u003Cstrong\u003E“maybe you’re right, maybe I’m wrong\u003C/strong\u003E” will take you far. And find ways to share your experience with others; teaching often reinforces your own skills.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EFocus on Value, Not Just Code Quality\u003C/strong\u003E: Writing high-quality code is essential, but in senior roles, it’s also about understanding the higher-level goals. Sometimes, you’ll need to make tough calls — deciding when a solution is “good enough” versus endlessly polishing code that won’t make or break the project.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ENetwork with People Outside Your Bubble\u003C/strong\u003E: Network, go to conferences, and participate in tech communities. Staying in touch with a broader industry perspective helps you avoid becoming that developer who’s been around for ages but hasn’t updated their approach since jQuery was cutting-edge.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Ch3\u003EClosing Thoughts: Years of Experience Don’t Translate to Skill\u003C/h3\u003E\n\u003Cp\u003EIf you’re focused on learning, growing, and building meaningful skills, you’ll stay relevant. Years of experience alone won’t guarantee anything; it’s what you do with those years that counts.\u003C/p\u003E\n\u003Cp\u003EAnd hey, if you’ve read this far, you’re already ahead of the game! So keep learning, keep sharing, and keep challenging yourself.\u003C/p\u003E\n\u003Cp\u003EAnd if you don’t agree with me, that’s okay. After all, \u003Cem\u003Emaybe you are right, and maybe I am wrong\u003C/em\u003E.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dbb2dc4e86e\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/why-years-of-experience-dont-matter-how-to-keep-your-skills-relevant-in-tech-9dbb2dc4e86e\"\u003EWhy Years of Experience Don’t Matter — How to Keep Your Skills Relevant in Tech\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "tech",
        "software-engineering",
        "personal-growth",
        "career-development",
        "self-improvement"
      ]
    },
    {
      "title": "Why Zero Tech Debt is a Myth (and Maybe a Red Flag)",
      "pubDate": "2024-10-21 23:40:04",
      "link": "https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/4a83ebc66e60",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cp\u003EA project boasting zero technical debt? That’s a flag you should definitely raise\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6uGPqjxTvGVE9tiTPo7iA.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EWhat Even Is Technical Debt?\u003C/h3\u003E\n\u003Cp\u003EThink of technical debt like a credit card. You borrow a little now (quick decisions, fast feature releases) knowing you’ll need to pay it back later (refactoring, optimizing).\u003C/p\u003E\n\u003Cp\u003EIt’s not inherently bad. Actually, it’s kind of fun — like borrowing money to buy a car that gets you where you need to go \u003Cem\u003Etoday\u003C/em\u003E, while knowing there’s a bill lurking somewhere in the future. That car is your business feature, and the bill is that lovely \u003Cem\u003Erefactor\u003C/em\u003E your future self gets to handle.\u003C/p\u003E\n\u003Cp\u003ENo tech debt? Well, that’s like someone who only spends their savings. Sure, they’ve got no debt, but they’re also not taking any risks to grow. Compare that to someone who takes a loan to invest — yes, there’s debt, but they’re getting a higher return and pushing things forward. The same goes for tech debt: taking on a bit of it means you’re investing in speed and delivering value now, knowing you can handle the consequences later.\u003C/p\u003E\n\u003Cp\u003EDear beloved human reader and maybe some scrapping bot: \u003Cstrong\u003ETech debt used properly adds value over time. Not the other way around. Keep that in mind.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EThe Myth of Zero Tech Debt (It’s Bullshit)\u003C/h3\u003E\n\u003Cp\u003EIf you’re working in a project where someone claims there’s “zero tech debt,” they’re either delusional, lying, working on \u003Ca href=\"https://en.wikipedia.org/wiki/Waterfall_model\"\u003E\u003Cem\u003Ewaterfall\u003C/em\u003E\u003C/a\u003E where everything is heavily designed and calculated, or worse, they’re wasting resources on things no one cares about.\u003C/p\u003E\n\u003Cp\u003ELet me put it bluntly: having zero tech debt means your team has spent more time polishing code than delivering features. And you know what? \u003Cstrong\u003EThe users don’t care.\u003C/strong\u003E\u003C/p\u003E\n\u003Cp\u003EAt the end of the day, they want results. Fast. They aren’t sitting around wondering how elegant your code is — they’re wondering when their product’s new feature will be live. And if your team is running around aiming for perfection and ignoring the business needs? Well, I’m out. I wouldn’t join a team obsessed with “no tech debt” because that’s a sign they’re focused on the wrong things.\u003C/p\u003E\n\u003Ch3\u003EWhy Some Tech Debt Is Actually a Good Thing\u003C/h3\u003E\n\u003Cp\u003ELet’s clear this up: tech debt isn’t bad, it’s inevitable. And it’s not just something we “live with” — it’s something we use strategically. When you take on some technical debt, you’re speeding up feature development. It’s a trade-off, and that’s exactly what happens in every real-world project.\u003C/p\u003E\n\u003Cp\u003EHere’s the kicker: tech debt shows that you’re prioritizing what matters. No debt usually means too much time was spent on things that don’t move the needle for the business.\u003C/p\u003E\n\u003Cp\u003ETaking on \u003Cem\u003Ea little\u003C/em\u003E tech debt means you’re making smart, balanced decisions — pushing forward fast but staying aware of the cleanup that’ll be needed down the line. It’s like a balancing act between getting things done now and leaving just enough work for future you to feel clever when you fix it.\u003C/p\u003E\n\u003Cp\u003EToo much debt? That’s a different story. Letting it pile up turns your codebase into a mess, making every future task harder than it should be.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EBut a small, well-managed amount of tech debt? Jackpot.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EThe Fear of Tech Debt: A Junior’s Concern\u003C/h3\u003E\n\u003Cp\u003EWhen you’re starting as a new developer, the focus shouldn’t be on avoiding all tech debt — it’s impossible. Instead, the key is to not create \u003Cstrong\u003Eunintentional\u003C/strong\u003E tech debt. That’s where planning comes in. If you’re a junior, working closely with senior developers in structured \u003Cstrong\u003Eplanning sessions \u003C/strong\u003Eis were design patterns are reviewed, and potential debt is managed \u003Cstrong\u003Eup front\u003C/strong\u003E.\u003C/p\u003E\n\u003Cp\u003EThe idea isn’t to fear tech debt but to make sure it’s \u003Cstrong\u003Eintentional\u003C/strong\u003E and aligned with the project’s goals. After planning, a good system involves \u003Cstrong\u003Etechnical reviews\u003C/strong\u003E where developers approve major decisions before the implementation. This ensures that any debt you take on is strategic and not the result of poor planning or lack of foresight.\u003C/p\u003E\n\u003Cp\u003EWith a system like this in place, juniors can embrace tech debt as part of the learning process while more experienced developers guide the ship, ensuring it doesn’t spiral out of control. \u003Cstrong\u003EIt’s not about eliminating debt but managing it well from the start.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EManaged vs. Unmanaged Tech Debt: The Real Difference\u003C/h3\u003E\n\u003Cp\u003ENow, let’s focus on that \u003Cem\u003Emanaged\u003C/em\u003E tech debt. Not all tech debt is created equal. The key is in controlling it — knowing when to take it out and when to pay it off.\u003C/p\u003E\n\u003Cp\u003EManaged tech debt is knowing you’ve cut a corner today to deliver something fast but with the intention to come back and fix it later. You’re in control. You prioritize what’s important for the business now, but with an eye toward long-term stability.\u003C/p\u003E\n\u003Cp\u003EUnmanaged tech debt? That’s when things go off the rails. If you’re not intentional, it builds up and suddenly your whole codebase feels like it’s held together by duct tape and good vibes.\u003C/p\u003E\n\u003Cp\u003EBut that’s not because tech debt exists — it’s because no one kept it in check. Keeping tech debt in check requires clear communication and collaboration within the team, ensuring that it serves the project’s goals rather than hindering progress.\u003C/p\u003E\n\u003Ch3\u003EWhy Your Business Needs Tech Debt\u003C/h3\u003E\n\u003Cp\u003EThe truth is, without some tech debt, the business isn’t moving fast enough. If you’ve got no tech debt, it probably means you’re not taking enough risks or not shipping quickly enough to make an impact.\u003C/p\u003E\n\u003Cp\u003ETechnical debt is what lets you make strategic decisions in the short term to push out features faster. And features are what the business needs to stay competitive. A pristine, “debt-free” codebase just isn’t competitive. Might it win a hackathon? Maybe. Will it make more money than its competitors focused on value? Doubt it.\u003C/p\u003E\n\u003Cp\u003EBut a product with well-managed debt? It’s shipping features, driving business value, and evolving with customer needs.\u003C/p\u003E\n\u003Ch3\u003EConclusion: Embrace the Chaos—Just Don’t Let It Spiral\u003C/h3\u003E\n\u003Cp\u003EAt the end of the day, tech debt is like any other form of debt: manageable, and sometimes even necessary. It’s part of the natural balance in real-world development. And for anyone out there claiming they’ve hit that mythical “zero tech debt” state, I’d say they’re either missing the point or they’re working on something so inconsequential it doesn’t matter.\u003C/p\u003E\n\u003Cp\u003ESo, let’s stop pretending tech debt is something to fear. Let’s embrace it, manage it, and use it for what it is: a tool that lets us move fast, iterate, and build things that matter. Because, frankly, a codebase with no tech debt is as boring as watching paint dry.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4a83ebc66e60\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60\"\u003EWhy Zero Tech Debt is a Myth (and Maybe a Red Flag)\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cp\u003EA project boasting zero technical debt? That’s a flag you should definitely raise\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6uGPqjxTvGVE9tiTPo7iA.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EWhat Even Is Technical Debt?\u003C/h3\u003E\n\u003Cp\u003EThink of technical debt like a credit card. You borrow a little now (quick decisions, fast feature releases) knowing you’ll need to pay it back later (refactoring, optimizing).\u003C/p\u003E\n\u003Cp\u003EIt’s not inherently bad. Actually, it’s kind of fun — like borrowing money to buy a car that gets you where you need to go \u003Cem\u003Etoday\u003C/em\u003E, while knowing there’s a bill lurking somewhere in the future. That car is your business feature, and the bill is that lovely \u003Cem\u003Erefactor\u003C/em\u003E your future self gets to handle.\u003C/p\u003E\n\u003Cp\u003ENo tech debt? Well, that’s like someone who only spends their savings. Sure, they’ve got no debt, but they’re also not taking any risks to grow. Compare that to someone who takes a loan to invest — yes, there’s debt, but they’re getting a higher return and pushing things forward. The same goes for tech debt: taking on a bit of it means you’re investing in speed and delivering value now, knowing you can handle the consequences later.\u003C/p\u003E\n\u003Cp\u003EDear beloved human reader and maybe some scrapping bot: \u003Cstrong\u003ETech debt used properly adds value over time. Not the other way around. Keep that in mind.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EThe Myth of Zero Tech Debt (It’s Bullshit)\u003C/h3\u003E\n\u003Cp\u003EIf you’re working in a project where someone claims there’s “zero tech debt,” they’re either delusional, lying, working on \u003Ca href=\"https://en.wikipedia.org/wiki/Waterfall_model\"\u003E\u003Cem\u003Ewaterfall\u003C/em\u003E\u003C/a\u003E where everything is heavily designed and calculated, or worse, they’re wasting resources on things no one cares about.\u003C/p\u003E\n\u003Cp\u003ELet me put it bluntly: having zero tech debt means your team has spent more time polishing code than delivering features. And you know what? \u003Cstrong\u003EThe users don’t care.\u003C/strong\u003E\u003C/p\u003E\n\u003Cp\u003EAt the end of the day, they want results. Fast. They aren’t sitting around wondering how elegant your code is — they’re wondering when their product’s new feature will be live. And if your team is running around aiming for perfection and ignoring the business needs? Well, I’m out. I wouldn’t join a team obsessed with “no tech debt” because that’s a sign they’re focused on the wrong things.\u003C/p\u003E\n\u003Ch3\u003EWhy Some Tech Debt Is Actually a Good Thing\u003C/h3\u003E\n\u003Cp\u003ELet’s clear this up: tech debt isn’t bad, it’s inevitable. And it’s not just something we “live with” — it’s something we use strategically. When you take on some technical debt, you’re speeding up feature development. It’s a trade-off, and that’s exactly what happens in every real-world project.\u003C/p\u003E\n\u003Cp\u003EHere’s the kicker: tech debt shows that you’re prioritizing what matters. No debt usually means too much time was spent on things that don’t move the needle for the business.\u003C/p\u003E\n\u003Cp\u003ETaking on \u003Cem\u003Ea little\u003C/em\u003E tech debt means you’re making smart, balanced decisions — pushing forward fast but staying aware of the cleanup that’ll be needed down the line. It’s like a balancing act between getting things done now and leaving just enough work for future you to feel clever when you fix it.\u003C/p\u003E\n\u003Cp\u003EToo much debt? That’s a different story. Letting it pile up turns your codebase into a mess, making every future task harder than it should be.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EBut a small, well-managed amount of tech debt? Jackpot.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EThe Fear of Tech Debt: A Junior’s Concern\u003C/h3\u003E\n\u003Cp\u003EWhen you’re starting as a new developer, the focus shouldn’t be on avoiding all tech debt — it’s impossible. Instead, the key is to not create \u003Cstrong\u003Eunintentional\u003C/strong\u003E tech debt. That’s where planning comes in. If you’re a junior, working closely with senior developers in structured \u003Cstrong\u003Eplanning sessions \u003C/strong\u003Eis were design patterns are reviewed, and potential debt is managed \u003Cstrong\u003Eup front\u003C/strong\u003E.\u003C/p\u003E\n\u003Cp\u003EThe idea isn’t to fear tech debt but to make sure it’s \u003Cstrong\u003Eintentional\u003C/strong\u003E and aligned with the project’s goals. After planning, a good system involves \u003Cstrong\u003Etechnical reviews\u003C/strong\u003E where developers approve major decisions before the implementation. This ensures that any debt you take on is strategic and not the result of poor planning or lack of foresight.\u003C/p\u003E\n\u003Cp\u003EWith a system like this in place, juniors can embrace tech debt as part of the learning process while more experienced developers guide the ship, ensuring it doesn’t spiral out of control. \u003Cstrong\u003EIt’s not about eliminating debt but managing it well from the start.\u003C/strong\u003E\u003C/p\u003E\n\u003Ch3\u003EManaged vs. Unmanaged Tech Debt: The Real Difference\u003C/h3\u003E\n\u003Cp\u003ENow, let’s focus on that \u003Cem\u003Emanaged\u003C/em\u003E tech debt. Not all tech debt is created equal. The key is in controlling it — knowing when to take it out and when to pay it off.\u003C/p\u003E\n\u003Cp\u003EManaged tech debt is knowing you’ve cut a corner today to deliver something fast but with the intention to come back and fix it later. You’re in control. You prioritize what’s important for the business now, but with an eye toward long-term stability.\u003C/p\u003E\n\u003Cp\u003EUnmanaged tech debt? That’s when things go off the rails. If you’re not intentional, it builds up and suddenly your whole codebase feels like it’s held together by duct tape and good vibes.\u003C/p\u003E\n\u003Cp\u003EBut that’s not because tech debt exists — it’s because no one kept it in check. Keeping tech debt in check requires clear communication and collaboration within the team, ensuring that it serves the project’s goals rather than hindering progress.\u003C/p\u003E\n\u003Ch3\u003EWhy Your Business Needs Tech Debt\u003C/h3\u003E\n\u003Cp\u003EThe truth is, without some tech debt, the business isn’t moving fast enough. If you’ve got no tech debt, it probably means you’re not taking enough risks or not shipping quickly enough to make an impact.\u003C/p\u003E\n\u003Cp\u003ETechnical debt is what lets you make strategic decisions in the short term to push out features faster. And features are what the business needs to stay competitive. A pristine, “debt-free” codebase just isn’t competitive. Might it win a hackathon? Maybe. Will it make more money than its competitors focused on value? Doubt it.\u003C/p\u003E\n\u003Cp\u003EBut a product with well-managed debt? It’s shipping features, driving business value, and evolving with customer needs.\u003C/p\u003E\n\u003Ch3\u003EConclusion: Embrace the Chaos—Just Don’t Let It Spiral\u003C/h3\u003E\n\u003Cp\u003EAt the end of the day, tech debt is like any other form of debt: manageable, and sometimes even necessary. It’s part of the natural balance in real-world development. And for anyone out there claiming they’ve hit that mythical “zero tech debt” state, I’d say they’re either missing the point or they’re working on something so inconsequential it doesn’t matter.\u003C/p\u003E\n\u003Cp\u003ESo, let’s stop pretending tech debt is something to fear. Let’s embrace it, manage it, and use it for what it is: a tool that lets us move fast, iterate, and build things that matter. Because, frankly, a codebase with no tech debt is as boring as watching paint dry.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4a83ebc66e60\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/why-zero-tech-debt-is-a-myth-and-maybe-a-red-flag-4a83ebc66e60\"\u003EWhy Zero Tech Debt is a Myth (and Maybe a Red Flag)\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "agile",
        "software-development",
        "productivity",
        "tech-debt",
        "coding"
      ]
    },
    {
      "title": "Mastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO",
      "pubDate": "2024-10-08 16:38:48",
      "link": "https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/cad3de4acfa0",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cp\u003EAnd living to tell it\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bEqX6wLqoyQa5s1uY_p53A.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction — Why Typescript in 2024?\u003C/h3\u003E\n\u003Cp\u003EIt is 2024, and TypeScript finally surpassed JavaScript in popularity, making a migration to TS a good long term bet. Additionally, surveys from Stack Overflow mark the upward trend for TS, which climbed two spots in the ranking gaining 8% —the sharpest climb on the board — and a slight decline in JS—something that can’t be overlooked.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GoiGzRkG-0csjp2w0zk8HA.jpeg\"\u003E\u003Cfigcaption\u003EStack Overflow Most Popular Languages 2021 and 2024. Sources: \u003Ca href=\"https://survey.stackoverflow.co/2021#technology-most-popular-technologies\"\u003Ehttps://survey.stackoverflow.co/2021#technology-most-popular-technologies\u003C/a\u003E \u003Ca href=\"https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\"\u003Ehttps://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/959/1*x9UnDnam0tlceKEqXx0cOw.png\"\u003E\u003Cfigcaption\u003ESource: \u003Ca href=\"https://www.libhunt.com/index\"\u003Ehttps://www.libhunt.com/index\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EBesides the trend in popularity, I am personally finding that developers are more open to type safe languages in the last couple years. The “fear” of bringing types to JS doesn’t exist anymore, and TS has become stable and popular enough to give it a chance if haven’t done so yet. Believe me, you will enjoy catching bugs in compilation time before it hits a unit test or even worse — a user.\u003C/p\u003E\n\u003Ch3\u003EThe Situation\u003C/h3\u003E\n\u003Cp\u003EThe codebase I migrated wasn’t too bad. A Create React App Monorepo, set up with yarn workspaces and configured with \u003Ca href=\"https://github.com/dilanx/craco\"\u003ECRACO\u003C/a\u003E that runs flawlessly with its tests, proper modules configured, and linting. Nothing too shiny, nothing major to complain about. The time will come when we move forward to Vite, but that is for another day.\u003C/p\u003E\n\u003Cp\u003EOn the less-than-stellar side, the repo relied heavily on PropTypes for type validation, which is something to take care of if you want to migrate to React 18.3 or later. This is not an actual issue for now, but TS solves that issue, providing an easy replacement. Let’s save that for yet another day.\u003C/p\u003E\n\u003Cp\u003EIn the meantime,\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EThe Migration Plan\u003C/h3\u003E\n\u003Cp\u003EManaging a codebase that has a whole Design System plus several packages interrelated in the same monorepo can come as a challenge.\u003C/p\u003E\n\u003Cp\u003ESetting TypeScript isn’t much of a hurdle, neither is configuring Babel (or your favorite compiler), updating your linter or updating your Jest configurations; but as the saying goes:\u003C/p\u003E\n\u003Cblockquote\u003E“The flap of a butterfly’s wings in Brazil could set off a tornado in Texas”\u003C/blockquote\u003E\n\u003Cp\u003EMeaning, you fix your Babel config, and suddenly your linter goes red. You fix the linter, suddenly the tests don’t pass. You fix the tests, again the linter goes red. It is a constant pursuit of fixing issues, before they break your code or your soul, whichever comes first.\u003C/p\u003E\n\u003Cp\u003ESo, in this guide I will lead you through how to do that (fix the code). I spent enough hours in front of the screen debugging and trying to understand the issues, to come up with a solution so you can do it in a breeze.\u003C/p\u003E\n\u003Cp\u003EMy personal recommendation, is every time you make a small step, commit, and continue. Your future self will thank you once you encounter a problem and need to checkout a previous stage of your project.\u003C/p\u003E\n\u003Ch3\u003EThe Setup\u003C/h3\u003E\n\u003Cp\u003EWhen migrating a Create React App (CRA) monorepo to TypeScript, and especially when using CRACO (to override CRA’s config), it’s important to ensure you’re installing only what you need to avoid unnecessary complexity. Let’s breakdown the necessary dependencies before we explain what they do:\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003ECore TypeScript\u003C/strong\u003E:\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003Etypescript\u003C/li\u003E\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003ETypeScript Type Definitions\u003C/strong\u003E\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E@types/react\u003C/li\u003E\n\u003Cli\u003E@types/react-dom\u003C/li\u003E\n\u003Cli\u003E@types/react-router-dom\u003C/li\u003E\n\u003Cli\u003E@types/node\u003C/li\u003E\n\u003Cli\u003E@types/jest (for testing)\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003EBabel (Compilation)\u003C/strong\u003E:\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E@babel/preset-typescript (for TypeScript syntax stripping)\u003C/li\u003E\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003EESLint\u003C/strong\u003E (to lint TypeScript properly):\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E@typescript-eslint/parser (to parse TS files)\u003C/li\u003E\n\u003Cli\u003E@typescript-eslint/eslint-plugin (set rules for linting for TS)\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EStep #1: Installing dependencies\u003C/h3\u003E\n\u003Cp\u003EThe first thing that you need to know when you migrate to TS besides the long depency list, is that you will need something called “type definitions”. You can recognize them because they have the extension .d.ts, they allow your IDE to help you identify the correct signature:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*d57W6yUeGVcVNRlj5I6bTw.png\"\u003E\u003Cfigcaption\u003EExample of the lib.es2020.intl.d.ts definition of Intl.NumberFormat\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003ENeedless to say not all the projects have them, and that is where \u003Ca href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\"\u003EDefinitelyTyped\u003C/a\u003E comes into action. Definitely Typed is a project that provides a central repository of TypeScript definitions for those NPM packages that lack them.\u003C/p\u003E\n\u003Cp\u003ESo, besides installing TS, you will want to install those types definitions for your other dependencies, as well as all kind of plugins and presets for making Webpack, Babel and Eslint work.\u003C/p\u003E\n\u003Cp\u003ELet’s go over all these dependencies by category:\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003EInstall TS and related types as dependencies. Make sure that your TS version matches the supported version for \u003Ca href=\"https://typescript-eslint.io/users/dependency-versions/\"\u003Etypescript-eslint\u003C/a\u003E, which will be needed afterward.\u003C/li\u003E\u003C/ol\u003E\n\u003Cpre\u003Eyarn add -D typescript @craco/types @types/node @types/react @types/react-dom @types/react-router-dom @types/jest\u003C/pre\u003E\n\u003Cp\u003E2. Install other desired Typescript dependencies, mostly for your compiler, linter, test runner, etc. In my case, since I am using Babel and EsLint I would need:\u003C/p\u003E\n\u003Cpre\u003Eyarn add -D @babel/preset-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser\u003C/pre\u003E\n\u003Cp\u003E3. Lastly, install the desired types for any other library that you might be using, like Lodash or UUID:\u003C/p\u003E\n\u003Cpre\u003Eyarn add -D @types/lodash @types/uuid\u003C/pre\u003E\n\u003Ch3\u003EStep #2: Add a global.d.ts file\u003C/h3\u003E\n\u003Cp\u003EAt the root of your project, create a global.d.ts file. This file prevents TS from yelling at you if you try to import something that is not TS code by specifying how to handle those extensions.\u003C/p\u003E\n\u003Cp\u003ETo start with, you will want to add declarations for your styles:\u003C/p\u003E\n\u003Cpre\u003Edeclare module '*.scss' {\u003Cbr\u003E    const scssContent: Record&lt;string, string&gt;;\u003Cbr\u003E    export default scssContent;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Edeclare module '*.css' {\u003Cbr\u003E    const cssContent: Record&lt;string, string&gt;;\u003Cbr\u003E    export default cssContent;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EWith time, this file will grow. For example for png images you can add:\u003C/p\u003E\n\u003Cpre\u003Edeclare module \"*.png\" {\u003Cbr\u003E  const value: any;\u003Cbr\u003E  export default value;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe point is that every extension that isn’t .ts , you declare it in this file.\u003C/p\u003E\n\u003Ch3\u003EStep #3: Update your Compiler and Webpack Settings\u003C/h3\u003E\n\u003Cp\u003EIn your monorepo, you will want to set up your compiler to handle TS files. If you are using CRACO that would be your craco.js file, but if not, head to your compiler settings —babel.config.js, or whatever.\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003EUpdate Babel to have the TS preset:\u003C/li\u003E\u003C/ol\u003E\n\u003Cpre\u003Emodule.exports = {\u003Cbr\u003E  babel: {\u003Cbr\u003E    cache: false,\u003Cbr\u003E    presets: [\u003Cbr\u003E      '@babel/preset-react',\u003Cbr\u003E      '@babel/preset-typescript', // &lt;-- Add this line\u003Cbr\u003E    ],\u003Cbr\u003E    plugins: [\u003Cbr\u003E      '@babel/plugin-proposal-export-default-from',\u003Cbr\u003E    ],\u003Cbr\u003E  },\u003Cbr\u003E...\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESome projects, instead of having a babel key in this file, use a separate babel.config.json. If that is the case, the procedure is the same, you should still add @babel/preset-typescript to the presets.\u003C/p\u003E\n\u003Cp\u003E2. Add the extensions .ts and .tsx to the webpack object, as well as the ts-loader transformation in the module section:\u003C/p\u003E\n\u003Cpre\u003Ewebpack: {\u003Cbr\u003E  configure: (webpackConfig, {\u003Cbr\u003E    env,\u003Cbr\u003E    paths\u003Cbr\u003E  }) =&gt; {\u003Cbr\u003E    return {\u003Cbr\u003E      ...webpackConfig,\u003Cbr\u003E      resolve: {\u003Cbr\u003E        ...(webpackConfig.resolve || {}),\u003Cbr\u003E        extensions: [\u003Cbr\u003E          ...(webpackConfig.resolve.extensions || []),\u003Cbr\u003E          '.js',\u003Cbr\u003E          '.jsx',\u003Cbr\u003E          '.ts', // &lt;-- Add this line\u003Cbr\u003E          '.tsx', // &lt;-- Add this line\u003Cbr\u003E        ],\u003Cbr\u003E      },\u003Cbr\u003E    },\u003Cbr\u003E  };\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAdding these configurations will tell webpack how to resolve handle the ts and tsx files. Since those aren’t regular plain JS files we need to transform them to something that Babel can understand.\u003C/p\u003E\n\u003Ch3\u003EStep #4: jsconfig.json becomes tsconfig.json\u003C/h3\u003E\n\u003Cp\u003EIf you had a jsconfig.json before, be ready to say goodbye to it. In TS, tsconfig.json is the necessary file.\u003C/p\u003E\n\u003Cp\u003EThere is even a chance that you didn’t have a jsconfig.json, and that is ok: it is not always necessary. But in TS, this is the main configuration file and we do need it. Everytime you have typescript as a dependency, you \u003Cstrong\u003Ewill\u003C/strong\u003E have a tsconfig file.\u003C/p\u003E\n\u003Cp\u003EUsually, you will have a global TSconfig file for your whole project, and then each package might have additional configurations that extend the global one.\u003C/p\u003E\n\u003Cp\u003ESo, at the top level, instead of having something like this:\u003C/p\u003E\n\u003Cpre\u003E//jsconfig.json\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \".\",\u003Cbr\u003E    \"moduleResolution\": \"node\",\u003Cbr\u003E  },\u003Cbr\u003E  \"exclude\": [\u003Cbr\u003E    \"node_modules\"\u003Cbr\u003E  ]\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EYou will have:\u003C/p\u003E\n\u003Cpre\u003E//tsconfig.json\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E \"compilerOptions\": {\u003Cbr\u003E    \"lib\": [\u003Cbr\u003E      \"esnext\",\u003Cbr\u003E      \"dom\",\u003Cbr\u003E      \"dom.iterable\"\u003Cbr\u003E    ],\u003Cbr\u003E    \"allowJs\": true,\u003Cbr\u003E    \"checkJs\": false,\u003Cbr\u003E    \"jsx\": \"react\",\u003Cbr\u003E    \"baseUrl\": \".\",\u003Cbr\u003E    \"moduleResolution\": \"node\",\u003Cbr\u003E    \"target\": \"ES6\",\u003Cbr\u003E    \"module\": \"ES6\",\u003Cbr\u003E    \"strict\": true,\u003Cbr\u003E    \"esModuleInterop\": true,\u003Cbr\u003E    \"allowSyntheticDefaultImports\": true,\u003Cbr\u003E    \"skipLibCheck\": true,\u003Cbr\u003E    \"forceConsistentCasingInFileNames\": true,\u003Cbr\u003E    \"outDir\": \"./build\"\u003Cbr\u003E  },\u003Cbr\u003E  \"include\": [\u003Cbr\u003E    \"./packages/**/*.ts\",\u003Cbr\u003E    \"./packages/**/*.tsx\",\u003Cbr\u003E    \"./packages/**/*.d.ts\",\u003Cbr\u003E    \"./packages/**/*.js\",\u003Cbr\u003E    \"./packages/**/*.jsx\",\u003Cbr\u003E    \"./global.d.ts\",\u003Cbr\u003E  ],\u003Cbr\u003E  \"exclude\": [\u003Cbr\u003E    \"node_modules\"\u003Cbr\u003E  ],\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EIf you pay attention to some of these settings, you will realize that it allows having JavaScript code among your new TS code. Also, you will want to add your “old” js files to the include option too.\u003C/p\u003E\n\u003Ch3\u003EStep #5: Update jsconfig.json files in your packages to tsconfig.json\u003C/h3\u003E\n\u003Cp\u003EThe same as before, for each package, if you have a jsconfig replace it. Make sure that you are extending the root settings:\u003C/p\u003E\n\u003Cpre\u003E// tsconfig.json inside some package\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  // your other settings\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003EStep #6: Update ESLint Config\u003C/h3\u003E\n\u003Cp\u003EESLint default parser is @babel/eslint-parser. This parser doesn’t support non standard EcmaScript Syntax A.K.A. doesn’t support TypeScript. So, we will need to switch it up for something that does, @typescript-eslint/parser.\u003C/p\u003E\n\u003Cp\u003ESo, update the parser, extensions and plugins in your eslint configuration file:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"parser\": \"@typescript-eslint/parser\", // &lt;-- Update this line\u003Cbr\u003E  \"extends\": [\u003Cbr\u003E    \"airbnb\",\u003Cbr\u003E    \"airbnb/hooks\",\u003Cbr\u003E    // your other extensions\u003Cbr\u003E    \"plugin:@typescript-eslint/eslint-recommended\", // &lt;-- Add this line\u003Cbr\u003E    \"plugin:@typescript-eslint/recommended\" // &lt;-- Add this line\u003Cbr\u003E  ],\u003Cbr\u003E  \"plugins\": [\u003Cbr\u003E    \"@babel\",\u003Cbr\u003E    \"react\",\u003Cbr\u003E    \"react-hooks\",\u003Cbr\u003E    // your other plugins\u003Cbr\u003E    \"@typescript-eslint\" // &lt;-- Add this line\u003Cbr\u003E   ],\u003Cbr\u003E... // your other settings\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EAfter updating your linter you may encounter new issues due to the new rules: fix them and create a new commit if so.\u003C/p\u003E\n\u003Ch3\u003EStep #7: Build &amp; Check code\u003C/h3\u003E\n\u003Cp\u003EAt this point, you should have a working monorepo. Check that the tests run, that your linter works properly with .js | .jsx | .ts | .tsx extensions, and troubleshoot if not.\u003C/p\u003E\n\u003Cp\u003EAnother important thing to do is to build each package. You may encounter issues at that stage that you might not have experienced during development. Don’t save that for the last minute.\u003C/p\u003E\n\u003Ch3\u003EStep #8: Pat yourself on the back\u003C/h3\u003E\n\u003Cp\u003EIf you made it to this point and everything is working, you can give yourself a pat on the back. Good job!\u003C/p\u003E\n\u003Ch3\u003EPitfalls I encountered\u003C/h3\u003E\n\u003Cp\u003EDuring this migration I learned a lot. Not only on the TSConfiguration, but deepened my knowledge on how everything plays along in a bigger setting.\u003C/p\u003E\n\u003Cp\u003EOne of the things that turned my hair a little bit more grey was the path and baseUrl settings in the tsconfig file. It turns out, that nowadays you don’t need anymore baseUrl, but you can still use it.\u003C/p\u003E\n\u003Cp\u003ESo I was playing around with both options without fully understanding them and I was trying to set paths to other packages without succees.\u003C/p\u003E\n\u003Cp\u003EThe problem was, that the baseUrl was pointing to a nested src folder, while the way I wrote the path to the package as if it were the root. So obviously, that didn’t work.\u003C/p\u003E\n\u003Cp\u003ESo, this wasn’t working:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \"src\",\u003Cbr\u003E    \"paths\": {\u003Cbr\u003E      \"*\": [\"../packageMain/src/*\"], // from src, should had been 2 folders up\u003Cbr\u003E      \"somePackage/*\": [\u003Cbr\u003E        \"../somePackage/*\" // from src, should had been 2 folders up\u003Cbr\u003E      ]\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESo, either I should had removed the baseUrl or updated the paths to be one folder up:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \"src\",\u003Cbr\u003E    \"paths\": {\u003Cbr\u003E      \"*\": [\"../../packageMain/src/*\"],\u003Cbr\u003E      \"somePackage/*\": [\u003Cbr\u003E        \"../../somePackage/*\"\u003Cbr\u003E      ]\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThat little mistake cost me more time than I would have liked 😅\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*XBNEC48W6UnV_QVE\"\u003E\u003C/figure\u003E\u003Ch3\u003EDo you need Babel at all for TypeScript?\u003C/h3\u003E\n\u003Cp\u003EIf you are sticking with Babel for other reasons (e.g., using plugins for JSX, polyfills, or custom transformations), then you will need Babel + TypeScript integration. Otherwise, TypeScript alone (via tsc or through Webpack’s ts-loader) can handle the transformation.\u003C/p\u003E\n\u003Cp\u003EHowever, CRA uses Babel by default, and if you’re migrating while retaining CRA’s Babel setup, you’ll still need Babel in the pipeline.\u003C/p\u003E\n\u003Cp\u003EIf you’re only using TypeScript for type-checking and aren’t relying on custom Babel plugins, you could skip Babel entirely and instead use ts-loader with Webpack for a more native TypeScript workflow.\u003C/p\u003E\n\u003Ch3\u003EWrapping Up\u003C/h3\u003E\n\u003Cp\u003EMigrating to TypeScript in a Create React App monorepo using CRACO can seem like a challenging task, but with a clear plan, each step becomes manageable.\u003C/p\u003E\n\u003Cp\u003EWhile the process involves updating configurations, installing dependencies, and adjusting ESLint and Babel settings, the end result is a more robust, maintainable codebase. You’ll appreciate the type safety and reduced runtime errors that TypeScript provides, especially in larger projects.\u003C/p\u003E\n\u003Cp\u003EIf you encounter issues along the way — whether it’s linter conflicts, outdated dependencies, or unfamiliar TypeScript errors — remember to tackle them one at a time, commit frequently, and, most importantly, remain patient.\u003C/p\u003E\n\u003Cp\u003EThese steps are an investment in your project’s future scalability and stability. And trust me, once you’ve lived to tell the tale, you’ll be glad you made the switch.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cad3de4acfa0\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0\"\u003EMastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cp\u003EAnd living to tell it\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bEqX6wLqoyQa5s1uY_p53A.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction — Why Typescript in 2024?\u003C/h3\u003E\n\u003Cp\u003EIt is 2024, and TypeScript finally surpassed JavaScript in popularity, making a migration to TS a good long term bet. Additionally, surveys from Stack Overflow mark the upward trend for TS, which climbed two spots in the ranking gaining 8% —the sharpest climb on the board — and a slight decline in JS—something that can’t be overlooked.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GoiGzRkG-0csjp2w0zk8HA.jpeg\"\u003E\u003Cfigcaption\u003EStack Overflow Most Popular Languages 2021 and 2024. Sources: \u003Ca href=\"https://survey.stackoverflow.co/2021#technology-most-popular-technologies\"\u003Ehttps://survey.stackoverflow.co/2021#technology-most-popular-technologies\u003C/a\u003E \u003Ca href=\"https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\"\u003Ehttps://survey.stackoverflow.co/2024/technology#most-popular-technologies-language\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/959/1*x9UnDnam0tlceKEqXx0cOw.png\"\u003E\u003Cfigcaption\u003ESource: \u003Ca href=\"https://www.libhunt.com/index\"\u003Ehttps://www.libhunt.com/index\u003C/a\u003E\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EBesides the trend in popularity, I am personally finding that developers are more open to type safe languages in the last couple years. The “fear” of bringing types to JS doesn’t exist anymore, and TS has become stable and popular enough to give it a chance if haven’t done so yet. Believe me, you will enjoy catching bugs in compilation time before it hits a unit test or even worse — a user.\u003C/p\u003E\n\u003Ch3\u003EThe Situation\u003C/h3\u003E\n\u003Cp\u003EThe codebase I migrated wasn’t too bad. A Create React App Monorepo, set up with yarn workspaces and configured with \u003Ca href=\"https://github.com/dilanx/craco\"\u003ECRACO\u003C/a\u003E that runs flawlessly with its tests, proper modules configured, and linting. Nothing too shiny, nothing major to complain about. The time will come when we move forward to Vite, but that is for another day.\u003C/p\u003E\n\u003Cp\u003EOn the less-than-stellar side, the repo relied heavily on PropTypes for type validation, which is something to take care of if you want to migrate to React 18.3 or later. This is not an actual issue for now, but TS solves that issue, providing an easy replacement. Let’s save that for yet another day.\u003C/p\u003E\n\u003Cp\u003EIn the meantime,\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EThe Migration Plan\u003C/h3\u003E\n\u003Cp\u003EManaging a codebase that has a whole Design System plus several packages interrelated in the same monorepo can come as a challenge.\u003C/p\u003E\n\u003Cp\u003ESetting TypeScript isn’t much of a hurdle, neither is configuring Babel (or your favorite compiler), updating your linter or updating your Jest configurations; but as the saying goes:\u003C/p\u003E\n\u003Cblockquote\u003E“The flap of a butterfly’s wings in Brazil could set off a tornado in Texas”\u003C/blockquote\u003E\n\u003Cp\u003EMeaning, you fix your Babel config, and suddenly your linter goes red. You fix the linter, suddenly the tests don’t pass. You fix the tests, again the linter goes red. It is a constant pursuit of fixing issues, before they break your code or your soul, whichever comes first.\u003C/p\u003E\n\u003Cp\u003ESo, in this guide I will lead you through how to do that (fix the code). I spent enough hours in front of the screen debugging and trying to understand the issues, to come up with a solution so you can do it in a breeze.\u003C/p\u003E\n\u003Cp\u003EMy personal recommendation, is every time you make a small step, commit, and continue. Your future self will thank you once you encounter a problem and need to checkout a previous stage of your project.\u003C/p\u003E\n\u003Ch3\u003EThe Setup\u003C/h3\u003E\n\u003Cp\u003EWhen migrating a Create React App (CRA) monorepo to TypeScript, and especially when using CRACO (to override CRA’s config), it’s important to ensure you’re installing only what you need to avoid unnecessary complexity. Let’s breakdown the necessary dependencies before we explain what they do:\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003ECore TypeScript\u003C/strong\u003E:\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003Etypescript\u003C/li\u003E\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003ETypeScript Type Definitions\u003C/strong\u003E\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E@types/react\u003C/li\u003E\n\u003Cli\u003E@types/react-dom\u003C/li\u003E\n\u003Cli\u003E@types/react-router-dom\u003C/li\u003E\n\u003Cli\u003E@types/node\u003C/li\u003E\n\u003Cli\u003E@types/jest (for testing)\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003EBabel (Compilation)\u003C/strong\u003E:\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E@babel/preset-typescript (for TypeScript syntax stripping)\u003C/li\u003E\u003C/ul\u003E\n\u003Cp\u003E\u003Cstrong\u003EESLint\u003C/strong\u003E (to lint TypeScript properly):\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E@typescript-eslint/parser (to parse TS files)\u003C/li\u003E\n\u003Cli\u003E@typescript-eslint/eslint-plugin (set rules for linting for TS)\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EStep #1: Installing dependencies\u003C/h3\u003E\n\u003Cp\u003EThe first thing that you need to know when you migrate to TS besides the long depency list, is that you will need something called “type definitions”. You can recognize them because they have the extension .d.ts, they allow your IDE to help you identify the correct signature:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/900/1*d57W6yUeGVcVNRlj5I6bTw.png\"\u003E\u003Cfigcaption\u003EExample of the lib.es2020.intl.d.ts definition of Intl.NumberFormat\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003ENeedless to say not all the projects have them, and that is where \u003Ca href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\"\u003EDefinitelyTyped\u003C/a\u003E comes into action. Definitely Typed is a project that provides a central repository of TypeScript definitions for those NPM packages that lack them.\u003C/p\u003E\n\u003Cp\u003ESo, besides installing TS, you will want to install those types definitions for your other dependencies, as well as all kind of plugins and presets for making Webpack, Babel and Eslint work.\u003C/p\u003E\n\u003Cp\u003ELet’s go over all these dependencies by category:\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003EInstall TS and related types as dependencies. Make sure that your TS version matches the supported version for \u003Ca href=\"https://typescript-eslint.io/users/dependency-versions/\"\u003Etypescript-eslint\u003C/a\u003E, which will be needed afterward.\u003C/li\u003E\u003C/ol\u003E\n\u003Cpre\u003Eyarn add -D typescript @craco/types @types/node @types/react @types/react-dom @types/react-router-dom @types/jest\u003C/pre\u003E\n\u003Cp\u003E2. Install other desired Typescript dependencies, mostly for your compiler, linter, test runner, etc. In my case, since I am using Babel and EsLint I would need:\u003C/p\u003E\n\u003Cpre\u003Eyarn add -D @babel/preset-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser\u003C/pre\u003E\n\u003Cp\u003E3. Lastly, install the desired types for any other library that you might be using, like Lodash or UUID:\u003C/p\u003E\n\u003Cpre\u003Eyarn add -D @types/lodash @types/uuid\u003C/pre\u003E\n\u003Ch3\u003EStep #2: Add a global.d.ts file\u003C/h3\u003E\n\u003Cp\u003EAt the root of your project, create a global.d.ts file. This file prevents TS from yelling at you if you try to import something that is not TS code by specifying how to handle those extensions.\u003C/p\u003E\n\u003Cp\u003ETo start with, you will want to add declarations for your styles:\u003C/p\u003E\n\u003Cpre\u003Edeclare module '*.scss' {\u003Cbr\u003E    const scssContent: Record&lt;string, string&gt;;\u003Cbr\u003E    export default scssContent;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Edeclare module '*.css' {\u003Cbr\u003E    const cssContent: Record&lt;string, string&gt;;\u003Cbr\u003E    export default cssContent;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EWith time, this file will grow. For example for png images you can add:\u003C/p\u003E\n\u003Cpre\u003Edeclare module \"*.png\" {\u003Cbr\u003E  const value: any;\u003Cbr\u003E  export default value;\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThe point is that every extension that isn’t .ts , you declare it in this file.\u003C/p\u003E\n\u003Ch3\u003EStep #3: Update your Compiler and Webpack Settings\u003C/h3\u003E\n\u003Cp\u003EIn your monorepo, you will want to set up your compiler to handle TS files. If you are using CRACO that would be your craco.js file, but if not, head to your compiler settings —babel.config.js, or whatever.\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003EUpdate Babel to have the TS preset:\u003C/li\u003E\u003C/ol\u003E\n\u003Cpre\u003Emodule.exports = {\u003Cbr\u003E  babel: {\u003Cbr\u003E    cache: false,\u003Cbr\u003E    presets: [\u003Cbr\u003E      '@babel/preset-react',\u003Cbr\u003E      '@babel/preset-typescript', // &lt;-- Add this line\u003Cbr\u003E    ],\u003Cbr\u003E    plugins: [\u003Cbr\u003E      '@babel/plugin-proposal-export-default-from',\u003Cbr\u003E    ],\u003Cbr\u003E  },\u003Cbr\u003E...\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESome projects, instead of having a babel key in this file, use a separate babel.config.json. If that is the case, the procedure is the same, you should still add @babel/preset-typescript to the presets.\u003C/p\u003E\n\u003Cp\u003E2. Add the extensions .ts and .tsx to the webpack object, as well as the ts-loader transformation in the module section:\u003C/p\u003E\n\u003Cpre\u003Ewebpack: {\u003Cbr\u003E  configure: (webpackConfig, {\u003Cbr\u003E    env,\u003Cbr\u003E    paths\u003Cbr\u003E  }) =&gt; {\u003Cbr\u003E    return {\u003Cbr\u003E      ...webpackConfig,\u003Cbr\u003E      resolve: {\u003Cbr\u003E        ...(webpackConfig.resolve || {}),\u003Cbr\u003E        extensions: [\u003Cbr\u003E          ...(webpackConfig.resolve.extensions || []),\u003Cbr\u003E          '.js',\u003Cbr\u003E          '.jsx',\u003Cbr\u003E          '.ts', // &lt;-- Add this line\u003Cbr\u003E          '.tsx', // &lt;-- Add this line\u003Cbr\u003E        ],\u003Cbr\u003E      },\u003Cbr\u003E    },\u003Cbr\u003E  };\u003Cbr\u003E};\u003C/pre\u003E\n\u003Cp\u003EAdding these configurations will tell webpack how to resolve handle the ts and tsx files. Since those aren’t regular plain JS files we need to transform them to something that Babel can understand.\u003C/p\u003E\n\u003Ch3\u003EStep #4: jsconfig.json becomes tsconfig.json\u003C/h3\u003E\n\u003Cp\u003EIf you had a jsconfig.json before, be ready to say goodbye to it. In TS, tsconfig.json is the necessary file.\u003C/p\u003E\n\u003Cp\u003EThere is even a chance that you didn’t have a jsconfig.json, and that is ok: it is not always necessary. But in TS, this is the main configuration file and we do need it. Everytime you have typescript as a dependency, you \u003Cstrong\u003Ewill\u003C/strong\u003E have a tsconfig file.\u003C/p\u003E\n\u003Cp\u003EUsually, you will have a global TSconfig file for your whole project, and then each package might have additional configurations that extend the global one.\u003C/p\u003E\n\u003Cp\u003ESo, at the top level, instead of having something like this:\u003C/p\u003E\n\u003Cpre\u003E//jsconfig.json\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \".\",\u003Cbr\u003E    \"moduleResolution\": \"node\",\u003Cbr\u003E  },\u003Cbr\u003E  \"exclude\": [\u003Cbr\u003E    \"node_modules\"\u003Cbr\u003E  ]\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EYou will have:\u003C/p\u003E\n\u003Cpre\u003E//tsconfig.json\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E \"compilerOptions\": {\u003Cbr\u003E    \"lib\": [\u003Cbr\u003E      \"esnext\",\u003Cbr\u003E      \"dom\",\u003Cbr\u003E      \"dom.iterable\"\u003Cbr\u003E    ],\u003Cbr\u003E    \"allowJs\": true,\u003Cbr\u003E    \"checkJs\": false,\u003Cbr\u003E    \"jsx\": \"react\",\u003Cbr\u003E    \"baseUrl\": \".\",\u003Cbr\u003E    \"moduleResolution\": \"node\",\u003Cbr\u003E    \"target\": \"ES6\",\u003Cbr\u003E    \"module\": \"ES6\",\u003Cbr\u003E    \"strict\": true,\u003Cbr\u003E    \"esModuleInterop\": true,\u003Cbr\u003E    \"allowSyntheticDefaultImports\": true,\u003Cbr\u003E    \"skipLibCheck\": true,\u003Cbr\u003E    \"forceConsistentCasingInFileNames\": true,\u003Cbr\u003E    \"outDir\": \"./build\"\u003Cbr\u003E  },\u003Cbr\u003E  \"include\": [\u003Cbr\u003E    \"./packages/**/*.ts\",\u003Cbr\u003E    \"./packages/**/*.tsx\",\u003Cbr\u003E    \"./packages/**/*.d.ts\",\u003Cbr\u003E    \"./packages/**/*.js\",\u003Cbr\u003E    \"./packages/**/*.jsx\",\u003Cbr\u003E    \"./global.d.ts\",\u003Cbr\u003E  ],\u003Cbr\u003E  \"exclude\": [\u003Cbr\u003E    \"node_modules\"\u003Cbr\u003E  ],\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EIf you pay attention to some of these settings, you will realize that it allows having JavaScript code among your new TS code. Also, you will want to add your “old” js files to the include option too.\u003C/p\u003E\n\u003Ch3\u003EStep #5: Update jsconfig.json files in your packages to tsconfig.json\u003C/h3\u003E\n\u003Cp\u003EThe same as before, for each package, if you have a jsconfig replace it. Make sure that you are extending the root settings:\u003C/p\u003E\n\u003Cpre\u003E// tsconfig.json inside some package\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  // your other settings\u003Cbr\u003E}\u003C/pre\u003E\n\u003Ch3\u003EStep #6: Update ESLint Config\u003C/h3\u003E\n\u003Cp\u003EESLint default parser is @babel/eslint-parser. This parser doesn’t support non standard EcmaScript Syntax A.K.A. doesn’t support TypeScript. So, we will need to switch it up for something that does, @typescript-eslint/parser.\u003C/p\u003E\n\u003Cp\u003ESo, update the parser, extensions and plugins in your eslint configuration file:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"parser\": \"@typescript-eslint/parser\", // &lt;-- Update this line\u003Cbr\u003E  \"extends\": [\u003Cbr\u003E    \"airbnb\",\u003Cbr\u003E    \"airbnb/hooks\",\u003Cbr\u003E    // your other extensions\u003Cbr\u003E    \"plugin:@typescript-eslint/eslint-recommended\", // &lt;-- Add this line\u003Cbr\u003E    \"plugin:@typescript-eslint/recommended\" // &lt;-- Add this line\u003Cbr\u003E  ],\u003Cbr\u003E  \"plugins\": [\u003Cbr\u003E    \"@babel\",\u003Cbr\u003E    \"react\",\u003Cbr\u003E    \"react-hooks\",\u003Cbr\u003E    // your other plugins\u003Cbr\u003E    \"@typescript-eslint\" // &lt;-- Add this line\u003Cbr\u003E   ],\u003Cbr\u003E... // your other settings\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EAfter updating your linter you may encounter new issues due to the new rules: fix them and create a new commit if so.\u003C/p\u003E\n\u003Ch3\u003EStep #7: Build &amp; Check code\u003C/h3\u003E\n\u003Cp\u003EAt this point, you should have a working monorepo. Check that the tests run, that your linter works properly with .js | .jsx | .ts | .tsx extensions, and troubleshoot if not.\u003C/p\u003E\n\u003Cp\u003EAnother important thing to do is to build each package. You may encounter issues at that stage that you might not have experienced during development. Don’t save that for the last minute.\u003C/p\u003E\n\u003Ch3\u003EStep #8: Pat yourself on the back\u003C/h3\u003E\n\u003Cp\u003EIf you made it to this point and everything is working, you can give yourself a pat on the back. Good job!\u003C/p\u003E\n\u003Ch3\u003EPitfalls I encountered\u003C/h3\u003E\n\u003Cp\u003EDuring this migration I learned a lot. Not only on the TSConfiguration, but deepened my knowledge on how everything plays along in a bigger setting.\u003C/p\u003E\n\u003Cp\u003EOne of the things that turned my hair a little bit more grey was the path and baseUrl settings in the tsconfig file. It turns out, that nowadays you don’t need anymore baseUrl, but you can still use it.\u003C/p\u003E\n\u003Cp\u003ESo I was playing around with both options without fully understanding them and I was trying to set paths to other packages without succees.\u003C/p\u003E\n\u003Cp\u003EThe problem was, that the baseUrl was pointing to a nested src folder, while the way I wrote the path to the package as if it were the root. So obviously, that didn’t work.\u003C/p\u003E\n\u003Cp\u003ESo, this wasn’t working:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \"src\",\u003Cbr\u003E    \"paths\": {\u003Cbr\u003E      \"*\": [\"../packageMain/src/*\"], // from src, should had been 2 folders up\u003Cbr\u003E      \"somePackage/*\": [\u003Cbr\u003E        \"../somePackage/*\" // from src, should had been 2 folders up\u003Cbr\u003E      ]\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003ESo, either I should had removed the baseUrl or updated the paths to be one folder up:\u003C/p\u003E\n\u003Cpre\u003E{\u003Cbr\u003E  \"extends\": \"../../tsconfig.json\",\u003Cbr\u003E  \"compilerOptions\": {\u003Cbr\u003E    \"baseUrl\": \"src\",\u003Cbr\u003E    \"paths\": {\u003Cbr\u003E      \"*\": [\"../../packageMain/src/*\"],\u003Cbr\u003E      \"somePackage/*\": [\u003Cbr\u003E        \"../../somePackage/*\"\u003Cbr\u003E      ]\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EThat little mistake cost me more time than I would have liked 😅\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*XBNEC48W6UnV_QVE\"\u003E\u003C/figure\u003E\u003Ch3\u003EDo you need Babel at all for TypeScript?\u003C/h3\u003E\n\u003Cp\u003EIf you are sticking with Babel for other reasons (e.g., using plugins for JSX, polyfills, or custom transformations), then you will need Babel + TypeScript integration. Otherwise, TypeScript alone (via tsc or through Webpack’s ts-loader) can handle the transformation.\u003C/p\u003E\n\u003Cp\u003EHowever, CRA uses Babel by default, and if you’re migrating while retaining CRA’s Babel setup, you’ll still need Babel in the pipeline.\u003C/p\u003E\n\u003Cp\u003EIf you’re only using TypeScript for type-checking and aren’t relying on custom Babel plugins, you could skip Babel entirely and instead use ts-loader with Webpack for a more native TypeScript workflow.\u003C/p\u003E\n\u003Ch3\u003EWrapping Up\u003C/h3\u003E\n\u003Cp\u003EMigrating to TypeScript in a Create React App monorepo using CRACO can seem like a challenging task, but with a clear plan, each step becomes manageable.\u003C/p\u003E\n\u003Cp\u003EWhile the process involves updating configurations, installing dependencies, and adjusting ESLint and Babel settings, the end result is a more robust, maintainable codebase. You’ll appreciate the type safety and reduced runtime errors that TypeScript provides, especially in larger projects.\u003C/p\u003E\n\u003Cp\u003EIf you encounter issues along the way — whether it’s linter conflicts, outdated dependencies, or unfamiliar TypeScript errors — remember to tackle them one at a time, commit frequently, and, most importantly, remain patient.\u003C/p\u003E\n\u003Cp\u003EThese steps are an investment in your project’s future scalability and stability. And trust me, once you’ve lived to tell the tale, you’ll be glad you made the switch.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cad3de4acfa0\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/mastering-typescript-migration-in-a-create-react-app-monorepo-a-practical-guide-with-craco-cad3de4acfa0\"\u003EMastering TypeScript Migration in a Create React App Monorepo: A Practical Guide with CRACO\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "monorepo",
        "typescript",
        "babel",
        "react",
        "eslint"
      ]
    },
    {
      "title": "React Tabs: Prevent Flickering When Highlighting with Bold Text",
      "pubDate": "2024-09-23 01:08:16",
      "link": "https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/fa12d319cb18",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i6acAv13QfrVYx_3XvLCIw.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EWhen styling tab components, using bold text to highlight the selected tab can often cause an annoying flicker effect when switching between tabs. If you look closely at the image below, you will see that the last element slightly moves its position when another tab is selected:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*9Hmfp1Sobg42zEQIC1osrg.gif\"\u003E\u003Cfigcaption\u003EInconsistent UI: Subtle but annoying\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EIn this article, I’ll show you how to avoid this issue with a simple CSS trick.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EWhy This Happens\u003C/h3\u003E\n\u003Cp\u003EThe flicker happens because changing the font weight forces the browser to recalculate the layout, as bold fonts are wider than regular ones. This change in width can cause visible flickering.\u003C/p\u003E\n\u003Cp\u003ETo avoid this, we can use CSS pseudo-elements (::before and ::after) to pre-render an ‘invisible’ bold version of the text. This method maintains a consistent width, preventing the flicker effect.\u003C/p\u003E\n\u003Cp\u003ETo achieve that we will need to take advantage of the data-content property too. We will pass the text content to our pseudo-elements to allow them to have the same content without duplicating it in the HTML structure.\u003C/p\u003E\n\u003Cp\u003ESo instead of:\u003C/p\u003E\n\u003Cpre\u003Eimport classNames from 'classnames';\u003Cbr\u003Eimport React from 'react';\u003Cbr\u003Eimport * as RadixTabs from '@radix-ui/react-tabs';\u003Cbr\u003Eimport styles from './Tab.module.scss';\u003Cbr\u003E\u003Cbr\u003Einterface TabProps {\u003Cbr\u003E  value: string;\u003Cbr\u003E  icon?: React.ReactNode;\u003Cbr\u003E  name: string;\u003Cbr\u003E  disabled?: boolean;\u003Cbr\u003E  selected?: boolean;\u003Cbr\u003E  onClick: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;RadixTabs.Trigger\u003Cbr\u003E      value={value}\u003Cbr\u003E      className={classNames(\u003Cbr\u003E        styles.root,\u003Cbr\u003E        {\u003Cbr\u003E          [styles.selected]: selected,\u003Cbr\u003E          [styles.disabled]: disabled,\u003Cbr\u003E        })}\u003Cbr\u003E      onClick={onClick}\u003Cbr\u003E    &gt;\u003Cbr\u003E      {icon}\u003Cbr\u003E      {name}\u003Cbr\u003E    &lt;/RadixTabs.Trigger&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport default Tab;\u003C/pre\u003E\n\u003Cp\u003EDo:\u003C/p\u003E\n\u003Cpre\u003Econst Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;RadixTabs.Trigger\u003Cbr\u003E      value={value}\u003Cbr\u003E      className={classNames(\u003Cbr\u003E        styles.root,\u003Cbr\u003E        {\u003Cbr\u003E          [styles.selected]: selected,\u003Cbr\u003E          [styles.disabled]: disabled,\u003Cbr\u003E        }\u003Cbr\u003E      )}\u003Cbr\u003E      onClick={onClick}\u003Cbr\u003E    &gt;\u003Cbr\u003E      {icon}\u003Cbr\u003E      &lt;span\u003Cbr\u003E        data-content={name}\u003Cbr\u003E        className={styles.content}\u003Cbr\u003E      &gt;\u003Cbr\u003E        {name}\u003Cbr\u003E      &lt;/span&gt;\u003Cbr\u003E    &lt;/RadixTabs.Trigger&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport default Tab;\u003C/pre\u003E\n\u003Cp\u003EWhat did we do here? We wrapped the tab text inside a span element and added two attributes: data-content and a className. The data-content attribute holds the text of the tab, and the className applies the necessary styles with pseudo-elements.\u003C/p\u003E\n\u003Cp\u003EThen, in the .scss file add:\u003C/p\u003E\n\u003Cpre\u003E.root {\u003Cbr\u003E  // Other styles...\u003Cbr\u003E\u003Cbr\u003E  .content {\u003Cbr\u003E    &amp;::before {\u003Cbr\u003E      content: attr(data-content);  // Preload normal font weight\u003Cbr\u003E      display: block;\u003Cbr\u003E      font-weight: normal;\u003Cbr\u003E      height: 0;\u003Cbr\u003E      visibility: hidden;\u003Cbr\u003E      color: transparent;\u003Cbr\u003E      overflow: hidden;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    &amp;::after {\u003Cbr\u003E      content: attr(data-content);  // Preload bold font weight\u003Cbr\u003E      display: block;\u003Cbr\u003E      font-weight: 700; // bold!\u003Cbr\u003E      height: 0;\u003Cbr\u003E      visibility: hidden;\u003Cbr\u003E      color: transparent;\u003Cbr\u003E      overflow: hidden;\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EVoilà! The tabs are working without flickering:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*vFWN0otYn8kSsvwHz-hkeg.gif\"\u003E\u003Cfigcaption\u003ENo more flickering!\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EWhy the ::after Might Be Unnecessary\u003C/h3\u003E\n\u003Cp\u003EIn some cases, deleting the ::after code won't change your tabs' behavior because the ::before pseudo-element alone can preload the font and prevent flickering. The browser might cache the bold font weight, making ::after redundant in some cases. However, keeping both ::before and ::after ensures consistency across different browsers.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EBy using the data-content attribute and the pseudo-elements ::before and ::after you can eliminate the flicker effect that occurs when changing font weight, improving the general user experience.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fa12d319cb18\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18\"\u003EReact Tabs: Prevent Flickering When Highlighting with Bold Text\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i6acAv13QfrVYx_3XvLCIw.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EWhen styling tab components, using bold text to highlight the selected tab can often cause an annoying flicker effect when switching between tabs. If you look closely at the image below, you will see that the last element slightly moves its position when another tab is selected:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*9Hmfp1Sobg42zEQIC1osrg.gif\"\u003E\u003Cfigcaption\u003EInconsistent UI: Subtle but annoying\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003EIn this article, I’ll show you how to avoid this issue with a simple CSS trick.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EWhy This Happens\u003C/h3\u003E\n\u003Cp\u003EThe flicker happens because changing the font weight forces the browser to recalculate the layout, as bold fonts are wider than regular ones. This change in width can cause visible flickering.\u003C/p\u003E\n\u003Cp\u003ETo avoid this, we can use CSS pseudo-elements (::before and ::after) to pre-render an ‘invisible’ bold version of the text. This method maintains a consistent width, preventing the flicker effect.\u003C/p\u003E\n\u003Cp\u003ETo achieve that we will need to take advantage of the data-content property too. We will pass the text content to our pseudo-elements to allow them to have the same content without duplicating it in the HTML structure.\u003C/p\u003E\n\u003Cp\u003ESo instead of:\u003C/p\u003E\n\u003Cpre\u003Eimport classNames from 'classnames';\u003Cbr\u003Eimport React from 'react';\u003Cbr\u003Eimport * as RadixTabs from '@radix-ui/react-tabs';\u003Cbr\u003Eimport styles from './Tab.module.scss';\u003Cbr\u003E\u003Cbr\u003Einterface TabProps {\u003Cbr\u003E  value: string;\u003Cbr\u003E  icon?: React.ReactNode;\u003Cbr\u003E  name: string;\u003Cbr\u003E  disabled?: boolean;\u003Cbr\u003E  selected?: boolean;\u003Cbr\u003E  onClick: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Econst Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;RadixTabs.Trigger\u003Cbr\u003E      value={value}\u003Cbr\u003E      className={classNames(\u003Cbr\u003E        styles.root,\u003Cbr\u003E        {\u003Cbr\u003E          [styles.selected]: selected,\u003Cbr\u003E          [styles.disabled]: disabled,\u003Cbr\u003E        })}\u003Cbr\u003E      onClick={onClick}\u003Cbr\u003E    &gt;\u003Cbr\u003E      {icon}\u003Cbr\u003E      {name}\u003Cbr\u003E    &lt;/RadixTabs.Trigger&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport default Tab;\u003C/pre\u003E\n\u003Cp\u003EDo:\u003C/p\u003E\n\u003Cpre\u003Econst Tab: React.FC&lt;TabProps&gt; = ({ value, icon, name, disabled = false, selected = false, onClick }) =&gt; {\u003Cbr\u003E  return (\u003Cbr\u003E    &lt;RadixTabs.Trigger\u003Cbr\u003E      value={value}\u003Cbr\u003E      className={classNames(\u003Cbr\u003E        styles.root,\u003Cbr\u003E        {\u003Cbr\u003E          [styles.selected]: selected,\u003Cbr\u003E          [styles.disabled]: disabled,\u003Cbr\u003E        }\u003Cbr\u003E      )}\u003Cbr\u003E      onClick={onClick}\u003Cbr\u003E    &gt;\u003Cbr\u003E      {icon}\u003Cbr\u003E      &lt;span\u003Cbr\u003E        data-content={name}\u003Cbr\u003E        className={styles.content}\u003Cbr\u003E      &gt;\u003Cbr\u003E        {name}\u003Cbr\u003E      &lt;/span&gt;\u003Cbr\u003E    &lt;/RadixTabs.Trigger&gt;\u003Cbr\u003E  );\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Eexport default Tab;\u003C/pre\u003E\n\u003Cp\u003EWhat did we do here? We wrapped the tab text inside a span element and added two attributes: data-content and a className. The data-content attribute holds the text of the tab, and the className applies the necessary styles with pseudo-elements.\u003C/p\u003E\n\u003Cp\u003EThen, in the .scss file add:\u003C/p\u003E\n\u003Cpre\u003E.root {\u003Cbr\u003E  // Other styles...\u003Cbr\u003E\u003Cbr\u003E  .content {\u003Cbr\u003E    &amp;::before {\u003Cbr\u003E      content: attr(data-content);  // Preload normal font weight\u003Cbr\u003E      display: block;\u003Cbr\u003E      font-weight: normal;\u003Cbr\u003E      height: 0;\u003Cbr\u003E      visibility: hidden;\u003Cbr\u003E      color: transparent;\u003Cbr\u003E      overflow: hidden;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    &amp;::after {\u003Cbr\u003E      content: attr(data-content);  // Preload bold font weight\u003Cbr\u003E      display: block;\u003Cbr\u003E      font-weight: 700; // bold!\u003Cbr\u003E      height: 0;\u003Cbr\u003E      visibility: hidden;\u003Cbr\u003E      color: transparent;\u003Cbr\u003E      overflow: hidden;\u003Cbr\u003E    }\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EVoilà! The tabs are working without flickering:\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*vFWN0otYn8kSsvwHz-hkeg.gif\"\u003E\u003Cfigcaption\u003ENo more flickering!\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EWhy the ::after Might Be Unnecessary\u003C/h3\u003E\n\u003Cp\u003EIn some cases, deleting the ::after code won't change your tabs' behavior because the ::before pseudo-element alone can preload the font and prevent flickering. The browser might cache the bold font weight, making ::after redundant in some cases. However, keeping both ::before and ::after ensures consistency across different browsers.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EBy using the data-content attribute and the pseudo-elements ::before and ::after you can eliminate the flicker effect that occurs when changing font weight, improving the general user experience.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fa12d319cb18\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/react-tabs-prevent-flickering-when-highlighting-with-bold-text-fa12d319cb18\"\u003EReact Tabs: Prevent Flickering When Highlighting with Bold Text\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "reactjs",
        "ui-ux-design",
        "react",
        "radix",
        "tabs"
      ]
    },
    {
      "title": "My GitHub Administration Exam Certification Experience",
      "pubDate": "2024-09-12 14:49:07",
      "link": "https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/65a999a008da",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cp\u003EA Comprehensive Guide to Acing the GitHub Administration Exam\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/616/0*-ZyLdt_ypZqP-fJV\"\u003E\u003Cfigcaption\u003EGitHub Admin Badge\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EAfter completing the Advanced Security Exam in August and achieving three of the four certifications — well, until Copilot becomes available to the public in October — I couldn’t just sit still: I needed to complete the sequel. And I did!.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZW4tUKN7kA3YDvyRP-Vqkg.jpeg\"\u003E\u003Cfigcaption\u003EThe Four Aces of GitHub\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003ELeaving aside my obsession to get all of them, in this article, I’m sharing the knowledge that will make it easier for you to get certified as well as my personal experience. What works, what doesn’t, shoulds, and shouldn’ts. Also, this certification doesn’t have as much content available as its smaller siblings, so it might be challenging to know where to start.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EConsiderations and how to approach\u003C/h3\u003E\n\u003Cp\u003EThe GitHub Administration Exam is cut from a different cloth than the other three. Andrew Brown classifies it as the hardest of them all. No surprise he hadn’t made any content for it yet for ExamPro. The good news, is that I personally didn’t find it as challenging.\u003C/p\u003E\n\u003Cp\u003EThe exam is shorter than the others — totaling about 66 questions instead of the usual 70 or 75. The time frame is the same, so you have more room to review your answers.\u003C/p\u003E\n\u003Cp\u003EI just think that due to the lack of resources available people don’t quite now where to start. It may not be as easily approachable as its siblings, but here’s what you’re up against:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EAdvanced Administration\u003C/strong\u003E: Expect to showcase your expertise in managing GitHub organizations, repositories, and user permissions at a granular level. You will need to have a really clear picture of the different settings that are available for Organizations and Enterprises. This exam plays dirty on what you can do on each of them. Same thing for permissions and roles. Having a role at the organization level is not the same as having a role in the repository level. Make sure you know those differences.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ESecurity and Compliance\u003C/strong\u003E: You’ll need to prove your knowledge in securing GitHub workflows and ensuring compliance with best practices and organizational policies. This includes understanding advanced security features inside GitHub Actions and Packages. You will also need to have a general understanding of a security posture, and for that a lot of content from the Advanced Security Exam might come handy.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EIntegrations and troubleshooting\u003C/strong\u003E: Be prepared to handle questions regarding how GitHub integrates with third party platforms, especially on SAML, and SCIM.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EStudy strategy\u003C/h3\u003E\n\u003Cp\u003EThe same recommendation as the previous three exams applies, with the difference that I couldn’t find a good video tutorial. The only one available is from LinkedIn Learning, and after viewing it in its entirety, I can’t recommend it. It’s too basic. So, intead of that I recommend:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EStart by reading the study guide thoroughly to understand the scope and content of the exam. Ask your prefered AI Assistent to briefly explain each of the topics to have a broad idea.\u003C/li\u003E\n\u003Cli\u003EFollow up by reading the relevant sections in the documentation. This is crucial since it is basically the only good source to study from. Try and play with the platform.\u003C/li\u003E\n\u003Cli\u003EThere is also GitHub Learning. I liked it as an introduction, but no more than that.\u003C/li\u003E\n\u003Cli\u003EAnother option is to study from Microsoft’s Learning Path, if you must🤷.\u003C/li\u003E\n\u003Cli\u003EFinally, before the real exam, do practice tests. I found a few that were good enough to practice, but not as thorough as the real exam. A good strategy I found is to challenge myself with more niche questions on the same topic whenever a question seems too easy. This way, I forced myself to go over the documentation and learn the ins and outs.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EResource materials\u003C/h3\u003E\n\u003Cul\u003E\n\u003Cli\u003E📚 \u003Ca href=\"https://assets.ctfassets.net/wfutmusr1t3h/4WQrNeENScZlISZKdknVbK/fa664e4ba61056df9194331de18aec0b/github-advanced-security-exam-preparation-study-guide__4_.pdf\"\u003EStudy Guide\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E🐙 \u003Ca href=\"https://resources.github.com/learn/pathways/administration-governance/essentials/administration-governance-github-enterprise-cloud/\"\u003EGitHub Learning\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E🫤 \u003Ca href=\"https://learn.microsoft.com/en-us/collections/mom7u1gzjdxw03\"\u003EMicrosoft Learning Path\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E📝 \u003Ca href=\"https://www.udemy.com/share/10aT2Q3@Q6uVZIkLVQHr_u7EkFrqVxVZAz0E650qzmSpLLCphyG62gMHxT3QgSwnSGZrhnqcNQ==/\"\u003EPractice Exams\u003C/a\u003E\n\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003ESo… How to study?\u003Cbr\u003EGo over the GitHub / Microsoft resources (whichever you hate the least) and then focus on completely reading the documentation.\u003C/p\u003E\n\u003Cp\u003EMy recommendation is to dedicate a full day to quickly go through either of these two resources to grasp the overall picture. Afterward, refine your knowledge by diving into the specifics in the documentation whenever directed.\u003C/p\u003E\n\u003Cp\u003EAlso, while practicing is crucial, be cautious with the online practice tests; they are often far too easy compared to the real exam. I’m sharing the closest one I found, but keep in mind that its difficulty level may still not fully match the actual test. Best way to practice? Drop some section of the docs to ChatGPT and ask it to create questions for you.\u003C/p\u003E\n\u003Ch3\u003EWrapping Up\u003C/h3\u003E\n\u003Cp\u003EThe knowledge required for the Administration Exam is the kind you’d expect from any one managing code or people. While knowing how to use Git and GitHub is a given, the ability to handle security, permissions, and synchronization that is the most important.\u003C/p\u003E\n\u003Cp\u003EHolding a certification in this area underscores your proficiency as a competent individual on a team, setting yourself apart.\u003C/p\u003E\n\u003Cp\u003EAfter finishing all of them, I’m satisfied with myself and somewhat proud to have achieved all four certifications. I’m incredibly proud of the dedication and motivation I’ve put into this journey and while some might overlook certifications, the effort and commitment required to earn them can’t be underestimated.\u003C/p\u003E\n\u003Cp\u003EEach certification represents a significant milestone, reflecting not just knowledge but the perseverance to excel in a challenging field.\u003C/p\u003E\n\u003Cp\u003EWhile I might not yet be a “GitHub Hero” my journey from where I started as a regular user was full of valuable insights, and now I stand further than where I started. And at the end of the day, that is what matters.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=65a999a008da\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da\"\u003EMy GitHub Administration Exam Certification Experience\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cp\u003EA Comprehensive Guide to Acing the GitHub Administration Exam\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/616/0*-ZyLdt_ypZqP-fJV\"\u003E\u003Cfigcaption\u003EGitHub Admin Badge\u003C/figcaption\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EAfter completing the Advanced Security Exam in August and achieving three of the four certifications — well, until Copilot becomes available to the public in October — I couldn’t just sit still: I needed to complete the sequel. And I did!.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZW4tUKN7kA3YDvyRP-Vqkg.jpeg\"\u003E\u003Cfigcaption\u003EThe Four Aces of GitHub\u003C/figcaption\u003E\u003C/figure\u003E\u003Cp\u003ELeaving aside my obsession to get all of them, in this article, I’m sharing the knowledge that will make it easier for you to get certified as well as my personal experience. What works, what doesn’t, shoulds, and shouldn’ts. Also, this certification doesn’t have as much content available as its smaller siblings, so it might be challenging to know where to start.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EConsiderations and how to approach\u003C/h3\u003E\n\u003Cp\u003EThe GitHub Administration Exam is cut from a different cloth than the other three. Andrew Brown classifies it as the hardest of them all. No surprise he hadn’t made any content for it yet for ExamPro. The good news, is that I personally didn’t find it as challenging.\u003C/p\u003E\n\u003Cp\u003EThe exam is shorter than the others — totaling about 66 questions instead of the usual 70 or 75. The time frame is the same, so you have more room to review your answers.\u003C/p\u003E\n\u003Cp\u003EI just think that due to the lack of resources available people don’t quite now where to start. It may not be as easily approachable as its siblings, but here’s what you’re up against:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EAdvanced Administration\u003C/strong\u003E: Expect to showcase your expertise in managing GitHub organizations, repositories, and user permissions at a granular level. You will need to have a really clear picture of the different settings that are available for Organizations and Enterprises. This exam plays dirty on what you can do on each of them. Same thing for permissions and roles. Having a role at the organization level is not the same as having a role in the repository level. Make sure you know those differences.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ESecurity and Compliance\u003C/strong\u003E: You’ll need to prove your knowledge in securing GitHub workflows and ensuring compliance with best practices and organizational policies. This includes understanding advanced security features inside GitHub Actions and Packages. You will also need to have a general understanding of a security posture, and for that a lot of content from the Advanced Security Exam might come handy.\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EIntegrations and troubleshooting\u003C/strong\u003E: Be prepared to handle questions regarding how GitHub integrates with third party platforms, especially on SAML, and SCIM.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EStudy strategy\u003C/h3\u003E\n\u003Cp\u003EThe same recommendation as the previous three exams applies, with the difference that I couldn’t find a good video tutorial. The only one available is from LinkedIn Learning, and after viewing it in its entirety, I can’t recommend it. It’s too basic. So, intead of that I recommend:\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EStart by reading the study guide thoroughly to understand the scope and content of the exam. Ask your prefered AI Assistent to briefly explain each of the topics to have a broad idea.\u003C/li\u003E\n\u003Cli\u003EFollow up by reading the relevant sections in the documentation. This is crucial since it is basically the only good source to study from. Try and play with the platform.\u003C/li\u003E\n\u003Cli\u003EThere is also GitHub Learning. I liked it as an introduction, but no more than that.\u003C/li\u003E\n\u003Cli\u003EAnother option is to study from Microsoft’s Learning Path, if you must🤷.\u003C/li\u003E\n\u003Cli\u003EFinally, before the real exam, do practice tests. I found a few that were good enough to practice, but not as thorough as the real exam. A good strategy I found is to challenge myself with more niche questions on the same topic whenever a question seems too easy. This way, I forced myself to go over the documentation and learn the ins and outs.\u003C/li\u003E\n\u003C/ul\u003E\n\u003Ch3\u003EResource materials\u003C/h3\u003E\n\u003Cul\u003E\n\u003Cli\u003E📚 \u003Ca href=\"https://assets.ctfassets.net/wfutmusr1t3h/4WQrNeENScZlISZKdknVbK/fa664e4ba61056df9194331de18aec0b/github-advanced-security-exam-preparation-study-guide__4_.pdf\"\u003EStudy Guide\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E🐙 \u003Ca href=\"https://resources.github.com/learn/pathways/administration-governance/essentials/administration-governance-github-enterprise-cloud/\"\u003EGitHub Learning\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E🫤 \u003Ca href=\"https://learn.microsoft.com/en-us/collections/mom7u1gzjdxw03\"\u003EMicrosoft Learning Path\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003E📝 \u003Ca href=\"https://www.udemy.com/share/10aT2Q3@Q6uVZIkLVQHr_u7EkFrqVxVZAz0E650qzmSpLLCphyG62gMHxT3QgSwnSGZrhnqcNQ==/\"\u003EPractice Exams\u003C/a\u003E\n\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cp\u003ESo… How to study?\u003Cbr\u003EGo over the GitHub / Microsoft resources (whichever you hate the least) and then focus on completely reading the documentation.\u003C/p\u003E\n\u003Cp\u003EMy recommendation is to dedicate a full day to quickly go through either of these two resources to grasp the overall picture. Afterward, refine your knowledge by diving into the specifics in the documentation whenever directed.\u003C/p\u003E\n\u003Cp\u003EAlso, while practicing is crucial, be cautious with the online practice tests; they are often far too easy compared to the real exam. I’m sharing the closest one I found, but keep in mind that its difficulty level may still not fully match the actual test. Best way to practice? Drop some section of the docs to ChatGPT and ask it to create questions for you.\u003C/p\u003E\n\u003Ch3\u003EWrapping Up\u003C/h3\u003E\n\u003Cp\u003EThe knowledge required for the Administration Exam is the kind you’d expect from any one managing code or people. While knowing how to use Git and GitHub is a given, the ability to handle security, permissions, and synchronization that is the most important.\u003C/p\u003E\n\u003Cp\u003EHolding a certification in this area underscores your proficiency as a competent individual on a team, setting yourself apart.\u003C/p\u003E\n\u003Cp\u003EAfter finishing all of them, I’m satisfied with myself and somewhat proud to have achieved all four certifications. I’m incredibly proud of the dedication and motivation I’ve put into this journey and while some might overlook certifications, the effort and commitment required to earn them can’t be underestimated.\u003C/p\u003E\n\u003Cp\u003EEach certification represents a significant milestone, reflecting not just knowledge but the perseverance to excel in a challenging field.\u003C/p\u003E\n\u003Cp\u003EWhile I might not yet be a “GitHub Hero” my journey from where I started as a regular user was full of valuable insights, and now I stand further than where I started. And at the end of the day, that is what matters.\u003C/p\u003E\n\u003Cp\u003EHappy Coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=65a999a008da\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/my-github-administration-exam-certification-experience-65a999a008da\"\u003EMy GitHub Administration Exam Certification Experience\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "administration",
        "github-administration",
        "github",
        "certification",
        "github-certification"
      ]
    },
    {
      "title": "5 Ways I Use AI in Front-End Development",
      "pubDate": "2024-09-02 12:17:34",
      "link": "https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/ee3490516dd4",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Ch4\u003ESharing AI techniques that have transformed my workflow and enhanced my coding productivity.\u003C/h4\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*r5ZF3HS2gMcHst_uzs8GQw.png\"\u003E\u003C/figure\u003E\u003Ch3\u003E\u003Cstrong\u003EIntroduction\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EIn 2024, not using AI is like laughing at mobile phones in the early 2000s. In this post, I’ll share 5 ways I use AI to supercharge my efficiency and be a more productive developer.\u003C/p\u003E\n\u003Ch3\u003E#1 Tone switcher\u003C/h3\u003E\n\u003Cp\u003EThis one is my favorite and the one I use the most. Many times, I need to write messages to other team members that, due to their content, might be taken the wrong way.\u003C/p\u003E\n\u003Cp\u003EFor example, you don’t want to offend a Back-End developer by telling them how problematic their endpoint is or that they should send you response A instead of B.\u003C/p\u003E\n\u003Cp\u003ESo, instead of:\u003C/p\u003E\n\u003Cblockquote\u003EHey, the API response for endpoint Z is completely wrong. I get it that when I do a PUT you should always return the same object. However, since you are running side effects on my call I am not getting the whole picture of the updated data state. The isMain property shouldn’t be inside the address object, but a companyProperty, as an id. That way, whenever the main address is updated you don’t need to map through the whole database to turn off the previous one. O(1) vs O(n). How much effort would it take to fix it?\u003C/blockquote\u003E\n\u003Cp\u003EPrompt:\u003C/p\u003E\n\u003Cp\u003EI need to send a message to a backend developer regarding an issue with the API response to endpoint Z. The message should clearly explain the problem with the response and suggest a solution. However, it should be phrased in a constructive, respectful, and collaborative tone. Here’s my original message: (…)\u003C/p\u003E\n\u003Cp\u003EResult:\u003C/p\u003E\n\u003Cblockquote\u003E“Hi [Name],\u003C/blockquote\u003E\n\u003Cblockquote\u003EI’ve been reviewing the API response for endpoint Z and noticed an issue that might affect data consistency. When I make a PUT request, I understand that the same object should be returned. However, due to the side effects, I’m not seeing the complete picture of the updated data state.\u003C/blockquote\u003E\n\u003Cblockquote\u003ESpecifically, the \u003Cem\u003EisMain\u003C/em\u003E property seems to be inside the address object, but I believe it would be more efficient as a company property, treated as an id. This change could help avoid mapping through the entire database when updating the main address, improving performance from O(n) to O(1).\u003C/blockquote\u003E\n\u003Cblockquote\u003ECould we discuss how long it would take to implement this adjustment? I think it could really streamline the process. Let me know your thoughts — thanks for your help!”\u003C/blockquote\u003E\n\u003Cp\u003ELiked 👍.\u003C/p\u003E\n\u003Ch3\u003E#2: Data mapping\u003C/h3\u003E\n\u003Cp\u003EMany times when I am working on a feature I need to transform the data in a very specific way. For example, I needed to create a multi-select component from a list like this one:\u003C/p\u003E\n\u003Cpre\u003Econst animals = [\u003Cbr\u003E  {id: 'CATS', name: 'animals_cats', type: 'DOMESTIC'},\u003Cbr\u003E  {id: 'DOGS', name: 'animals_dogs', type: 'DOMESTIC'},\u003Cbr\u003E  {id: 'EAGLES', name: 'animals_eagles', type: 'WILD'},\u003Cbr\u003E  {id: 'SHARKS', name: 'animals_sharks', type: 'WILD'},\u003Cbr\u003E  {id: 'PANDAS', name: 'animals_pandas', type: 'WILD'},\u003Cbr\u003E];\u003C/pre\u003E\n\u003Cp\u003ETo something like this, to be injected into my form as the initial values:\u003C/p\u003E\n\u003Cpre\u003E// Initial Form state with all values set as false (for example, for a petshop)\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  DOMESTIC: {\u003Cbr\u003E    'CATS': false,\u003Cbr\u003E    'DOGS': false\u003Cbr\u003E  },\u003Cbr\u003E  WILD: {\u003Cbr\u003E    'EAGLES': false,\u003Cbr\u003E    'SHARKS': false,\u003Cbr\u003E    'PANDAS': false\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EYeah, you are right. I could have sat for a few minutes to reduce that, but AI tools shine when you have input and output. I just needed to create a prompt for it. You can specify what you want to use.\u003C/p\u003E\n\u003Cblockquote\u003EGiven the following array of animals (…) Write a JavaScript solution using Lodash that outputs an object structured like this (…). Use reduce.\u003C/blockquote\u003E\n\u003Cp\u003EResult:\u003C/p\u003E\n\u003Cpre\u003Econst animalsMap = _.reduce(animals, (acc, {id, type}) =&gt; {\u003Cbr\u003E  acc[type] = acc[type] || {};\u003Cbr\u003E  acc[type][id] = false;\u003Cbr\u003E  return acc;\u003Cbr\u003E}, {});\u003C/pre\u003E\n\u003Ch3\u003E#3: Writing Unit Tests\u003C/h3\u003E\n\u003Cp\u003EWriting tests by hand in the AI era is the equivalent of using a discman in the 2010s. Nothing wrong with them, but we should welcome it when new technology makes our lives easier. AI shines in input-output operations as we mentioned before, and is an excelent tool to help you speed up writing unit tests.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EWarning\u003C/strong\u003E: You should always check the output, and examine the test cases. The chatbot might have spotted a behavior that it considers “normal” for your function, but for you, it would be a bug.\u003Cstrong\u003E So read the test cases\u003C/strong\u003E. Also, specify what your edge cases are: it might spot a bug or two.\u003C/p\u003E\n\u003Cp\u003EFor example, using a prompt like:\u003C/p\u003E\n\u003Cblockquote\u003EGiven the following Redux selector selectAnimalsEndpoint, I need to create a unit test using Jest. The test should verify that the selector returns the correct endpoint when the user has \u003Cstrong\u003Epermission X. \u003C/strong\u003EHere is the selector: (…).\u003C/blockquote\u003E\n\u003Cp\u003EBoom. The next thing you know is that you have suite of tests like the following:\u003C/p\u003E\n\u003Cpre\u003Eit('should return the correct endpoint given permission X', () =&gt; {\u003Cbr\u003E    const mockPermissionSelector = jest.spyOn(selectors, 'selectUserPermissions').mockReturnValue(() =&gt; true);\u003Cbr\u003E    const mode = 'UPDATE';\u003Cbr\u003E    const endpoint = selectAnimalsEndpoint(animalGroups, mode)({permissions: {data: ['canEditAnimals']}});\u003Cbr\u003E    expect(endpoint).toBe(animalsUrls.updateAnimalsV4);\u003Cbr\u003E    mockPermissionSelector.mockRestore();\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ESure, not all of them pass on the first try, and sometimes they have minor things to be fixed, but it streamlines a good chunk of the work. The amount of time that I save is staggering.\u003C/p\u003E\n\u003Ch3\u003E#4 Troubleshooting Uncaught Errors\u003C/h3\u003E\n\u003Cp\u003EEvery once in a while, I perform technical tasks to maintain the project as a package, in addition to my daily tasks as a Front-end developer. Sometimes those tasks involve upgrading a package or migrating some tools, and when that is the case you know you will encounter errors during the process.\u003C/p\u003E\n\u003Cp\u003EFor example, when upgrading a major library or migrating to the latest version, you might run into issues with deprecated methods, compatibility problems, or unexpected bugs. Here’s how I use AI to troubleshoot these issues:\u003C/p\u003E\n\u003Cblockquote\u003EPrompt: I’m encountering an uncaught error after upgrading [PackageName] to version [VersionNumber]. The error message is: [ErrorMessage]. I’ve tried [InitialTroubleshootingSteps], but the issue persists. Can you help me identify potential causes and solutions?\u003C/blockquote\u003E\n\u003Cp\u003ESometimes, AI offers creative ideas beyond what you might find on Stack Overflow or suggests solutions you might not have considered. For example, checking some logs if available. While it’s not always perfectly accurate, sometimes its suggestions provide a trigger that leads to the actual solution.\u003C/p\u003E\n\u003Cp\u003EYou know, you don’t need it to be 100% accurate. Even brainstorming solutions can be a great way to get you out of your problem.\u003C/p\u003E\n\u003Ch3\u003E\u003Cstrong\u003E#5 Planning and estimating\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EThis one is the most underrated! Using AI chatbots for coding is a well-known resource… but using it for planning and estimation and satisfying product managers? That is a whole new level.\u003C/p\u003E\n\u003Cp\u003EThe trick here is to use previously completed tasks or epics that include a detailed timetable and item breakdown as a resource. By feeding this data, you can ask for assistance in estimating the time required for your next set of tasks.\u003C/p\u003E\n\u003Cp\u003EFor example, if you’ve already finished a feature and know it took you 4.5 days to complete 4 items, you can provide this information in your prompt. Then, when faced with a similar feature, you can ask it to break down the tasks. You can also estimate how long each one might take. This can give you a strong starting point for your planning sessions. I keep a doc with some of my plans (no need for more than 6–7, but you can find the number that suits you best).\u003C/p\u003E\n\u003Cp\u003EEach of those plans looks something like this:\u003C/p\u003E\n\u003Cpre\u003E1. Design Form Layout (1 day):\u003Cbr\u003E- Create Wireframes (0.5 day): Sketch the design; use Figma/Sketch.\u003Cbr\u003E- Review with Design Team (0.5 day): Present and adjust based on feedback.\u003Cbr\u003E\u003Cbr\u003E2. Develop Frontend Form Components (1.5 days):\u003Cbr\u003E- Build Form Components (1 day): Create React components (text fields, dropdowns); manage state.\u003Cbr\u003E- Implement Form Validation (0.5 day): Integrate Formik; set up validation rules.\u003Cbr\u003E\u003Cbr\u003E3. Integrate with Backend API (1 day):\u003Cbr\u003E- Create API Endpoints (0.5 day): Define and implement endpoints; set up testing.\u003Cbr\u003E- Implement API Integration (0.5 day): Develop API call functions; handle responses/errors.\u003Cbr\u003E\u003Cbr\u003E4. Testing (1 day):\u003Cbr\u003E- Write Unit Tests (0.5 day): Test form components and validation.\u003Cbr\u003E- Perform End-to-End Tests (0.5 day): Test feedback submission flow and API integration.\u003C/pre\u003E\n\u003Cp\u003EThen, when I am assigned another task, I can provide my input data, and the newly assigned task, and get a raw estimatation.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EAI in 2024 isn’t just a trend — it’s a game-changer. From refining communication with tone adjustments to automating data mapping, writing unit tests, troubleshooting errors, and even planning projects, AI tools have become invaluable time-savers. By leveraging these techniques, you can boost your productivity and become a faster, more efficient developer.\u003C/p\u003E\n\u003Cp\u003EHowever, remember that AI is a tool like any other and should be used with caution. Just as you wouldn’t operate a chainsaw without proper safety equipment, always review how AI handles your data and validate its responses, as it is not infallible.\u003C/p\u003E\n\u003Ch3\u003EIn Plain English 🚀\u003C/h3\u003E\n\u003Cp\u003E\u003Cem\u003EThank you for being a part of the \u003C/em\u003E\u003Ca href=\"https://plainenglish.io/\"\u003E\u003Cstrong\u003E\u003Cem\u003EIn Plain English\u003C/em\u003E\u003C/strong\u003E\u003C/a\u003E\u003Cem\u003E community! Before you go:\u003C/em\u003E\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EBe sure to \u003Cstrong\u003Eclap\u003C/strong\u003E and \u003Cstrong\u003Efollow\u003C/strong\u003E the writer ️👏\u003Cstrong\u003E️️\u003C/strong\u003E\n\u003C/li\u003E\n\u003Cli\u003EFollow us: \u003Ca href=\"https://twitter.com/inPlainEngHQ\"\u003E\u003Cstrong\u003EX\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://www.linkedin.com/company/inplainenglish/\"\u003E\u003Cstrong\u003ELinkedIn\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw\"\u003E\u003Cstrong\u003EYouTube\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://discord.gg/in-plain-english-709094664682340443\"\u003E\u003Cstrong\u003EDiscord\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://newsletter.plainenglish.io/\"\u003E\u003Cstrong\u003ENewsletter\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003EVisit our other platforms: \u003Ca href=\"https://cofeed.app/\"\u003E\u003Cstrong\u003ECoFeed\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://differ.blog/\"\u003E\u003Cstrong\u003EDiffer\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003EMore content at \u003Ca href=\"https://plainenglish.io/\"\u003E\u003Cstrong\u003EPlainEnglish.io\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ee3490516dd4\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4\"\u003E5 Ways I Use AI in Front-End Development\u003C/a\u003E was originally published in \u003Ca href=\"https://javascript.plainenglish.io/\"\u003EJavaScript in Plain English\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Ch4\u003ESharing AI techniques that have transformed my workflow and enhanced my coding productivity.\u003C/h4\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*r5ZF3HS2gMcHst_uzs8GQw.png\"\u003E\u003C/figure\u003E\u003Ch3\u003E\u003Cstrong\u003EIntroduction\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EIn 2024, not using AI is like laughing at mobile phones in the early 2000s. In this post, I’ll share 5 ways I use AI to supercharge my efficiency and be a more productive developer.\u003C/p\u003E\n\u003Ch3\u003E#1 Tone switcher\u003C/h3\u003E\n\u003Cp\u003EThis one is my favorite and the one I use the most. Many times, I need to write messages to other team members that, due to their content, might be taken the wrong way.\u003C/p\u003E\n\u003Cp\u003EFor example, you don’t want to offend a Back-End developer by telling them how problematic their endpoint is or that they should send you response A instead of B.\u003C/p\u003E\n\u003Cp\u003ESo, instead of:\u003C/p\u003E\n\u003Cblockquote\u003EHey, the API response for endpoint Z is completely wrong. I get it that when I do a PUT you should always return the same object. However, since you are running side effects on my call I am not getting the whole picture of the updated data state. The isMain property shouldn’t be inside the address object, but a companyProperty, as an id. That way, whenever the main address is updated you don’t need to map through the whole database to turn off the previous one. O(1) vs O(n). How much effort would it take to fix it?\u003C/blockquote\u003E\n\u003Cp\u003EPrompt:\u003C/p\u003E\n\u003Cp\u003EI need to send a message to a backend developer regarding an issue with the API response to endpoint Z. The message should clearly explain the problem with the response and suggest a solution. However, it should be phrased in a constructive, respectful, and collaborative tone. Here’s my original message: (…)\u003C/p\u003E\n\u003Cp\u003EResult:\u003C/p\u003E\n\u003Cblockquote\u003E“Hi [Name],\u003C/blockquote\u003E\n\u003Cblockquote\u003EI’ve been reviewing the API response for endpoint Z and noticed an issue that might affect data consistency. When I make a PUT request, I understand that the same object should be returned. However, due to the side effects, I’m not seeing the complete picture of the updated data state.\u003C/blockquote\u003E\n\u003Cblockquote\u003ESpecifically, the \u003Cem\u003EisMain\u003C/em\u003E property seems to be inside the address object, but I believe it would be more efficient as a company property, treated as an id. This change could help avoid mapping through the entire database when updating the main address, improving performance from O(n) to O(1).\u003C/blockquote\u003E\n\u003Cblockquote\u003ECould we discuss how long it would take to implement this adjustment? I think it could really streamline the process. Let me know your thoughts — thanks for your help!”\u003C/blockquote\u003E\n\u003Cp\u003ELiked 👍.\u003C/p\u003E\n\u003Ch3\u003E#2: Data mapping\u003C/h3\u003E\n\u003Cp\u003EMany times when I am working on a feature I need to transform the data in a very specific way. For example, I needed to create a multi-select component from a list like this one:\u003C/p\u003E\n\u003Cpre\u003Econst animals = [\u003Cbr\u003E  {id: 'CATS', name: 'animals_cats', type: 'DOMESTIC'},\u003Cbr\u003E  {id: 'DOGS', name: 'animals_dogs', type: 'DOMESTIC'},\u003Cbr\u003E  {id: 'EAGLES', name: 'animals_eagles', type: 'WILD'},\u003Cbr\u003E  {id: 'SHARKS', name: 'animals_sharks', type: 'WILD'},\u003Cbr\u003E  {id: 'PANDAS', name: 'animals_pandas', type: 'WILD'},\u003Cbr\u003E];\u003C/pre\u003E\n\u003Cp\u003ETo something like this, to be injected into my form as the initial values:\u003C/p\u003E\n\u003Cpre\u003E// Initial Form state with all values set as false (for example, for a petshop)\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E  DOMESTIC: {\u003Cbr\u003E    'CATS': false,\u003Cbr\u003E    'DOGS': false\u003Cbr\u003E  },\u003Cbr\u003E  WILD: {\u003Cbr\u003E    'EAGLES': false,\u003Cbr\u003E    'SHARKS': false,\u003Cbr\u003E    'PANDAS': false\u003Cbr\u003E  }\u003Cbr\u003E}\u003C/pre\u003E\n\u003Cp\u003EYeah, you are right. I could have sat for a few minutes to reduce that, but AI tools shine when you have input and output. I just needed to create a prompt for it. You can specify what you want to use.\u003C/p\u003E\n\u003Cblockquote\u003EGiven the following array of animals (…) Write a JavaScript solution using Lodash that outputs an object structured like this (…). Use reduce.\u003C/blockquote\u003E\n\u003Cp\u003EResult:\u003C/p\u003E\n\u003Cpre\u003Econst animalsMap = _.reduce(animals, (acc, {id, type}) =&gt; {\u003Cbr\u003E  acc[type] = acc[type] || {};\u003Cbr\u003E  acc[type][id] = false;\u003Cbr\u003E  return acc;\u003Cbr\u003E}, {});\u003C/pre\u003E\n\u003Ch3\u003E#3: Writing Unit Tests\u003C/h3\u003E\n\u003Cp\u003EWriting tests by hand in the AI era is the equivalent of using a discman in the 2010s. Nothing wrong with them, but we should welcome it when new technology makes our lives easier. AI shines in input-output operations as we mentioned before, and is an excelent tool to help you speed up writing unit tests.\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EWarning\u003C/strong\u003E: You should always check the output, and examine the test cases. The chatbot might have spotted a behavior that it considers “normal” for your function, but for you, it would be a bug.\u003Cstrong\u003E So read the test cases\u003C/strong\u003E. Also, specify what your edge cases are: it might spot a bug or two.\u003C/p\u003E\n\u003Cp\u003EFor example, using a prompt like:\u003C/p\u003E\n\u003Cblockquote\u003EGiven the following Redux selector selectAnimalsEndpoint, I need to create a unit test using Jest. The test should verify that the selector returns the correct endpoint when the user has \u003Cstrong\u003Epermission X. \u003C/strong\u003EHere is the selector: (…).\u003C/blockquote\u003E\n\u003Cp\u003EBoom. The next thing you know is that you have suite of tests like the following:\u003C/p\u003E\n\u003Cpre\u003Eit('should return the correct endpoint given permission X', () =&gt; {\u003Cbr\u003E    const mockPermissionSelector = jest.spyOn(selectors, 'selectUserPermissions').mockReturnValue(() =&gt; true);\u003Cbr\u003E    const mode = 'UPDATE';\u003Cbr\u003E    const endpoint = selectAnimalsEndpoint(animalGroups, mode)({permissions: {data: ['canEditAnimals']}});\u003Cbr\u003E    expect(endpoint).toBe(animalsUrls.updateAnimalsV4);\u003Cbr\u003E    mockPermissionSelector.mockRestore();\u003Cbr\u003E});\u003C/pre\u003E\n\u003Cp\u003ESure, not all of them pass on the first try, and sometimes they have minor things to be fixed, but it streamlines a good chunk of the work. The amount of time that I save is staggering.\u003C/p\u003E\n\u003Ch3\u003E#4 Troubleshooting Uncaught Errors\u003C/h3\u003E\n\u003Cp\u003EEvery once in a while, I perform technical tasks to maintain the project as a package, in addition to my daily tasks as a Front-end developer. Sometimes those tasks involve upgrading a package or migrating some tools, and when that is the case you know you will encounter errors during the process.\u003C/p\u003E\n\u003Cp\u003EFor example, when upgrading a major library or migrating to the latest version, you might run into issues with deprecated methods, compatibility problems, or unexpected bugs. Here’s how I use AI to troubleshoot these issues:\u003C/p\u003E\n\u003Cblockquote\u003EPrompt: I’m encountering an uncaught error after upgrading [PackageName] to version [VersionNumber]. The error message is: [ErrorMessage]. I’ve tried [InitialTroubleshootingSteps], but the issue persists. Can you help me identify potential causes and solutions?\u003C/blockquote\u003E\n\u003Cp\u003ESometimes, AI offers creative ideas beyond what you might find on Stack Overflow or suggests solutions you might not have considered. For example, checking some logs if available. While it’s not always perfectly accurate, sometimes its suggestions provide a trigger that leads to the actual solution.\u003C/p\u003E\n\u003Cp\u003EYou know, you don’t need it to be 100% accurate. Even brainstorming solutions can be a great way to get you out of your problem.\u003C/p\u003E\n\u003Ch3\u003E\u003Cstrong\u003E#5 Planning and estimating\u003C/strong\u003E\u003C/h3\u003E\n\u003Cp\u003EThis one is the most underrated! Using AI chatbots for coding is a well-known resource… but using it for planning and estimation and satisfying product managers? That is a whole new level.\u003C/p\u003E\n\u003Cp\u003EThe trick here is to use previously completed tasks or epics that include a detailed timetable and item breakdown as a resource. By feeding this data, you can ask for assistance in estimating the time required for your next set of tasks.\u003C/p\u003E\n\u003Cp\u003EFor example, if you’ve already finished a feature and know it took you 4.5 days to complete 4 items, you can provide this information in your prompt. Then, when faced with a similar feature, you can ask it to break down the tasks. You can also estimate how long each one might take. This can give you a strong starting point for your planning sessions. I keep a doc with some of my plans (no need for more than 6–7, but you can find the number that suits you best).\u003C/p\u003E\n\u003Cp\u003EEach of those plans looks something like this:\u003C/p\u003E\n\u003Cpre\u003E1. Design Form Layout (1 day):\u003Cbr\u003E- Create Wireframes (0.5 day): Sketch the design; use Figma/Sketch.\u003Cbr\u003E- Review with Design Team (0.5 day): Present and adjust based on feedback.\u003Cbr\u003E\u003Cbr\u003E2. Develop Frontend Form Components (1.5 days):\u003Cbr\u003E- Build Form Components (1 day): Create React components (text fields, dropdowns); manage state.\u003Cbr\u003E- Implement Form Validation (0.5 day): Integrate Formik; set up validation rules.\u003Cbr\u003E\u003Cbr\u003E3. Integrate with Backend API (1 day):\u003Cbr\u003E- Create API Endpoints (0.5 day): Define and implement endpoints; set up testing.\u003Cbr\u003E- Implement API Integration (0.5 day): Develop API call functions; handle responses/errors.\u003Cbr\u003E\u003Cbr\u003E4. Testing (1 day):\u003Cbr\u003E- Write Unit Tests (0.5 day): Test form components and validation.\u003Cbr\u003E- Perform End-to-End Tests (0.5 day): Test feedback submission flow and API integration.\u003C/pre\u003E\n\u003Cp\u003EThen, when I am assigned another task, I can provide my input data, and the newly assigned task, and get a raw estimatation.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EAI in 2024 isn’t just a trend — it’s a game-changer. From refining communication with tone adjustments to automating data mapping, writing unit tests, troubleshooting errors, and even planning projects, AI tools have become invaluable time-savers. By leveraging these techniques, you can boost your productivity and become a faster, more efficient developer.\u003C/p\u003E\n\u003Cp\u003EHowever, remember that AI is a tool like any other and should be used with caution. Just as you wouldn’t operate a chainsaw without proper safety equipment, always review how AI handles your data and validate its responses, as it is not infallible.\u003C/p\u003E\n\u003Ch3\u003EIn Plain English 🚀\u003C/h3\u003E\n\u003Cp\u003E\u003Cem\u003EThank you for being a part of the \u003C/em\u003E\u003Ca href=\"https://plainenglish.io/\"\u003E\u003Cstrong\u003E\u003Cem\u003EIn Plain English\u003C/em\u003E\u003C/strong\u003E\u003C/a\u003E\u003Cem\u003E community! Before you go:\u003C/em\u003E\u003C/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EBe sure to \u003Cstrong\u003Eclap\u003C/strong\u003E and \u003Cstrong\u003Efollow\u003C/strong\u003E the writer ️👏\u003Cstrong\u003E️️\u003C/strong\u003E\n\u003C/li\u003E\n\u003Cli\u003EFollow us: \u003Ca href=\"https://twitter.com/inPlainEngHQ\"\u003E\u003Cstrong\u003EX\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://www.linkedin.com/company/inplainenglish/\"\u003E\u003Cstrong\u003ELinkedIn\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw\"\u003E\u003Cstrong\u003EYouTube\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://discord.gg/in-plain-english-709094664682340443\"\u003E\u003Cstrong\u003EDiscord\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://newsletter.plainenglish.io/\"\u003E\u003Cstrong\u003ENewsletter\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003EVisit our other platforms: \u003Ca href=\"https://cofeed.app/\"\u003E\u003Cstrong\u003ECoFeed\u003C/strong\u003E\u003C/a\u003E | \u003Ca href=\"https://differ.blog/\"\u003E\u003Cstrong\u003EDiffer\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003Cli\u003EMore content at \u003Ca href=\"https://plainenglish.io/\"\u003E\u003Cstrong\u003EPlainEnglish.io\u003C/strong\u003E\u003C/a\u003E\n\u003C/li\u003E\n\u003C/ul\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ee3490516dd4\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://javascript.plainenglish.io/5-ways-i-use-ai-in-front-end-development-ee3490516dd4\"\u003E5 Ways I Use AI in Front-End Development\u003C/a\u003E was originally published in \u003Ca href=\"https://javascript.plainenglish.io/\"\u003EJavaScript in Plain English\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "ai",
        "web-development",
        "artificial-intelligence",
        "javascript",
        "front-end-development"
      ]
    },
    {
      "title": "Rebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains",
      "pubDate": "2024-08-27 16:36:02",
      "link": "https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50?source=rss-9d104c42e755------2",
      "guid": "https://medium.com/p/22df25b5fe50",
      "author": "Jonatan Kruszewski",
      "thumbnail": "",
      "description": "\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NPUG8uIidQ6iUvKVmfqjzQ.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EQuestion: how many times did your development flow come to a standstill because a teammate didn’t review your Pull Request (PR)?\u003Cbr\u003EIt is true that PRs should have Priority Zero in any normal company. But do we all work in normal companies 😅? And even if so, sometimes your teammates are just too busy doing something else, or honestly, don’t want to review that humongous PR, or whatever.\u003C/p\u003E\n\u003Cp\u003EMeet what I call the \u003Cstrong\u003EContinuous Incremental PR Chain:\u003C/strong\u003E a flow I once answered someone in \u003Ca href=\"https://stackoverflow.com/questions/64324610/how-to-automatically-rebase-all-children-branches-onto-master-after-squashing-an/75858310#75858310\"\u003EStack Overflow\u003C/a\u003E, and now I refined it and shared it for you to use, based on continuously rebasing multiple stacked branches.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EOne PR is Never Enough: A Tale of Two Developers\u003C/h3\u003E\n\u003Cp\u003ELet’s take the example of two developers. Developer A works on his branch. He creates several commits along the creation of his feature. At the end, he submits a pull request.\u003C/p\u003E\n\u003Cpre\u003E  A--B--C--D--E--F--G--H--I   &lt;-- branch1\u003Cbr\u003E /\u003Cbr\u003EM                            &lt;-- main\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EResult:\u003C/strong\u003E A large request with lots of changes since it contains a lot of commits. The unique reviewer postpones reviewing that branch to the end of the day because they don’t feel like it: it is too much code. Developer A doesn’t get to be a rockstar at the office: he might even chase his reviewer to get some feedback— \u003Cem\u003E“Every Breath You Take”\u003C/em\u003E plays in the background.\u003C/p\u003E\n\u003Cp\u003EIn contrast, Developer B creates a branch for every few commits. He keeps on working, but when he makes progress uses a new branch on top of the previous one. Where Developer A had 10 commits in 1 PR, Developer B had 3 PRs with about 3 commits each. Developer B, as soon as he finishes a batch of commits, immediately creates a PR.\u003C/p\u003E\n\u003Cpre\u003E                  G--H--I   &lt;-- branch3 #PR to branch2\u003Cbr\u003E                 /    \u003Cbr\u003E          D--E--F   &lt;-- branch2 #PR to branch1\u003Cbr\u003E         /    \u003Cbr\u003E  A--B--C     &lt;-- branch1  #PR to main\u003Cbr\u003E /\u003Cbr\u003EM      &lt;-- main\u003C/pre\u003E\n\u003Cp\u003EDeveloper B can parallelize his feedback: he assigns each PR to a different team member. Each team member quickly reviews them, since they are small changes and “don’t require too much effort”. Also, now the review is split among more developers. Multithreading, anyone? Developer B gets higher quality feedback too, by getting different inputs. Thanks to his efficiency, Developer B finishes his work earlier — \u003Cem\u003E“I’m a Survivor”\u003C/em\u003E plays in the background.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*01fxMUbhNDX6FAFxhQK0Yg.gif\"\u003E\u003C/figure\u003E\u003Cp\u003EWhich one would you rather be?\u003C/p\u003E\n\u003Ch3\u003EStacked Branches and Constant Rebasing: A pain to maintain\u003C/h3\u003E\n\u003Cp\u003ENow that I convinced you to stack branches on top of each other, you might be wondering: “Why isn’t everybody doing this?” And the answer is \u003Cem\u003Erebasing\u003C/em\u003E. Constantly rebasing several branches can be a pain in the ass. At least, without using --update-refs, a somewhat “new” option about to be 2 years old in October 2024. I was surprised by how many people at the office had never heard about it.\u003C/p\u003E\n\u003Cp\u003EAfter merging branch1 into main, or trying to update the whole tree against the remote, you’re left with a problem: you now have to manually rebase each subsequent branch onto main.\u003C/p\u003E\n\u003Cpre\u003E                  G--H--I   &lt;-- branch3\u003Cbr\u003E                 /    \u003Cbr\u003E          D--E--F   &lt;-- branch2\u003Cbr\u003E         /    \u003Cbr\u003E  A--B--C \u003Cbr\u003E /\u003Cbr\u003EM--S       &lt;-- main (branch1 changes squashed in S)\u003C/pre\u003E\n\u003Cp\u003ETypically, you would rebase each one like this🤢:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main\u003Cbr\u003Egit checkout branch2\u003Cbr\u003Egit rebase --onto master (SHA-1 of C)\u003Cbr\u003Egit checkout branch3\u003Cbr\u003Egit rebase --onto branch2 (SHA-1 of F)\u003Cbr\u003E# repeat checkout + rebase for each branch\u003C/pre\u003E\n\u003Cp\u003EAnd so on. This can become tedious, especially when dealing with multiple branches.\u003C/p\u003E\n\u003Ch3\u003EEnter the --update-refs Option\u003C/h3\u003E\n\u003Cp\u003EStarting from Git 2.38 (and improved in 2.39), there’s a new flag that addresses this problem directly: --update-refs.\u003C/p\u003E\n\u003Cp\u003EThe --update-refs option is designed to automatically rebase your entire branch stack, updating all references in one go. So, instead of manually rebasing each branch, you can now do the following instead:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main\u003Cbr\u003Egit checkout branch3  # Checkout the farthest branch in your stack\u003Cbr\u003Egit rebase main --update-refs  # This will rebase the entire tree\u003C/pre\u003E\n\u003Cp\u003EAchieving it effectively in one command:\u003C/p\u003E\n\u003Cpre\u003E                  G'--H'--I'   &lt;-- branch3\u003Cbr\u003E                 /\u003Cbr\u003E       D'--E'--F'   &lt;-- branch2\u003Cbr\u003E      /\u003Cbr\u003E  M--S  &lt;-- main, origin/main\u003C/pre\u003E\n\u003Cblockquote\u003ETip: If you want to avoid adding the --update-refs flag every time you rebase you can set this as the default behavior by adding the following configuration to your .gitconfig:\u003C/blockquote\u003E\n\u003Cpre\u003Egit config --global --add rebase.updateRefs true\u003C/pre\u003E\n\u003Cp\u003EBut we aren’t done yet. We still need to push them to the remote… And nobody likes to do that one by one…\u003C/p\u003E\n\u003Ch3\u003EThe Final Hurdle: Pushing Updated Branches\u003C/h3\u003E\n\u003Cp\u003EAfter rebasing, pushing all the updated branches can still be a bit of a hassle. Thankfully, you can loop through them with the for-each-ref command with the merged option and push them:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main &amp;&amp; \\\u003Cbr\u003Egit rebase --update-refs main &amp;&amp; \\\u003Cbr\u003Egit for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\\u003Cbr\u003Exargs -I {} git push --force-with-lease origin {}\u003C/pre\u003E\n\u003Cblockquote\u003EThe for-each-ref combined with the --merged option only loops through your current tree without touching other unrelated branches. Use the force-with-lease to make sure you aren’t unintentionally force-pushing changes that you don’t have locally.\u003C/blockquote\u003E\n\u003Cp\u003EVoilà! Your 2, 3, 5 or 1000 branches were all rebased and pushed to the remote in one command 🤯!\u003C/p\u003E\n\u003Cp\u003EThese lines summarize the whole article:\u003C/p\u003E\n\u003Col\u003E\n\u003Cli\u003ECreate a new branch\u003C/li\u003E\n\u003Cli\u003ECommit. Commit even more.\u003C/li\u003E\n\u003Cli\u003ECreate PR\u003C/li\u003E\n\u003Cli\u003EBranch out from this point, and repeat from step 1.\u003C/li\u003E\n\u003Cli\u003EWhen your branches are merged, rebase with update-refs and push.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Cp\u003ENow, every small step forward in your development can quickly enter the code base by creating a small PR. If the previous PR wasn’t merged yet, not much of a problem; you can continuously rebase and push until it is merged.\u003C/p\u003E\n\u003Ch3\u003EWrapping up / TLDR;\u003C/h3\u003E\n\u003Cp\u003EBy adopting this workflow, you can significantly reduce the complexity of your PRs. Instead of creating a single massive PR with thousands of commits, you can stack smaller branches, each representing a different stage of your work, and assign slices of it to different teammates. Make sure that the target branch for each increment isn’t the main one, but the previous branch in the tree.\u003C/p\u003E\n\u003Cp\u003EThat way your teammates review only the relevant slice. Once the PR is approved, you can change back the target branch to main. At merging time, all the PR’s will enter like dominos since git has the avalibity to recognize the previously applied commit.\u003C/p\u003E\n\u003Cp\u003EThis approach makes it easier for reviewers to digest your changes and allows you to ‘parallelize’ the review.\u003C/p\u003E\n\u003Cp\u003EUsing the before-mentioned commands:\u003C/p\u003E\n\u003Cpre\u003Egit checkout farestBranch\u003Cbr\u003Egit fetch origin main:main &amp;&amp; \\\u003Cbr\u003Egit rebase --update-refs main &amp;&amp; \\ \u003Cbr\u003Egit for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\\u003Cbr\u003Exargs -I {} git push --force-with-lease origin {}\u003C/pre\u003E\n\u003Cp\u003EEnsures that rebasing and pushing updated branches is no longer a tedious, manual process. With this flow, you can focus more on writing quality code and less on managing your Git history.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EManaging a stack of branches isn’t a headache anymore. By using Git’s --update-refs option and automating the push process, you can maintain a clean, organized codebase and make life easier for both yourself and your reviewers.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22df25b5fe50\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50\"\u003ERebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "content": "\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NPUG8uIidQ6iUvKVmfqjzQ.jpeg\"\u003E\u003C/figure\u003E\u003Ch3\u003EIntroduction\u003C/h3\u003E\n\u003Cp\u003EQuestion: how many times did your development flow come to a standstill because a teammate didn’t review your Pull Request (PR)?\u003Cbr\u003EIt is true that PRs should have Priority Zero in any normal company. But do we all work in normal companies 😅? And even if so, sometimes your teammates are just too busy doing something else, or honestly, don’t want to review that humongous PR, or whatever.\u003C/p\u003E\n\u003Cp\u003EMeet what I call the \u003Cstrong\u003EContinuous Incremental PR Chain:\u003C/strong\u003E a flow I once answered someone in \u003Ca href=\"https://stackoverflow.com/questions/64324610/how-to-automatically-rebase-all-children-branches-onto-master-after-squashing-an/75858310#75858310\"\u003EStack Overflow\u003C/a\u003E, and now I refined it and shared it for you to use, based on continuously rebasing multiple stacked branches.\u003C/p\u003E\n\u003Cp\u003ELet’s dive in!\u003C/p\u003E\n\u003Ch3\u003EOne PR is Never Enough: A Tale of Two Developers\u003C/h3\u003E\n\u003Cp\u003ELet’s take the example of two developers. Developer A works on his branch. He creates several commits along the creation of his feature. At the end, he submits a pull request.\u003C/p\u003E\n\u003Cpre\u003E  A--B--C--D--E--F--G--H--I   &lt;-- branch1\u003Cbr\u003E /\u003Cbr\u003EM                            &lt;-- main\u003C/pre\u003E\n\u003Cp\u003E\u003Cstrong\u003EResult:\u003C/strong\u003E A large request with lots of changes since it contains a lot of commits. The unique reviewer postpones reviewing that branch to the end of the day because they don’t feel like it: it is too much code. Developer A doesn’t get to be a rockstar at the office: he might even chase his reviewer to get some feedback— \u003Cem\u003E“Every Breath You Take”\u003C/em\u003E plays in the background.\u003C/p\u003E\n\u003Cp\u003EIn contrast, Developer B creates a branch for every few commits. He keeps on working, but when he makes progress uses a new branch on top of the previous one. Where Developer A had 10 commits in 1 PR, Developer B had 3 PRs with about 3 commits each. Developer B, as soon as he finishes a batch of commits, immediately creates a PR.\u003C/p\u003E\n\u003Cpre\u003E                  G--H--I   &lt;-- branch3 #PR to branch2\u003Cbr\u003E                 /    \u003Cbr\u003E          D--E--F   &lt;-- branch2 #PR to branch1\u003Cbr\u003E         /    \u003Cbr\u003E  A--B--C     &lt;-- branch1  #PR to main\u003Cbr\u003E /\u003Cbr\u003EM      &lt;-- main\u003C/pre\u003E\n\u003Cp\u003EDeveloper B can parallelize his feedback: he assigns each PR to a different team member. Each team member quickly reviews them, since they are small changes and “don’t require too much effort”. Also, now the review is split among more developers. Multithreading, anyone? Developer B gets higher quality feedback too, by getting different inputs. Thanks to his efficiency, Developer B finishes his work earlier — \u003Cem\u003E“I’m a Survivor”\u003C/em\u003E plays in the background.\u003C/p\u003E\n\u003Cfigure\u003E\u003Cimg alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*01fxMUbhNDX6FAFxhQK0Yg.gif\"\u003E\u003C/figure\u003E\u003Cp\u003EWhich one would you rather be?\u003C/p\u003E\n\u003Ch3\u003EStacked Branches and Constant Rebasing: A pain to maintain\u003C/h3\u003E\n\u003Cp\u003ENow that I convinced you to stack branches on top of each other, you might be wondering: “Why isn’t everybody doing this?” And the answer is \u003Cem\u003Erebasing\u003C/em\u003E. Constantly rebasing several branches can be a pain in the ass. At least, without using --update-refs, a somewhat “new” option about to be 2 years old in October 2024. I was surprised by how many people at the office had never heard about it.\u003C/p\u003E\n\u003Cp\u003EAfter merging branch1 into main, or trying to update the whole tree against the remote, you’re left with a problem: you now have to manually rebase each subsequent branch onto main.\u003C/p\u003E\n\u003Cpre\u003E                  G--H--I   &lt;-- branch3\u003Cbr\u003E                 /    \u003Cbr\u003E          D--E--F   &lt;-- branch2\u003Cbr\u003E         /    \u003Cbr\u003E  A--B--C \u003Cbr\u003E /\u003Cbr\u003EM--S       &lt;-- main (branch1 changes squashed in S)\u003C/pre\u003E\n\u003Cp\u003ETypically, you would rebase each one like this🤢:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main\u003Cbr\u003Egit checkout branch2\u003Cbr\u003Egit rebase --onto master (SHA-1 of C)\u003Cbr\u003Egit checkout branch3\u003Cbr\u003Egit rebase --onto branch2 (SHA-1 of F)\u003Cbr\u003E# repeat checkout + rebase for each branch\u003C/pre\u003E\n\u003Cp\u003EAnd so on. This can become tedious, especially when dealing with multiple branches.\u003C/p\u003E\n\u003Ch3\u003EEnter the --update-refs Option\u003C/h3\u003E\n\u003Cp\u003EStarting from Git 2.38 (and improved in 2.39), there’s a new flag that addresses this problem directly: --update-refs.\u003C/p\u003E\n\u003Cp\u003EThe --update-refs option is designed to automatically rebase your entire branch stack, updating all references in one go. So, instead of manually rebasing each branch, you can now do the following instead:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main\u003Cbr\u003Egit checkout branch3  # Checkout the farthest branch in your stack\u003Cbr\u003Egit rebase main --update-refs  # This will rebase the entire tree\u003C/pre\u003E\n\u003Cp\u003EAchieving it effectively in one command:\u003C/p\u003E\n\u003Cpre\u003E                  G'--H'--I'   &lt;-- branch3\u003Cbr\u003E                 /\u003Cbr\u003E       D'--E'--F'   &lt;-- branch2\u003Cbr\u003E      /\u003Cbr\u003E  M--S  &lt;-- main, origin/main\u003C/pre\u003E\n\u003Cblockquote\u003ETip: If you want to avoid adding the --update-refs flag every time you rebase you can set this as the default behavior by adding the following configuration to your .gitconfig:\u003C/blockquote\u003E\n\u003Cpre\u003Egit config --global --add rebase.updateRefs true\u003C/pre\u003E\n\u003Cp\u003EBut we aren’t done yet. We still need to push them to the remote… And nobody likes to do that one by one…\u003C/p\u003E\n\u003Ch3\u003EThe Final Hurdle: Pushing Updated Branches\u003C/h3\u003E\n\u003Cp\u003EAfter rebasing, pushing all the updated branches can still be a bit of a hassle. Thankfully, you can loop through them with the for-each-ref command with the merged option and push them:\u003C/p\u003E\n\u003Cpre\u003Egit fetch origin main:main &amp;&amp; \\\u003Cbr\u003Egit rebase --update-refs main &amp;&amp; \\\u003Cbr\u003Egit for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\\u003Cbr\u003Exargs -I {} git push --force-with-lease origin {}\u003C/pre\u003E\n\u003Cblockquote\u003EThe for-each-ref combined with the --merged option only loops through your current tree without touching other unrelated branches. Use the force-with-lease to make sure you aren’t unintentionally force-pushing changes that you don’t have locally.\u003C/blockquote\u003E\n\u003Cp\u003EVoilà! Your 2, 3, 5 or 1000 branches were all rebased and pushed to the remote in one command 🤯!\u003C/p\u003E\n\u003Cp\u003EThese lines summarize the whole article:\u003C/p\u003E\n\u003Col\u003E\n\u003Cli\u003ECreate a new branch\u003C/li\u003E\n\u003Cli\u003ECommit. Commit even more.\u003C/li\u003E\n\u003Cli\u003ECreate PR\u003C/li\u003E\n\u003Cli\u003EBranch out from this point, and repeat from step 1.\u003C/li\u003E\n\u003Cli\u003EWhen your branches are merged, rebase with update-refs and push.\u003C/li\u003E\n\u003C/ol\u003E\n\u003Cp\u003ENow, every small step forward in your development can quickly enter the code base by creating a small PR. If the previous PR wasn’t merged yet, not much of a problem; you can continuously rebase and push until it is merged.\u003C/p\u003E\n\u003Ch3\u003EWrapping up / TLDR;\u003C/h3\u003E\n\u003Cp\u003EBy adopting this workflow, you can significantly reduce the complexity of your PRs. Instead of creating a single massive PR with thousands of commits, you can stack smaller branches, each representing a different stage of your work, and assign slices of it to different teammates. Make sure that the target branch for each increment isn’t the main one, but the previous branch in the tree.\u003C/p\u003E\n\u003Cp\u003EThat way your teammates review only the relevant slice. Once the PR is approved, you can change back the target branch to main. At merging time, all the PR’s will enter like dominos since git has the avalibity to recognize the previously applied commit.\u003C/p\u003E\n\u003Cp\u003EThis approach makes it easier for reviewers to digest your changes and allows you to ‘parallelize’ the review.\u003C/p\u003E\n\u003Cp\u003EUsing the before-mentioned commands:\u003C/p\u003E\n\u003Cpre\u003Egit checkout farestBranch\u003Cbr\u003Egit fetch origin main:main &amp;&amp; \\\u003Cbr\u003Egit rebase --update-refs main &amp;&amp; \\ \u003Cbr\u003Egit for-each-ref --format='%(refname:short)' refs/heads/ --merged | \\\u003Cbr\u003Exargs -I {} git push --force-with-lease origin {}\u003C/pre\u003E\n\u003Cp\u003EEnsures that rebasing and pushing updated branches is no longer a tedious, manual process. With this flow, you can focus more on writing quality code and less on managing your Git history.\u003C/p\u003E\n\u003Ch3\u003EConclusion\u003C/h3\u003E\n\u003Cp\u003EManaging a stack of branches isn’t a headache anymore. By using Git’s --update-refs option and automating the push process, you can maintain a clean, organized codebase and make life easier for both yourself and your reviewers.\u003C/p\u003E\n\u003Cp\u003EHappy coding!\u003C/p\u003E\n\u003Cimg src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22df25b5fe50\" width=\"1\" height=\"1\" alt=\"\"\u003E\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https://levelup.gitconnected.com/rebase-multiple-git-branches-like-a-pro-master-continuous-pr-chains-22df25b5fe50\"\u003ERebase Multiple GIT Branches Like a Pro: Creating Continuous PR Chains\u003C/a\u003E was originally published in \u003Ca href=\"https://levelup.gitconnected.com/\"\u003ELevel Up Coding\u003C/a\u003E on Medium, where people are continuing the conversation by highlighting and responding to this story.\u003C/p\u003E\n",
      "enclosure": {

      },
      "categories": [
        "pull-request",
        "git",
        "version-control",
        "gitlab",
        "github"
      ]
    }
  ]
}
